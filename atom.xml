<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuTao&#39;s Blog</title>
  
  <subtitle>while(!(succeed = try()));</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wutao18.github.io/"/>
  <updated>2020-10-27T07:07:57.881Z</updated>
  <id>http://wutao18.github.io/</id>
  
  <author>
    <name>吴涛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性回归及Python实现</title>
    <link href="http://wutao18.github.io/2020/06/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8APython%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wutao18.github.io/2020/06/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8APython%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-21T12:05:30.000Z</published>
    <updated>2020-10-27T07:07:57.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>线性模型</strong>：</p><script type="math/tex; mode=display">y = \boldsymbol{w}^T \boldsymbol{x} + b \tag{1}</script><p>数据集：$D = \{(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), … , (\boldsymbol{x}_m, y_m)\}$，$\boldsymbol{x}_i = (x_{i1}; x_{i2};…; x_{id})$</p><p><strong>损失函数</strong> (Loss function) 采用平方损失：</p><script type="math/tex; mode=display">L(\boldsymbol{w}, b) = \sum_{i=1}^m (y_i - \hat{y_i})^2</script><script type="math/tex; mode=display">= \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2\tag{2}</script><p>目标是找到一组解 $(\boldsymbol{w}^{\star}, b^{\star})$ 使得损失函数的值最小，即：</p><script type="math/tex; mode=display">(\boldsymbol{w}^*, b^*) = \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)}L(\boldsymbol{w}, b)</script><script type="math/tex; mode=display">= \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)} \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2\tag{3}</script><a id="more"></a><p>求解方法：</p><ul><li><strong>最小二乘法</strong></li><li><strong>梯度下降法</strong><ul><li>模拟退火</li><li>随机梯度下降</li></ul></li></ul><p>损失函数的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 误差函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(w, b, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line">  b = np.array(b)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  b = np.matrix(b)</span><br><span class="line">  </span><br><span class="line">  err = [[<span class="number">0.0</span>]]</span><br><span class="line">  m = len(x)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    err = err + (y[i] - w.T * x[i] - b) ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># err = err + abs(y[i,:] - w.T * x[i,:] - b)</span></span><br><span class="line">  <span class="keyword">return</span> err.tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 误差函数重载，这里的w包含了w和b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x=np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  </span><br><span class="line">  err = <span class="number">0.0</span></span><br><span class="line">  m = len(x)</span><br><span class="line">  <span class="comment"># print('-------')</span></span><br><span class="line">  <span class="comment"># print(m)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    pp= x[i] * w</span><br><span class="line">    p=(y[i] - pp.T )</span><br><span class="line">    err = err + p * p.T</span><br><span class="line">    <span class="comment"># err = err + (y[i] - x[i] * w.T ) ** 2</span></span><br><span class="line">  <span class="comment"># return math.sqrt(err.tolist()[0][0])/10</span></span><br><span class="line">  <span class="keyword">return</span> err.tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">1.</span>], [<span class="number">2.</span>]]</span><br><span class="line">y = [ <span class="number">1.</span>, <span class="number">2.</span>]</span><br><span class="line"></span><br><span class="line">print(loss_function([<span class="number">1</span>], <span class="number">0</span>, x, y))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><pre><code>0.0</code></pre><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>把 $\boldsymbol{w}$ 和 $b$ 吸收入向量形式 $\hat{\boldsymbol{w}} = (\boldsymbol{w}; b)$</p><p>把数据集 $D$ 的输入表示为一个 $m \times (d + 1)$ 大小的矩阵 $\boldsymbol{X}$</p><script type="math/tex; mode=display">\boldsymbol{X} = \left(    \begin{array}{cccc|c}      x_{11} & x_{12} & \cdots & x_{1d} & 1 \\      x_{21} & x_{22} & \cdots & x_{2d} & 1 \\      \vdots & \vdots & \ddots & \vdots & \vdots \\      x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\    \end{array}\right) = \left(    \begin{array}{c|c}      \boldsymbol{x}_{1}^T & 1 \\      \boldsymbol{x}_{2}^T & 1 \\      \vdots & \vdots \\      \boldsymbol{x}_{m}^T & 1 \\    \end{array}\right)</script><p>把输出也表示成向量形式 $\boldsymbol{y} = (y_1; y_2; …; y_n)$</p><p>式(2) 可表示为</p><script type="math/tex; mode=display">L(\hat{\boldsymbol{w}}) = (\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})^T(\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})\tag{4}</script><p>式(3) 可表示为</p><script type="math/tex; mode=display">\hat{\boldsymbol{w}}^* = \mathop{arg\ min}\limits_{\hat{\boldsymbol{w}}} (\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})^T(\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})\tag{5}</script><p>对式(4)求导可得</p><script type="math/tex; mode=display">\frac{\partial L(\hat{\boldsymbol{w}})}{\partial \hat{\boldsymbol{w}}} = 2 \boldsymbol{X}^T(\boldsymbol{X} \hat{\boldsymbol{w}} - \boldsymbol{y})\tag{6}</script><p>当 $\boldsymbol{X}^T\boldsymbol{X}$ 为满秩矩阵时（不是满秩矩阵时无法求解），令式(5)等于0可得解为</p><script type="math/tex; mode=display">\hat{\boldsymbol{w}}^* = (\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T \boldsymbol{y}\tag{7}</script><p>Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_w</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  w = (x.T * x).I * x.T * y</span><br><span class="line">  <span class="keyword">return</span> w.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小二乘法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">least_squares</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line"></span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  <span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  <span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> get_w(x, y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># x = [[1], [2], [3]]</span></span><br><span class="line"><span class="comment"># y = [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = least_squares(x, y)</span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(math.sqrt(loss_function(w0, w[<span class="number">-1</span>][<span class="number">0</span>], x, y)) / len(x))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><pre><code>31.927531989787543</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(str(w[<span class="number">0</span>][<span class="number">0</span>]) + <span class="string">' '</span> + str(w[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">600</span>]</span><br><span class="line">p2 = [<span class="number">0</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>], <span class="number">600</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>模型的解为：</p><pre><code>2.669454966762257 -188.43319665732653</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621194739.png" alt="20200621194739"></p><p>采用statsmodels库求线性回归作为对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采用statsmodels库求线性回归</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line">x = sm.add_constant(x) <span class="comment"># 若模型中有截距，必须有这一步</span></span><br><span class="line">model = sm.OLS(y, x).fit() <span class="comment"># 构建最小二乘模型并拟合</span></span><br><span class="line">print(model.summary()) <span class="comment"># 输出回归结果</span></span><br></pre></td></tr></table></figure><pre><code>                            OLS Regression Results                            ==============================================================================Dep. Variable:                      y   R-squared:                       0.944Model:                            OLS   Adj. R-squared:                  0.938Method:                 Least Squares   F-statistic:                     136.1Date:                Wed, 10 Jun 2020   Prob (F-statistic):           2.66e-06Time:                        07:28:51   Log-Likelihood:                -60.337No. Observations:                  10   AIC:                             124.7Df Residuals:                       8   BIC:                             125.3Df Model:                           1                                         Covariance Type:            nonrobust                                         ==============================================================================                 coef    std err          t      P&gt;|t|      [0.025      0.975]------------------------------------------------------------------------------const       -188.4332     67.619     -2.787      0.024    -344.363     -32.503x1             2.6695      0.229     11.667      0.000       2.142       3.197==============================================================================Omnibus:                        1.562   Durbin-Watson:                   2.661Prob(Omnibus):                  0.458   Jarque-Bera (JB):                0.877Skew:                           0.356   Prob(JB):                        0.645Kurtosis:                       1.737   Cond. No.                         560.==============================================================================Warnings:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified./usr/local/lib/python3.6/dist-packages/scipy/stats/stats.py:1535: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=10  &quot;anyway, n=%i&quot; % int(n))</code></pre><p>可以看到结果基本一致。   </p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>式(4)的梯度为</p><script type="math/tex; mode=display">\nabla L(\hat{\boldsymbol{w}}) = \left(    \begin{matrix}      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_1} \\      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_2} \\      \vdots \\      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_d} \\      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial b} \\    \end{matrix}\right)= \frac{\partial L(\hat{\boldsymbol{w}})}{\partial \hat{\boldsymbol{w}}} = 2 \boldsymbol{X}^T(\boldsymbol{X} \hat{\boldsymbol{w}} - \boldsymbol{y})\tag{8}</script><p>根据梯度下降法，不断更新 $\hat{\boldsymbol{w}}$ 去寻找 $\hat{\boldsymbol{w}}^*$。参数的更新以目标的负梯度为方向，$t$ 表示第 $t$ 次更新参数，$\eta$ 表示学习率。</p><script type="math/tex; mode=display">\hat{\boldsymbol{w}}^{(t+1)} = \hat{\boldsymbol{w}}^{(t)} - \eta \nabla L(\hat{\boldsymbol{w}}^{(t)}) \tag{9}</script><p>Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x.T * (x * w - y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">0.0000001</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line">  w[len(x[<span class="number">0</span>])][<span class="number">0</span>] = y[<span class="number">0</span>] - x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">  <span class="comment"># w=data.iloc[1:2,1:-1].values</span></span><br><span class="line">  <span class="comment"># w=np.concatenate((w, np.ones((len(w), 1))), axis=1).T</span></span><br><span class="line">  <span class="comment"># print(x)</span></span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    w = w - lr * gradient(w, x, y)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># data=pd.read_csv('final_data.csv',encoding='gb18030')</span></span><br><span class="line"><span class="comment"># x = data.iloc[:,1:-1].values</span></span><br><span class="line"><span class="comment"># y = data.iloc[:,0].values</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"><span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))  <span class="comment"># 均方误差</span></span><br></pre></td></tr></table></figure><p>模型的解及误差为：</p><pre><code>[[2.664103150270952], [-186.57092397847248]]31.929045483933738</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(str(w[<span class="number">0</span>][<span class="number">0</span>]) + <span class="string">' '</span> + str(w[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">600</span>]</span><br><span class="line">p2 = [<span class="number">0</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>], <span class="number">600</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>2.664103150270952 -186.57092397847248</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621195200.png" alt="20200621195200"></p><p>线性回归也可以求解<strong>非线性模型</strong>。如引入二次项：</p><script type="math/tex; mode=display">y = \boldsymbol{w}_2^T\left(    \begin{matrix}      x_1^2 \\      x_2^2 \\      \vdots \\      x_d^2 \\    \end{matrix}\right)+ \boldsymbol{w}_1^T\left(    \begin{matrix}      x_1 \\      x_2 \\      \vdots \\      x_d \\    \end{matrix}\right)+ b</script><p>可以把 $x_i^2$ 看成另一个特征，本质还是线性回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">1e-12</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    w = w - lr * gradient(w, x, y)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">m = len(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">  x[i].insert(<span class="number">0</span>, x[i][<span class="number">0</span>] ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">w = gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))  <span class="comment"># 均方误差</span></span><br></pre></td></tr></table></figure><pre><code>[[114244.0, 338.0], [110889.0, 333.0], [107584.0, 328.0], [42849.0, 207.0], [51076.0, 226.0], [625.0, 25.0], [32041.0, 179.0], [3600.0, 60.0], [43264.0, 208.0], [367236.0, 606.0]][640.0, 633.0, 619.0, 393.0, 428.0, 27.0, 193.0, 66.0, 226.0, 1591.0][[0.002695722750670167], [0.9906491919888195], [0.9999201489658276]]15.529527888679146</code></pre><p>可以看到误差小了一半。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p1 = [0, 600]</span></span><br><span class="line"><span class="comment"># p2 = [0 * w[0][0] + w[1][0], 600 * w[0][0] + w[1][0]]</span></span><br><span class="line">p1 = []</span><br><span class="line">p2 = []</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">print(w[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">print(w[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">  p1.append(i)</span><br><span class="line">  p2.append(i * i * w[<span class="number">0</span>][<span class="number">0</span>] + i * w[<span class="number">1</span>][<span class="number">0</span>] + w[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(p1)</span></span><br><span class="line"><span class="comment"># print(p2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>模型的解为：</p><pre><code>0.0026957227506701670.99064919198881950.9999201489658276</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621195602.png" alt="20200621195602"></p><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>模拟退火算法基于物理退火的原理，将固体加热至高温然后冷却，温度越高降温的概率越大 (降温更快)，温度越低降温的概率越小 (降温越慢)。模拟退火算法进行多次降温，直到找到一个可行解。</p><p>简单来说，如果新的状态比当前状态更优就接受该状态，否则以一定概率接受新状态。概率为：$P(\Delta E) = e^{\frac{-\Delta E}{T}}$，其中 $T$ 为当前温度，$\Delta E$ 新状态与当前状态的能量差。</p><p>模拟退火主要有三个参数：初始温度 $T_0$，降温系数 $d$，终止温度 $T_k$。</p><p>让当前温度 $T = T_0$，温度下降，尝试转移，如果转移 $T = d * T$。当 $T &lt; T_k$ 时结束模拟退火算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟退火</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulateAnneal</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  Tk = <span class="number">1e-8</span>  <span class="comment"># 终止温度</span></span><br><span class="line">  T0 = <span class="number">100</span>  <span class="comment"># 初始温度</span></span><br><span class="line">  d = <span class="number">0.5</span>  <span class="comment"># 降温系数</span></span><br><span class="line">  w = [[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x[<span class="number">0</span>]) + <span class="number">1</span>)]</span><br><span class="line">  <span class="comment"># now = loss_function(w, x, y)</span></span><br><span class="line">  <span class="comment"># nxt = now</span></span><br><span class="line">  <span class="comment"># min_value = now  # 损失函数最小值</span></span><br><span class="line">  </span><br><span class="line">  min_value = loss_function(w, x, y)  <span class="comment"># 损失函数最小值</span></span><br><span class="line">  T = T0  <span class="comment"># 当前温度</span></span><br><span class="line">  cnt = <span class="number">0</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  <span class="keyword">while</span> T &gt; Tk:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    next = []</span><br><span class="line">    mn = <span class="number">1e20</span>  <span class="comment"># 临时的最小值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">      nw = []</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">        nw.append(i.copy())</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">        nw[i][<span class="number">0</span>] = w[i][<span class="number">0</span>] + math.cos(myrand() * <span class="number">2</span> * math.pi) * T</span><br><span class="line">      </span><br><span class="line">      nE = loss_function(nw, x, y)  <span class="comment"># 新状态</span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span> mn &gt; nE:  <span class="comment"># 更新最小值</span></span><br><span class="line">        mn = nE</span><br><span class="line">        next = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nw:</span><br><span class="line">          next.append(i.copy())</span><br><span class="line">    dE = mn - min_value  <span class="comment"># 能量差</span></span><br><span class="line">    <span class="keyword">if</span> dE / T &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> dE &lt; <span class="number">0</span> <span class="keyword">or</span> math.exp(dE / T) &lt; myrand():</span><br><span class="line">      min_value = mn</span><br><span class="line">      w = []</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> next:</span><br><span class="line">        w.append(i.copy())</span><br><span class="line">    T = T * d  <span class="comment"># 降温</span></span><br><span class="line">  print(cnt)</span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myrand</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">10000</span>) / <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = simulateAnneal(x, y)</span><br><span class="line"><span class="comment"># w = w.tolist()</span></span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))</span><br></pre></td></tr></table></figure><pre><code>40[[2.5460349824125927], [-145.48637019150746]]32.72257883908066</code></pre><p>模拟退火求得的解随机性比较强，可能效果很好也可能很差，因为模拟退火能跳出局部最优解，也可能跳出全局最优解。</p><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>随机梯度下降法在计算梯度时加入随机因素，这样即便陷入局部最小点，计算出的梯度仍可能不为零，就有机会跳出局部极小继续搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x.T * (x * w - y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">0.0000001</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line">  w[len(x[<span class="number">0</span>])][<span class="number">0</span>] = y[<span class="number">0</span>] - x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    id = random.randint(<span class="number">0</span>, len(x) - <span class="number">1</span>)  <span class="comment"># 随机选择一组数据</span></span><br><span class="line">    w = w - lr * gradient(w, [x[id]], [y[id]])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = random_gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))</span><br></pre></td></tr></table></figure><pre><code>[[1.4345358411567755], [275.41894946969995]]84.25783548408097</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》周志华</a></li><li><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html" target="_blank" rel="noopener">台湾大学 李宏毅 机器学习 Machine Learning (2017,Fall)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线性模型&lt;/strong&gt;：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;y = \boldsymbol{w}^T \boldsymbol{x} + b \tag{1}&lt;/script&gt;&lt;p&gt;数据集：$D = \{(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), … , (\boldsymbol{x}_m, y_m)\}$，$\boldsymbol{x}_i = (x_{i1}; x_{i2};…; x_{id})$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt; (Loss function) 采用平方损失：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
L(\boldsymbol{w}, b) = \sum_{i=1}^m (y_i - \hat{y_i})^2&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
= \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2
\tag{2}&lt;/script&gt;&lt;p&gt;目标是找到一组解 $(\boldsymbol{w}^{\star}, b^{\star})$ 使得损失函数的值最小，即：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
(\boldsymbol{w}^*, b^*) = \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)}L(\boldsymbol{w}, b)&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
= \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)} \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2
\tag{3}&lt;/script&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://wutao18.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://wutao18.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://wutao18.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="西瓜书" scheme="http://wutao18.github.io/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Google Kick Start Round A 2020</title>
    <link href="http://wutao18.github.io/2020/03/24/Google-Kick-Start-Round-A-2020/"/>
    <id>http://wutao18.github.io/2020/03/24/Google-Kick-Start-Round-A-2020/</id>
    <published>2020-03-24T13:20:35.000Z</published>
    <updated>2020-10-27T03:28:42.545Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7" target="_blank" rel="noopener">kick start Round A 2020</a></p><a id="more"></a><h2 id="A-Allocation"><a href="#A-Allocation" class="headerlink" title="A. Allocation"></a>A. Allocation</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f56" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出 $N$ 栋房子的价格，第 $i$ 栋房子的价格为 $A_i$，你有 $B$ 美元，问最多可以买多少栋房子？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>典型的贪心问题，将所有的房子按价格从低到高排序后选取即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                b -= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Plates"><a href="#B-Plates" class="headerlink" title="B. Plates"></a>B. Plates</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d40bb" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有 $N$ 叠盘子，每叠有 $K$ 个盘子，每个盘子有个 <em>beauty value</em>，现在要拿 $P$ 个盘子，使得 <em>beauty value</em> 之和最大。拿盘子的条件：如果一个盘子的上面的盘子都被拿走了，才能拿到这个盘子。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>看完题目就想到是动态规划的题了，但是还是忍不住先暴搜试试能不能水过小数据，结果 WA 了，于是只好老老实实写 DP。</p><p>本题有一点点像多重背包。首先计算每叠盘子各自的前缀和 $sum[N][K]$，设 $dp[i][j]$ 表示前 $i$ 堆盘子中取 $j$ 个盘子的 <em>beauty value</em> 的最大值，转移方程为：</p><script type="math/tex; mode=display">dp[i][j]=max\{dp[i][j], dp[i - 1][j - l] + sum[i][l]|for\ l\ \in[0, min(j, k)]\}</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, p;</span><br><span class="line">ll a[maxn][maxn];</span><br><span class="line">ll sum[maxn][maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">                sum[i][j] = <span class="number">0</span>;</span><br><span class="line">                a[i][j] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                sum[i][j] = sum[i][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = sum[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * k; ++j) &#123;  <span class="comment">// 我这里多算了，实际上到 p 就行了</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= min(j, k); ++l) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - l] + sum[i][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n][p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Workout"><a href="#C-Workout" class="headerlink" title="C. Workout"></a>C. Workout</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f5b" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个严格递增的数，往这 $N$ 个数中间插 $K$ 个数，插入后要使所有的数仍然保持严格递增，而且要保证相邻两数的最大绝对值之差最小，求最小的绝对值之差。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我一开始想的是贪心+优先队列，先计算所有相邻两数的差值并加入到优先队列中，然后每次取出队首 $x$，将它分成 $x / 2$ 和 $x - x / 2$ 两部分，并将这两部分加入到优先队列中，操作 $K$ 次后的队首就是答案。提交后小数据过了，大数据 $WA$ 了。仔细一看小数据是 $K=1$。然后找到了反例，如 $K=4$，原数组是 $[10, 20]$，那么正确结果是 $[10, 12, 14, 16, 18, 20]$，而采用本方法得到的结果是 $[10, 12, 13, 15, 17, 20]$。</p><p>最后用的是二分答案过的，典型的最大值最小的问题。判断函数的思路：传入参数 $x$，表示答案为 $x$，然后遍历每个数 $num[i]$，如果 $num[i + 1] - num[i] &gt; x$，就插入 $num[i] + x$，如果插入的数的个数大于 $K$ 个就返回 $false$，否则返回 $true$。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll m[maxn];</span><br><span class="line">ll tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tmp[i + <span class="number">1</span>] - tmp[i] &gt; x) &#123;</span><br><span class="line">            tmp[i] += x;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = inf;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                tmp[i] = m[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge(mid)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Bundling"><a href="#D-Bundling" class="headerlink" title="D. Bundling"></a>D. Bundling</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3ff3" target="_blank" rel="noopener">题目链接</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个字符串，把它们分组，每组 $K$ 个。每组的分数是该组所有字符串的最长公共前缀。求最大的所有组的分数和。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>很容易想到前缀树 (字典树 / trie 树)，建完树后从根节点 $dfs$，同时记录深度 $d$，然后从叶子节点回溯，统计每个节点出现的个数 $cnt$，如果某个节点 $u$ 的 $cnt[u] ≥ K$，那么说明有 $K$ 个字符串的前缀是以该节点结尾，深度 $d$ 表示它们的前缀的长度，由于是从叶子节点回溯的，所以一定是最长公共前缀，所以 $ans = ans + d$，同时 $cnt[u]$ 减去 $k$，即这 $k$ 个字符串已经分完组，不再分到其他组。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[maxn &lt;&lt; <span class="number">2</span>][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = ch - <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[p][id]) &#123;</span><br><span class="line">            trie[p][id] = tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = trie[p][id];</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="number">26</span>; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(trie[u][v]) &#123;</span><br><span class="line">            dfs(trie[u][v], d + <span class="number">1</span>);</span><br><span class="line">            cnt[u] += cnt[trie[u][v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt[u] &gt;= k) &#123;</span><br><span class="line">        cnt[u] -= k;</span><br><span class="line">        ans += d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛链接：&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kick start Round A 2020&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://wutao18.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DFS" scheme="http://wutao18.github.io/tags/DFS/"/>
    
      <category term="贪心" scheme="http://wutao18.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="二分" scheme="http://wutao18.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="排序" scheme="http://wutao18.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="前缀和" scheme="http://wutao18.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="Trie/字典树/前缀树" scheme="http://wutao18.github.io/tags/Trie-%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ bitset的使用</title>
    <link href="http://wutao18.github.io/2019/11/23/C-bitset%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wutao18.github.io/2019/11/23/C-bitset%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-11-23T14:08:50.000Z</published>
    <updated>2020-10-27T03:27:07.740Z</updated>
    
    <content type="html"><![CDATA[<p>bitset 一般代替 bool 数组使用，常用于优化空间，因为 bitset 中一个元素只占 1 bit。</p><a id="more"></a><p>bitset 的大小在定义使就需要确定。如果想要不定长的 bitset，就需要使用 vector<bool>。</p><p>bitset 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bt;  <span class="comment">// 定义大小为16的bitset，每一位都是0</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;16&gt; <span class="title">bt</span><span class="params">(<span class="built_in">string</span>(<span class="string">"11001"</span>))</span></span>;  <span class="comment">// 定义大小为16的bitset，并用string初始化，注意高位为0，也就是 0000000000011001</span></span><br></pre></td></tr></table></figure><p>bitset 可以直接使用 cin 和 cout 输入输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bt &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>bitset 可以像数组一样访问或修改某一位置的元素，注意0表示低位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;8&gt; bt;</span><br><span class="line">bt[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure><p>bitset 也可以像一个数一样进行位运算：与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)。</p><p>常用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;8&gt; bt;</span><br><span class="line">bt.size(); <span class="comment">// 返回大小</span></span><br><span class="line">bt.count(); <span class="comment">// 返回1的个数</span></span><br><span class="line">bt.<span class="built_in">set</span>(); <span class="comment">// 全部置1</span></span><br><span class="line">bt.<span class="built_in">set</span>(pos);  <span class="comment">// pos位置1</span></span><br><span class="line">bt.reset();  <span class="comment">// 全部置0</span></span><br><span class="line">bt.reset(pos);  <span class="comment">// pos位置0</span></span><br><span class="line">bt.flip(); <span class="comment">// 全部取反</span></span><br><span class="line">bt.flip(pos); <span class="comment">// pos位取反</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bitset 一般代替 bool 数组使用，常用于优化空间，因为 bitset 中一个元素只占 1 bit。&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="STL" scheme="http://wutao18.github.io/tags/STL/"/>
    
      <category term="编程语言" scheme="http://wutao18.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++" scheme="http://wutao18.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1121 Damn Single</title>
    <link href="http://wutao18.github.io/2019/11/22/PTA-1121-Damn-Single/"/>
    <id>http://wutao18.github.io/2019/11/22/PTA-1121-Damn-Single/</id>
    <published>2019-11-22T15:34:17.000Z</published>
    <updated>2020-10-27T04:01:02.767Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805352359378944" target="_blank" rel="noopener">1121 Damn Single (25 分)</a></p><blockquote><p>“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.</p></blockquote><a id="more"></a><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID’s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (≤ 10,000) followed by M ID’s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (重婚) or dangling with more than one companion.</p></blockquote><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote><p>First print in a line the total number of lonely guests. Then in the next line, print their ID’s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">11111 22222</span><br><span class="line">33333 44444</span><br><span class="line">55555 66666</span><br><span class="line">7</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10000 23333 44444 55555 88888</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定情侣关系，然后给出一次宴会上出席的人，问这些人中有多少单身狗 (伴侣没来的也算)。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>记录情侣关系，然后找出出席的人中不在情侣关系中的人以及伴侣没有来的人即可。</p><p>注意输出要补零，最后一行不用换行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> couple[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        couple[x] = y;</span><br><span class="line">        couple[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; party;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        party.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = couple[party[i]];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="number">-1</span>) &#123;</span><br><span class="line">            ans.insert(party[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(party.begin(), party.end(), tmp) == party.end()) &#123;</span><br><span class="line">                ans.insert(party[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.begin(); it != ans.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it != ans.begin()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, *it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805352359378944&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1121 Damn Single (25 分)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="STL" scheme="http://wutao18.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1269 迷宫城堡 (Kosaraju)</title>
    <link href="http://wutao18.github.io/2019/11/21/HDU-1269-%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1-Kosaraju/"/>
    <id>http://wutao18.github.io/2019/11/21/HDU-1269-%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1-Kosaraju/</id>
    <published>2019-11-21T14:30:56.000Z</published>
    <updated>2020-10-27T03:29:25.800Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1269" target="_blank" rel="noopener">HDU 1269</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+2006-4+Programming+Contest+&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">HDU 2006-4 Programming Contest</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求强连通分量的模板题。</p><p>这里使用的是 Kosaraju 算法。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn], rg[maxn];  <span class="comment">// 原图和反图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 时间戳</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> sccno[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// 强连通分量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">        rg[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">memset</span>(sccno, <span class="number">0</span>, <span class="keyword">sizeof</span>(sccno));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line">        dfs1(g[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sccno[u]) <span class="keyword">return</span>;</span><br><span class="line">    sccno[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rg[u].size(); ++i) &#123;</span><br><span class="line">        dfs2(rg[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dfs1(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!sccno[s[i]]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            dfs2(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">            rg[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        Kosaraju(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (cnt == <span class="number">1</span>? <span class="string">"Yes"</span>: <span class="string">"No"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 1269&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&amp;lt;=10000)和M条通道(M&amp;lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="强连通分量" scheme="http://wutao18.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="模板题" scheme="http://wutao18.github.io/tags/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
      <category term="Kosaraju" scheme="http://wutao18.github.io/tags/Kosaraju/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1154 Vertex Coloring</title>
    <link href="http://wutao18.github.io/2019/11/20/PTA-1154-Vertex-Coloring/"/>
    <id>http://wutao18.github.io/2019/11/20/PTA-1154-Vertex-Coloring/</id>
    <published>2019-11-20T14:38:37.000Z</published>
    <updated>2020-10-27T04:01:06.841Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552" target="_blank" rel="noopener">1154 Vertex Coloring</a></p><blockquote><p>A <strong>proper vertex coloring</strong> is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most $k$ colors is called a (proper) $k$-<strong>coloring</strong>.</p><p>Now you are supposed to tell if a given coloring is a proper $k$-coloring.</p></blockquote><a id="more"></a><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote><p>Each input file contains one test case. For each case, the first line gives two positive integers $N$ and $M$ (both no more than $10​^4$), being the total numbers of vertices and edges, respectively. Then $M$ lines follow, each describes an edge by giving the indices (from $0$ to $N−1$) of the two ends of the edge.</p><p>After the graph, a positive integer $K (≤ 100)$ is given, which is the number of colorings you are supposed to check. Then $K$ lines follow, each contains $N$ colors which are represented by non-negative integers in the range of <strong>int</strong>. The $i$-th color is the color of the $i$-th vertex.</p></blockquote><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote><p>For each coloring, print in a line <code>k-coloring</code> if it is a proper <code>k</code>-coloring for some positive <code>k</code>, or <code>No</code> if not.</p></blockquote><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 11</span><br><span class="line">8 7</span><br><span class="line">6 8</span><br><span class="line">4 5</span><br><span class="line">8 4</span><br><span class="line">8 1</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">9 8</span><br><span class="line">9 1</span><br><span class="line">1 0</span><br><span class="line">2 4</span><br><span class="line">4</span><br><span class="line">0 1 0 1 4 1 0 1 3 0</span><br><span class="line">0 1 0 1 4 1 0 1 0 0</span><br><span class="line">8 1 0 1 4 1 0 5 3 0</span><br><span class="line">1 2 3 4 5 6 7 8 8 9</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4-coloring</span><br><span class="line">No</span><br><span class="line">6-coloring</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个图，以及每个顶点的颜色，问是否所有边连接的两个顶点颜色不同。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举每一条边即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> colors[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        edges[i] = &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; colors[i];</span><br><span class="line">            mp[colors[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line">            <span class="keyword">if</span>(colors[x] == colors[y]) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mp.size() &lt;&lt; <span class="string">"-coloring"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1154 Vertex Coloring&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;proper vertex coloring&lt;/strong&gt; is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most $k$ colors is called a (proper) $k$-&lt;strong&gt;coloring&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now you are supposed to tell if a given coloring is a proper $k$-coloring.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="枚举" scheme="http://wutao18.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="STL" scheme="http://wutao18.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1155 Heap Paths (DFS)</title>
    <link href="http://wutao18.github.io/2019/11/19/PTA-1155-Heap-Paths-DFS/"/>
    <id>http://wutao18.github.io/2019/11/19/PTA-1155-Heap-Paths-DFS/</id>
    <published>2019-11-19T13:16:29.000Z</published>
    <updated>2020-10-27T04:01:10.950Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552" target="_blank" rel="noopener">1155 Heap Paths (30 分)</a></p><blockquote><p>In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure</a>))</p><p>One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.</p><p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p></blockquote><a id="more"></a><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote><p>Each input file contains one test case. For each case, the first line gives a positive integer $N (1&lt;N≤1,000)$, the number of keys in the tree. Then the next line contains $N$ distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.</p></blockquote><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote><p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p><p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p></blockquote><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">98 72 86 60 65 12 23 50</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">98 86 23</span><br><span class="line">98 86 12</span><br><span class="line">98 72 65</span><br><span class="line">98 72 60 50</span><br><span class="line">Max Heap</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">8 38 25 58 52 82 70 60</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8 25 70</span><br><span class="line">8 25 82</span><br><span class="line">8 38 52</span><br><span class="line">8 38 58 60</span><br><span class="line">Min Heap</span><br></pre></td></tr></table></figure><h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">10 28 15 12 34 9 8 56</span><br></pre></td></tr></table></figure><h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 15 8</span><br><span class="line">10 15 9</span><br><span class="line">10 28 34</span><br><span class="line">10 28 12 56</span><br><span class="line">Not Heap</span><br></pre></td></tr></table></figure><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $N$ 的数组，输出从根节点到叶子结点的每一条路径，并且判断是否是堆。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接 dfs 输出路径。设立两个变量 Max 和 Min 统计父节点比子节点大的个数和父节点比子节点小的个数。如果两者都不为 0，说明不是堆；如果 Max 为 0，说明是小顶堆，如果 Min 为 0，说明是大顶堆。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">11</span>];  <span class="comment">// 保存路径</span></span><br><span class="line"><span class="keyword">int</span> Max = <span class="number">0</span>, Min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    path[step] = arr[id];</span><br><span class="line">    <span class="keyword">if</span>(id * <span class="number">2</span> &gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; step; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; path[step] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = id * <span class="number">2</span>, r = id * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 左右儿子结点</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &lt; arr[r]) ++Min;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &gt; arr[r]) ++Max;</span><br><span class="line">        dfs(step + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &lt; arr[l]) ++Min;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &gt; arr[l]) ++Max;</span><br><span class="line">        dfs(step + <span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(Min == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Max == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Min Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1155 Heap Paths (30 分)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/Heap_(data_structure&lt;/a&gt;))&lt;/p&gt;
&lt;p&gt;One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.&lt;/p&gt;
&lt;p&gt;Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="DFS" scheme="http://wutao18.github.io/tags/DFS/"/>
    
      <category term="堆" scheme="http://wutao18.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>HDU 2063 过山车 (匈牙利算法)</title>
    <link href="http://wutao18.github.io/2019/11/18/HDU-2063-%E8%BF%87%E5%B1%B1%E8%BD%A6-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://wutao18.github.io/2019/11/18/HDU-2063-%E8%BF%87%E5%B1%B1%E8%BD%A6-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-18T12:49:28.000Z</published>
    <updated>2020-10-27T03:30:45.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU-2063-过山车-匈牙利算法"><a href="#HDU-2063-过山车-匈牙利算法" class="headerlink" title="HDU 2063 过山车 (匈牙利算法)"></a>HDU 2063 过山车 (匈牙利算法)</h1><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener">HDU 2063</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000<br>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 3 3</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=RPG%D7%A8%B3%A1%C1%B7%CF%B0%C8%FC&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">RPG专场练习赛</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分图最大匹配。</p><p>可以用最大流解决。也可以用匈牙利算法。匈牙利算法是最大流方法的一种优化。若采用邻接矩阵存图，时间复杂度 $O(V^2)$，空间复杂度 $O(V^2)$。若采用邻接表，时间复杂度 $O(VE)$，空间复杂度 $O(V+E)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], ok[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; g[x][i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ok[i] || dfs(ok[i])) &#123;</span><br><span class="line">                ok[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(ok, <span class="number">0</span>, <span class="keyword">sizeof</span>(ok));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            g[a][b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i)) ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HDU-2063-过山车-匈牙利算法&quot;&gt;&lt;a href=&quot;#HDU-2063-过山车-匈牙利算法&quot; class=&quot;headerlink&quot; title=&quot;HDU 2063 过山车 (匈牙利算法)&quot;&gt;&lt;/a&gt;HDU 2063 过山车 (匈牙利算法)&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2063&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 2063&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="匈牙利算法" scheme="http://wutao18.github.io/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分图" scheme="http://wutao18.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流" scheme="http://wutao18.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>HDU 2512 一卡通大冒险 (第二类斯特林数)</title>
    <link href="http://wutao18.github.io/2019/11/17/HDU-2512-%E4%B8%80%E5%8D%A1%E9%80%9A%E5%A4%A7%E5%86%92%E9%99%A9-%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    <id>http://wutao18.github.io/2019/11/17/HDU-2512-%E4%B8%80%E5%8D%A1%E9%80%9A%E5%A4%A7%E5%86%92%E9%99%A9-%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</id>
    <published>2019-11-17T15:19:51.000Z</published>
    <updated>2020-10-27T03:31:00.881Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2512" target="_blank" rel="noopener">HDU 2512</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划”一卡通大冒险”。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡”遗失”在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：</p><p>((A),(B),(C)) , ((A,B),(C)), ((B,C),(A)), ((A,C),(B)) ,((A,B,C)) 于是，</p><p>这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>包含多组数据，第一行为n，表示接下来有n组数据。以下每行一个数x，表示共有x张一卡通。(1≤x≤2000).</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>对每组数据，输出一行：不同的方法数，因为这个数可能非常大，我们只需要它除以1000的余数。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">751</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将 $n$ 个各不相同的物品放到若干个相同的盒子，很明显就是第二类 Stirling 数。</p><p>题目中要把 $1$ 到 $n$ 个盒子的方案数加起来。该方案总数也称为贝尔 (Bell) 数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        s[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        s[i][i] = <span class="number">1</span>;</span><br><span class="line">        sum[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + j * s[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            sum[i] = (sum[i] + s[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2512&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 2512&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划”一卡通大冒险”。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡”遗失”在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：&lt;/p&gt;
&lt;p&gt;((A),(B),(C)) , ((A,B),(C)), ((B,C),(A)), ((A,C),(B)) ,((A,B,C)) 于是，&lt;/p&gt;
&lt;p&gt;这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="数学" scheme="http://wutao18.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合数学" scheme="http://wutao18.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="斯特林数/Stirling number" scheme="http://wutao18.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0-Stirling-number/"/>
    
  </entry>
  
  <entry>
    <title>PTA 1067 Sort with Swap(0, i) (贪心)</title>
    <link href="http://wutao18.github.io/2019/11/16/PTA-1067-Sort-with-Swap-0-i-%E8%B4%AA%E5%BF%83/"/>
    <id>http://wutao18.github.io/2019/11/16/PTA-1067-Sort-with-Swap-0-i-%E8%B4%AA%E5%BF%83/</id>
    <published>2019-11-16T15:40:53.000Z</published>
    <updated>2020-10-27T06:15:37.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PTA-1067-Sort-with-Swap-0-i-贪心"><a href="#PTA-1067-Sort-with-Swap-0-i-贪心" class="headerlink" title="PTA 1067 Sort with Swap(0, i) (贪心)"></a>PTA 1067 Sort with Swap(0, i) (贪心)</h1><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560" target="_blank" rel="noopener">1067 Sort with Swap(0, i) (25 分)</a></p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/16/1573916930346-1573916930573.png" alt=""></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的排列，如果每次只能把某个数和第 $0$ 个数交换，那么要使排列是升序的最少需要交换几次。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>贪心</strong></p><p>由于是排列，所以排序后第 $i$ 个位置上的数就是 $i$。所以当 $a[0] \neq 0$ 时，把 $a[0]$ 位置上的元素交换到相应位置。如果 $a[0] = 0$，就找到第一个不在正确位置上的数，把它与第 $0$ 个数交换，那么下一次又是第一种情况了，也就是下一次交换可以换到正确的位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            swap(arr[<span class="number">0</span>], arr[arr[<span class="number">0</span>]]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; c &lt; n &amp;&amp; arr[c] == c; ++c);</span><br><span class="line">            <span class="keyword">if</span> (c == n) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr[<span class="number">0</span>], arr[c]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PTA-1067-Sort-with-Swap-0-i-贪心&quot;&gt;&lt;a href=&quot;#PTA-1067-Sort-with-Swap-0-i-贪心&quot; class=&quot;headerlink&quot; title=&quot;PTA 1067 Sort with Swap(0, i) (贪心)&quot;&gt;&lt;/a&gt;PTA 1067 Sort with Swap(0, i) (贪心)&lt;/h1&gt;&lt;p&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1067 Sort with Swap(0, i) (25 分)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/16/1573916930346-1573916930573.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定长度为 $n$ 的排列，如果每次只能把某个数和第 $0$ 个数交换，那么要使排列是升序的最少需要交换几次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="贪心" scheme="http://wutao18.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="思维" scheme="http://wutao18.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4513 吉哥系列故事——完美队形II (Manacher)</title>
    <link href="http://wutao18.github.io/2019/11/15/HDU-4513-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2II-Manacher/"/>
    <id>http://wutao18.github.io/2019/11/15/HDU-4513-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2II-Manacher/</id>
    <published>2019-11-15T15:05:08.000Z</published>
    <updated>2020-10-27T03:31:23.050Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4513" target="_blank" rel="noopener">HDU 4513</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>吉哥又想出了一个新的完美队形游戏！</p><p>假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] … h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：</p><p>1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；</p><p>2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；</p><p>3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &lt;= H[2] &lt;= H[3] …. &lt;= H[mid]。</p><p>现在吉哥想知道：最多能选出多少人组成新的完美队形呢？</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>输入数据第一行包含一个整数T，表示总共有T组测试数据(T &lt;= 20)；</p><p>每组数据首先是一个整数n(1 &lt;= n &lt;= 100000)，表示原先队形的人数，接下来一行输入n个整数，表示原队形从左到右站的人的身高（50 &lt;= h &lt;= 250，不排除特别矮小和高大的）。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>请输出能组成完美队形的最多人数，每组输出占一行。</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">51 52 51</span><br><span class="line">4</span><br><span class="line">51 52 52 51</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2013%CC%DA%D1%B6%B1%E0%B3%CC%C2%ED%C0%AD%CB%C9%B3%F5%C8%FC%B5%DA%B6%FE%B3%A1%A3%A83%D4%C222%C8%D5%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2013腾讯编程马拉松初赛第二场（3月22日）</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在 Manacher 求最长回文子串时增加一个判断条件: h[i - len[i]] &lt;= h[i - len[i] + 2]</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[maxn &lt;&lt; <span class="number">1</span>], len[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n * <span class="number">2</span> + <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h[i - len[i]] == h[i + len[i]] &amp;&amp; h[i - len[i]] &lt;= h[i - len[i] + <span class="number">2</span>]) &#123;  <span class="comment">// 这里要保持递增</span></span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        h[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            h[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; h[i * <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        h[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 4513&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;吉哥又想出了一个新的完美队形游戏！&lt;/p&gt;
&lt;p&gt;假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] … h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：&lt;/p&gt;
&lt;p&gt;1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；&lt;/p&gt;
&lt;p&gt;2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；&lt;/p&gt;
&lt;p&gt;3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &amp;lt;= H[2] &amp;lt;= H[3] …. &amp;lt;= H[mid]。&lt;/p&gt;
&lt;p&gt;现在吉哥想知道：最多能选出多少人组成新的完美队形呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="Manacher" scheme="http://wutao18.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3974 Palindrome (Manacher)</title>
    <link href="http://wutao18.github.io/2019/11/14/POJ-3974-Palindrome-Manacher/"/>
    <id>http://wutao18.github.io/2019/11/14/POJ-3974-Palindrome-Manacher/</id>
    <published>2019-11-14T13:59:48.000Z</published>
    <updated>2020-10-27T04:00:53.291Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3974" target="_blank" rel="noopener">POJ 3974</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?”</p><p>A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not.</p><p>The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”.</p><p>If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>Your program will be tested on at most 30 test cases, each test case is given as a string of at most 1000000 lowercase characters on a line by itself. The input is terminated by a line that starts with the string “END” (quotes for clarity).</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case in the input print the test case number and the length of the largest palindrome.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Seventh+ACM+Egyptian+National+Programming+Contest" target="_blank" rel="noopener">Seventh ACM Egyptian National Programming Contest</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串，求最长回文子串。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Manacher 模板题。</p><p>有关 Manacher 算法的讲解见<a href="https://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/">这里</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;</span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"END"</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp = init(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; (++kase) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher(tmp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=3974&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 3974&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?”&lt;/p&gt;
&lt;p&gt;A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not.&lt;/p&gt;
&lt;p&gt;The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”.&lt;/p&gt;
&lt;p&gt;If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="模板题" scheme="http://wutao18.github.io/tags/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
      <category term="字符串" scheme="http://wutao18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Manacher" scheme="http://wutao18.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串 —— Manacher (马拉车) 算法</title>
    <link href="http://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/"/>
    <id>http://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-13T15:48:28.000Z</published>
    <updated>2020-10-27T06:19:03.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>回文串</strong>就是原串和反转字符串相同的字符串。比如 <code>aba</code>，<code>acca</code>。前一个是奇数长度的回文串，后一个是偶数长度的回文串。</p><p><strong>最长回文子串</strong>就是一个字符串的所有子串中，是回文串且长度最长的子串。</p><a id="more"></a><h2 id="Brute-Force-做法"><a href="#Brute-Force-做法" class="headerlink" title="Brute Force 做法"></a>Brute Force 做法</h2><p>枚举所有子串，判断是否是回文串，然后寻找最大长度。寻找所有子串要两重循环，判断是否是回文要一重循环，总体时间复杂度 $O(n^3)$。</p><p>稍微优化一下，可以枚举对称中心，然后向两边扩展，直到遇到两个不同的字符，枚举下一个对称中心，寻找其中的最大长度，时间复杂度 $O(n^2)$。</p><p>还可以使用 DP 解决，求原串与反转字符串的最长公共子序列 (LCS)，时间复杂度 $O(n^2)$。</p><h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>接下来就是重点了，Manacher 算法，在1975年由一个叫 <a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#CITEREFManacher1975" target="_blank" rel="noopener">Manacher</a> 的人发明的。能够在 $O(n)$ 的时间求得最长回文子串。</p><p>前面提到，回文串有奇数长度的和偶数长度的，分类讨论有些复杂，可以参考<a href="https://oi-wiki.org/string/manacher/" target="_blank" rel="noopener">这里</a>。为了避免分类讨论，可以使用一个技巧：在字符串首尾以及每两个字符之间插入一个 <code>&#39;#&#39;</code>。比如 <code>abaacca</code>，转换后就是 <code>#a#b#a#a#c#c#a#</code>。那么不管是奇回文 <code>aba</code> 还是偶回文 <code>acca</code>，转换后都是奇回文 (<code>#a#b#a#</code> 和 <code>#a#c#c#a#</code>)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;  <span class="comment">// 在开头加入哨兵防止越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;  <span class="comment">// 结尾同样加入哨兵防止越界</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manacher 算法的思想来自于上述枚举对称中心的思想。该算法需要维护一个 $len$ 数组，$len[i]$ 代表 $i$ 为中心的最长回文子串的长度。</p><p>设 $s$ 为原字符串，$mx$ 为之前计算的回文串中右端点的最大值，这个回文串的中心位置为 $id$，也就是 $mx = id + len[id]$。</p><p>每次计算的时候，$id$ 的右边和左边是对称的，因此计算右边的时候不需要用从对称中心向两边扩展的思想，而是只用一行代码解决：<code>len[i] = min(mx - i, len[2 * id - i]);</code>，这也是 Manacher 中最关键的一行代码。</p><p>如下图所示，$id$ 右边到 $mx$ 之间的子串与 $id$ 左边是对称的，所以右边的 $len[i]$ 最大长度为左边与之对称的 $len[2\times id - i]$，由于右边的回文串不能超过 $mx$ (原因见第 2 张图)，所以 <code>len[i] = min(mx - i, len[2 * id - i]);</code>。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/13/1573657779673-1573657779889.png" alt=""></p><p>$id$ 右边的回文串长度不能超过 $mx - i$ 的原因是，如果 $len[2 * id - i]$ 更长，如下图的黄色部分，那么右边的黄色部分与左边的黄色部分相同，那么黑色部分应该可以更长，产生矛盾。</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/13/1573658827030-1573658827032.png" alt=""></p><p>理解了上面的内容基本上就理解了 Manacher 算法了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);  <span class="comment">// 上面提到的最关键的一行代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;  <span class="comment">// 如果 i 超过右边界要从头计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;  <span class="comment">// 从头计算的方法，就是上面提到的从中心向两边扩展</span></span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 mx 和 id</span></span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i]; </span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>; <span class="comment">// len[i] 中的最大值-1 即为原串的最长回文子串长度 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板题：HDU-3068-最长回文"><a href="#模板题：HDU-3068-最长回文" class="headerlink" title="模板题：HDU 3068 最长回文"></a>模板题：HDU 3068 最长回文</h2><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" target="_blank" rel="noopener">HDU 3068 最长回文</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;</span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp = init(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher(tmp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/csdn_kou/article/details/82917937" target="_blank" rel="noopener">Manacher算法图解</a></p><p><a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">Manacher算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;回文串&lt;/strong&gt;就是原串和反转字符串相同的字符串。比如 &lt;code&gt;aba&lt;/code&gt;，&lt;code&gt;acca&lt;/code&gt;。前一个是奇数长度的回文串，后一个是偶数长度的回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最长回文子串&lt;/strong&gt;就是一个字符串的所有子串中，是回文串且长度最长的子串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="笔记" scheme="http://wutao18.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ACM学习" scheme="http://wutao18.github.io/tags/ACM%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="字符串" scheme="http://wutao18.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Manacher" scheme="http://wutao18.github.io/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>LightOJ 1418 Trees on My Island (Pick定理)</title>
    <link href="http://wutao18.github.io/2019/11/12/LightOJ-1418-Trees-on-My-Island-Pick%E5%AE%9A%E7%90%86/"/>
    <id>http://wutao18.github.io/2019/11/12/LightOJ-1418-Trees-on-My-Island-Pick%E5%AE%9A%E7%90%86/</id>
    <published>2019-11-12T15:29:12.000Z</published>
    <updated>2020-10-27T06:19:03.214Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/LightOJ-1418" target="_blank" rel="noopener">LightOJ 1418</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>I have bought an island where I want to plant trees in rows and columns. So, the trees will form a rectangular grid and each of them can be thought of having integer coordinates by taking a suitable grid point as the origin.</p><p>But, the problem is that the island itself is not rectangular. So, I have identified a simple polygonal area inside the island with vertices on the grid points and have decided to plant trees on grid points lying strictly inside the polygon.</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/12/1573572162954-1573572163167.png" alt=""></p><p>Figure: A sample of my island</p><p>For example, in the above figure, the green circles form the polygon, and the blue circles show the position of the trees.</p><p>Now, I seek your help for calculating the number of trees that can be planted on my island.</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>Input starts with an integer $T (≤ 100)$, denoting the number of test cases.</p><p>Each case starts with a line containing an integer $N (3 ≤ N ≤ 10000)$ denoting the number of vertices of the polygon.</p><p>Each of the next $N$ lines contains two integers $x_i y_i (-10^6 ≤ x_i, y_i ≤ 10^6)$ denoting the co-ordinate of a vertex. The vertices will be given in clockwise or anti-clockwise order. And they will form a simple polygon.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each case, print the case number and the total number of trees that can be planted inside the polygon.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">4 1</span><br><span class="line"></span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">6 2</span><br><span class="line"></span><br><span class="line">6 4</span><br><span class="line"></span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">1 5</span><br><span class="line"></span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 8</span><br></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote><p>Dataset is huge, use faster I/O methods.</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个多边形，顶点都在格点上，求多边形内部的格点个数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://oi-wiki.org/geometry/pick/" target="_blank" rel="noopener">Pick 定理</a> 裸题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll x, y;</span><br><span class="line">    Point(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll on = <span class="number">0</span>;</span><br><span class="line">        ll s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s += (p[i + <span class="number">1</span>] - p[<span class="number">0</span>]).cross(p[i] - p[<span class="number">0</span>]);</span><br><span class="line">            on += gcd(<span class="built_in">abs</span>(p[i].x - p[i + <span class="number">1</span>].x), <span class="built_in">abs</span>(p[i].y - p[i + <span class="number">1</span>].y));</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">abs</span>(s);</span><br><span class="line">        ll in = s / <span class="number">2</span> - on / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, _);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://vjudge.net/problem/LightOJ-1418&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LightOJ 1418&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;I have bought an island where I want to plant trees in rows and columns. So, the trees will form a rectangular grid and each of them can be thought of having integer coordinates by taking a suitable grid point as the origin.&lt;/p&gt;
&lt;p&gt;But, the problem is that the island itself is not rectangular. So, I have identified a simple polygonal area inside the island with vertices on the grid points and have decided to plant trees on grid points lying strictly inside the polygon.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/12/1573572162954-1573572163167.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Figure: A sample of my island&lt;/p&gt;
&lt;p&gt;For example, in the above figure, the green circles form the polygon, and the blue circles show the position of the trees.&lt;/p&gt;
&lt;p&gt;Now, I seek your help for calculating the number of trees that can be planted on my island.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="计算几何" scheme="http://wutao18.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="Pick定理" scheme="http://wutao18.github.io/tags/Pick%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1410 Intersection (计算几何)</title>
    <link href="http://wutao18.github.io/2019/11/11/POJ-1410-Intersection-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    <id>http://wutao18.github.io/2019/11/11/POJ-1410-Intersection-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</id>
    <published>2019-11-11T14:45:33.000Z</published>
    <updated>2020-10-27T06:19:03.214Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1410" target="_blank" rel="noopener">POJ 1410</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>You are to write a program that has to decide whether a given line segment intersects a given rectangle. </p><p>An example: </p><p>line: start point: (4,9) </p><p>end point: (11,2) </p><p>rectangle: left-top: (1,5) </p><p>right-bottom: (7,1) </p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/11/1573482242971-1573482243153.png" alt=""></p><p>Figure 1: Line segment does not intersect rectangle </p><p>The line is said to intersect the rectangle if the line and the rectangle have at least one point in common. The rectangle consists of four straight lines and the area in between. Although all input values are integer numbers, valid intersection points do not have to lay on the integer grid. </p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The input consists of n test cases. The first line of the input file contains the number n. Each following line contains one test case of the format: </p><p>xstart ystart xend yend xleft ytop xright ybottom </p><p>where (xstart, ystart) is the start and (xend, yend) the end point of the line and (xleft, ytop) the top left and (xright, ybottom) the bottom right corner of the rectangle. The eight numbers are separated by a blank. The terms top left and bottom right do not imply any ordering of coordinates. </p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case in the input file, the output file should contain a line consisting either of the letter “T” if the line segment intersects the rectangle or the letter “F” if the line segment does not intersect the rectangle. </p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 9 11 2 1 5 7 1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Southwestern+European+Regional+Contest+1995" target="_blank" rel="noopener">Southwestern European Regional Contest 1995</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个矩形和一条线段，判断线段是否与矩形相交或者在矩形内部。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断线段是否与矩形每条边相交。至于线段是否在矩形内，判断是否线段两个端点在矩形内即可。</p><p>计算几何模板来在 kuangbin 的模板。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sgn(x-b.x) == <span class="number">0</span> &amp;&amp; sgn(y-b.y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//叉积</span></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x*b.y - y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点积</span></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x*b.x + y*b.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//`两线段相交判断`</span></span><br><span class="line"><span class="comment">//`2 规范相交`</span></span><br><span class="line"><span class="comment">//`1 非规范相交`</span></span><br><span class="line"><span class="comment">//`0 不相交`</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segcrossseg</span><span class="params">(Line v)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d1 = sgn((e - s) ^ (v.s - s));</span><br><span class="line"><span class="keyword">int</span> d2 = sgn((e - s) ^ (v.e - s));</span><br><span class="line"><span class="keyword">int</span> d3 = sgn((v.e - v.s) ^ (s - v.s));</span><br><span class="line"><span class="keyword">int</span> d4 = sgn((v.e - v.s) ^ (e - v.s));</span><br><span class="line"><span class="keyword">if</span>( (d1 ^ d2) == <span class="number">-2</span> &amp;&amp; (d3 ^ d4) == <span class="number">-2</span> ) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (d1 == <span class="number">0</span> &amp;&amp; sgn((v.s - s)*(v.s - e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">    (d2 == <span class="number">0</span> &amp;&amp; sgn((v.e - s)*(v.e - e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">    (d3 == <span class="number">0</span> &amp;&amp; sgn((s - v.s) * (s - v.e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">    (d4 == <span class="number">0</span> &amp;&amp; sgn((e - v.s) * (e - v.e)) &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 点在线段上的判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pointonseg</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sgn((p - s) ^ (e - s)) == <span class="number">0</span> &amp;&amp; sgn((p - s) * (p - e)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">    Point p[<span class="number">4</span>];</span><br><span class="line">    Line l[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getline</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">l[i] = Line(p[i], p[(i + <span class="number">1</span>) % n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//`判断点和任意多边形的关系`</span></span><br><span class="line">    <span class="comment">//` 3 点上`</span></span><br><span class="line">    <span class="comment">//` 2 边上`</span></span><br><span class="line">    <span class="comment">//` 1 内部`</span></span><br><span class="line">    <span class="comment">//` 0 外部`</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationpoint</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == q) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getline();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i].pointonseg(q)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (i + <span class="number">1</span>) % n;</span><br><span class="line">            <span class="keyword">int</span> k = sgn((q - p[j])^(p[i] - p[j]));</span><br><span class="line">            <span class="keyword">int</span> u = sgn(p[i].y - q.y);</span><br><span class="line">            <span class="keyword">int</span> v = sgn(p[j].y - q.y);</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; u &lt; <span class="number">0</span> &amp;&amp; v &gt;= <span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span> &amp;&amp; v &lt; <span class="number">0</span> &amp;&amp; u &gt;= <span class="number">0</span>) cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Point a, b;</span><br><span class="line">        a.input(), b.input();</span><br><span class="line">        Line l = Line(a, b);</span><br><span class="line">        Rec rec;</span><br><span class="line">        a.input(), b.input();</span><br><span class="line">        rec.p[<span class="number">0</span>] = Point(min(a.x, b.x), min(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">1</span>] = Point(max(a.x, b.x), min(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">2</span>] = Point(max(a.x, b.x), max(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">3</span>] = Point(min(a.x, b.x), max(a.y, b.y));</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">0</span>], rec.p[<span class="number">1</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">1</span>], rec.p[<span class="number">2</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">2</span>], rec.p[<span class="number">3</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">3</span>], rec.p[<span class="number">0</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rec.relationpoint(l.s) || rec.relationpoint(l.e)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=1410&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 1410&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;You are to write a program that has to decide whether a given line segment intersects a given rectangle. &lt;/p&gt;
&lt;p&gt;An example: &lt;/p&gt;
&lt;p&gt;line: start point: (4,9) &lt;/p&gt;
&lt;p&gt;end point: (11,2) &lt;/p&gt;
&lt;p&gt;rectangle: left-top: (1,5) &lt;/p&gt;
&lt;p&gt;right-bottom: (7,1) &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/11/1573482242971-1573482243153.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Figure 1: Line segment does not intersect rectangle &lt;/p&gt;
&lt;p&gt;The line is said to intersect the rectangle if the line and the rectangle have at least one point in common. The rectangle consists of four straight lines and the area in between. Although all input values are integer numbers, valid intersection points do not have to lay on the integer grid. &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="计算几何" scheme="http://wutao18.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1028 Ignatius and the Princess III (生成函数/母函数)</title>
    <link href="http://wutao18.github.io/2019/11/10/HDU-1028-Ignatius-and-the-Princess-III-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://wutao18.github.io/2019/11/10/HDU-1028-Ignatius-and-the-Princess-III-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/</id>
    <published>2019-11-10T07:49:55.000Z</published>
    <updated>2020-10-27T03:28:57.880Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1028" target="_blank" rel="noopener">HDU 1028</a></p><a id="more"></a><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.</p><p>“The second problem is, given an positive integer N, we define an equation like this:</p><p>  N=a[1]+a[2]+a[3]+…+a[m];</p><p>  a[i]&gt;0,1&lt;=m&lt;=N;</p><p>My question is how many different equations you can find for a given N.</p><p>For example, assume N is 4, we can find:</p><p>  4 = 4;</p><p>  4 = 3 + 1;</p><p>  4 = 2 + 2;</p><p>  4 = 2 + 1 + 1;</p><p>  4 = 1 + 1 + 1 + 1;</p><p>so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!”</p></blockquote><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case, you have to output a line contains an integer P which indicate the different equations you have found.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">42</span><br><span class="line">627</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$，求 $n$ 的划分数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>普通母函数。母函数 $G(x) = (1+x+x^2+…)(1+x^2+x^4+…)(1+x^3+x^6+…)…$。</p><p>$(1+x+x^2+…)=(x^{0\times1}+x^{1\times1}+x^{2\times1}+…)$ 代表不用数字 $1$，用一次数字 $1$，用两次数字 $1$……</p><p>动态规划的版本见<a href="https://wutao18.github.io/2019/11/04/HDU-1028-Ignatius-and-the-Princess-III-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">这里</a>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c1[maxn], c2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        c1[i] = <span class="number">1</span>;</span><br><span class="line">        c2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + j &lt; maxn; k += i) &#123;</span><br><span class="line">                c2[k + j] += c1[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            c1[j] = c2[j];</span><br><span class="line">            c2[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c1[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1028&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 1028&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="数学" scheme="http://wutao18.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="生成函数/母函数" scheme="http://wutao18.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    
      <category term="组合数学" scheme="http://wutao18.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1860 Currency Exchange (Bellman-Ford)</title>
    <link href="http://wutao18.github.io/2019/11/09/POJ-1860-Currency-Exchange-Bellman-Ford/"/>
    <id>http://wutao18.github.io/2019/11/09/POJ-1860-Currency-Exchange-Bellman-Ford/</id>
    <published>2019-11-09T15:39:55.000Z</published>
    <updated>2020-10-27T03:58:48.520Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1860" target="_blank" rel="noopener">POJ 1860</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency.</p><p>For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR.</p><p>You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively.</p><p>Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations.</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The first line of the input contains four numbers: N - the number of currencies, M - the number of exchange points, S - the number of currency Nick has and V - the quantity of currency units he has. The following M lines contain 6 numbers each - the description of the corresponding exchange point - in specified above order. Numbers are separated by one or more spaces. 1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103.</p><p>For each point exchange rates and commissions are real, given with at most two digits after the decimal point, 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102.</p><p>Let us call some sequence of the exchange operations simple if no exchange point is used more than once in this sequence. You may assume that ratio of the numeric values of the sums at the end and at the beginning of any simple sequence of the exchange operations will be less than 104.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>If Nick can increase his wealth, output YES, in other case output NO to the output file.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2 1 20.0</span><br><span class="line">1 2 1.00 1.00 1.00 1.00</span><br><span class="line">2 3 1.10 1.00 1.10 1.00</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2001" target="_blank" rel="noopener">Northeastern Europe 2001, Northern Subregion</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 种货币，给出一些两种货币之间的汇率及税价。</p><p>求原来持有的货币能否通过一些兑换过程使得价值增加。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把货币看成结点，兑换的过程看成有向边，那么其实问题就是判断图中是否存在正环。</p><p>使用 $Bellman-Ford$ 算法，与判断负环的方法类似，改变一下松弛的条件即可。注意初始化也需要修改。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">double</span> v;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">double</span> dis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="keyword">double</span> r, c;</span><br><span class="line">    Edge(<span class="keyword">int</span> f = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>, <span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> c = <span class="number">0</span>): from(f), to(t), r(r), c(c) &#123;&#125;</span><br><span class="line">&#125; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">double</span> r, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    edges[tot++] = Edge(f, t, r, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = edges[j].from, t = edges[j].to;</span><br><span class="line">            <span class="keyword">double</span> r = edges[j].r, c = edges[j].c;</span><br><span class="line">            <span class="keyword">double</span> tmp = (dis[f] - c) * r;</span><br><span class="line">            <span class="keyword">if</span>(dis[t] &lt; tmp) &#123;</span><br><span class="line">                dis[t] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[edges[i].to] &lt; (dis[edges[i].from] - edges[i].c) * edges[i].r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf"</span>, &amp;n, &amp;m, &amp;s, &amp;v)) &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f, t;</span><br><span class="line">        <span class="keyword">double</span> r1, c1, r2, c2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf%lf%lf"</span>, &amp;f, &amp;t, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">            add(f, t, r1, c1);</span><br><span class="line">            add(t, f, r2, c2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Bellman_Ford()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=1860&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 1860&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency.&lt;/p&gt;
&lt;p&gt;For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR.&lt;/p&gt;
&lt;p&gt;You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively.&lt;/p&gt;
&lt;p&gt;Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="图论" scheme="http://wutao18.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://wutao18.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Bellman-Ford" scheme="http://wutao18.github.io/tags/Bellman-Ford/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5183 Negative and Positive (NP)  (手写哈希)</title>
    <link href="http://wutao18.github.io/2019/11/08/HDU-5183-Negative-and-Positive-NP-%E6%89%8B%E5%86%99%E5%93%88%E5%B8%8C/"/>
    <id>http://wutao18.github.io/2019/11/08/HDU-5183-Negative-and-Positive-NP-%E6%89%8B%E5%86%99%E5%93%88%E5%B8%8C/</id>
    <published>2019-11-08T14:30:13.000Z</published>
    <updated>2020-10-27T03:31:32.160Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5183" target="_blank" rel="noopener">HDU 5183</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote><p>When given an array $(a_0,a_1,a_2,⋯a_{n−1})$ and an integer $K$, you are expected to judge whether there is a pair $(i,j)(0≤i≤j&lt;n)$ which makes that $NP−sum(i,j)$ equals to $K$ true. Here $NP−sum(i,j)=a_i−a_{i+1}+a_{i+2}+⋯+(−1)^{j−i}a_j$</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>Multi test cases. In the first line of the input file there is an integer $T$ indicates the number of test cases.</p><p>In the next $2∗T$ lines, it will list the data for each test case.</p><p>Each case occupies two lines, the first line contain two integers $n$ and $K$ which are mentioned above.</p><p>The second line contain $(a_0,a_1,a_2,⋯a_{n−1})$ separated by exact one space.</p><p>[Technical Specification]</p><p>All input items are integers.</p><p>$0&lt;T≤25,1≤n≤1000000,−1000000000≤a_i≤1000000000,−1000000000≤K≤1000000000$</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each case，the output should occupies exactly one line. The output format is Case #id: ans, here id is the data number starting from 1; ans is “Yes.” or “No.” (without quote) according to whether you can find $(i,j)$ which makes $PN−sum(i,j)$ equals to $K$.</p><p>See the sample for more details.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">2 1</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: Yes.</span><br><span class="line">Case #2: No.</span><br></pre></td></tr></table></figure><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote><p>If input is huge, fast IO method is recommended.</p></blockquote><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=BestCoder+Round+%2332&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">BestCoder Round #32</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的数组，问是否存在一段区间其加减交错的和等于 $k$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对该数组求前缀和然后哈希就行。</p><p>不过这题不同的 set 过不了。</p><p>所以要手写哈希。</p><p>当然 unordered_set 也可以过。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashMap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxn], next[maxn];</span><br><span class="line">    ll num[maxn];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">abs</span>(val) % maxn;</span><br><span class="line">        num[tot] = val, next[tot] = head[h], head[h] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">find</span><span class="params">(ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">abs</span>(val) % maxn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[h]; ~i; i = next[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hashmap;</span><br><span class="line"></span><br><span class="line">ll arr[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        hashmap.init();</span><br><span class="line">        ll n, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + (i &amp; <span class="number">1</span>? arr[i]: -arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">            hashmap.insert(sum[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmap.find(sum[i - <span class="number">1</span>] + k)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmap.find(sum[i - <span class="number">1</span>] - k)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; (flag? <span class="string">"Yes."</span> : <span class="string">"No."</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5183&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU 5183&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;When given an array $(a_0,a_1,a_2,⋯a_{n−1})$ and an integer $K$, you are expected to judge whether there is a pair $(i,j)(0≤i≤j&amp;lt;n)$ which makes that $NP−sum(i,j)$ equals to $K$ true. Here $NP−sum(i,j)=a_i−a_{i+1}+a_{i+2}+⋯+(−1)^{j−i}a_j$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="前缀和" scheme="http://wutao18.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="哈希/Hash" scheme="http://wutao18.github.io/tags/%E5%93%88%E5%B8%8C-Hash/"/>
    
  </entry>
  
  <entry>
    <title>C++ 常见的cin的错误处理</title>
    <link href="http://wutao18.github.io/2019/11/07/C-%E5%B8%B8%E8%A7%81%E7%9A%84cin%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://wutao18.github.io/2019/11/07/C-%E5%B8%B8%E8%A7%81%E7%9A%84cin%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2019-11-07T14:50:01.000Z</published>
    <updated>2020-10-27T03:26:49.141Z</updated>
    
    <content type="html"><![CDATA[<p>写程序时想要用 cin 对输入的合法性检查，于是学习了一下 cin.fail() 函数，顺便学习了类似的一些函数。</p><p>cin 对象包含了一个描述流状态的数据成员。流状态有 3 个标志位：eofbit，badbit 和 failbit。</p><p>当 cin 操作到达文件末尾时，eofbit 置 1。</p><p>当流被破坏时，badbit 置 1。例如：试图读取不可访问的文件、写入写保护的磁盘、写入的设备剩余空间不足等。</p><p>cin 操作未能读取到预期的字符时 failbit 会置 1。例如：要输入到一个整型变量中，输入的却是字符时 failbit 置 1。I/O 失败时 failbit 也可能置 1。</p><p>如果 3 个状态位都为 0 表示一切顺利。</p><a id="more"></a><p>下面介绍一些检查或改变流状态的方法。</p><ul><li>eof()</li></ul><p>如果 eofbit 为 1 返回 true。</p><p>所以可以用 <code>cin.eof()</code> 来判断是否读到文件尾。</p><ul><li>good()</li></ul><p>如果流可以使用，也就是 3 个状态位都为 0，返回 true。</p><p>只有 <code>cin.good()</code> 为 true 时，<code>while(cin &gt;&gt; input)</code> 才返回 true。</p><ul><li>bad()</li></ul><p>如果 badbit 为 1 返回 true。</p><ul><li>fail()</li></ul><p>如果 failbit 或 badbit 为 1 返回 true。所以与 bad() 一样的情况会返回 true，输入一个类型不匹配的字符也是返回 true。</p><p>可用于检查输入是否合法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果输入不合法重新输入，failbit 是不会自动重置的。</p><ul><li>rdstate()</li></ul><p>返回流状态。</p><ul><li>clear(iostate s)</li></ul><p>状态位置位后不会改变。因此要重置状态位需使用 clear(iostate s)。该方法将所有的状态位都设置为 s，其中 s 默认为 0。也就是 clear() 将所有状态位清零。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://book.douban.com/subject/10789789/" target="_blank" rel="noopener">《C++ Primer Plus》 Stephen Prata</a></p><p><a href="https://blog.csdn.net/maoliran/article/details/51725396" target="_blank" rel="noopener">C++之cin.eof, cin.bad, cin.good, cin.fail, cin.clear</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写程序时想要用 cin 对输入的合法性检查，于是学习了一下 cin.fail() 函数，顺便学习了类似的一些函数。&lt;/p&gt;
&lt;p&gt;cin 对象包含了一个描述流状态的数据成员。流状态有 3 个标志位：eofbit，badbit 和 failbit。&lt;/p&gt;
&lt;p&gt;当 cin 操作到达文件末尾时，eofbit 置 1。&lt;/p&gt;
&lt;p&gt;当流被破坏时，badbit 置 1。例如：试图读取不可访问的文件、写入写保护的磁盘、写入的设备剩余空间不足等。&lt;/p&gt;
&lt;p&gt;cin 操作未能读取到预期的字符时 failbit 会置 1。例如：要输入到一个整型变量中，输入的却是字符时 failbit 置 1。I/O 失败时 failbit 也可能置 1。&lt;/p&gt;
&lt;p&gt;如果 3 个状态位都为 0 表示一切顺利。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://wutao18.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编程语言" scheme="http://wutao18.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++" scheme="http://wutao18.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>POJ 2287 Tian Ji -- The Horse Racing (贪心)</title>
    <link href="http://wutao18.github.io/2019/11/06/POJ-2287-Tian-Ji-The-Horse-Racing-%E8%B4%AA%E5%BF%83/"/>
    <id>http://wutao18.github.io/2019/11/06/POJ-2287-Tian-Ji-The-Horse-Racing-%E8%B4%AA%E5%BF%83/</id>
    <published>2019-11-06T15:11:28.000Z</published>
    <updated>2020-10-27T06:19:03.214Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2287" target="_blank" rel="noopener">POJ 2287</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Here is a famous story in Chinese history.</p><p>That was about 2300 years ago. General Tian Ji was a high official in the country Qi. He likes to play horse racing with the king and others.</p><p>Both of Tian and the king have three horses in different classes, namely, regular, plus, and super. The rule is to have three rounds in a match; each of the horses must be used in one round. The winner of a single round takes two hundred silver dollars from the loser.</p><p>Being the most powerful man in the country, the king has so nice horses that in each class his horse is better than Tian’s. As a result, each time the king takes six hundred silver dollars from Tian.</p><p>Tian Ji was not happy about that, until he met Sun Bin, one of the most famous generals in Chinese history. Using a little trick due to Sun, Tian Ji brought home two hundred silver dollars and such a grace in the next match.</p><p>It was a rather simple trick. Using his regular class horse race against the super class from the king, they will certainly lose that round. But then his plus beat the king’s regular, and his super beat the king’s plus. What a simple trick. And how do you think of Tian Ji, the high ranked official in China?</p><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/06/1573050687823-1573050688065.png" alt=""></p><p>Were Tian Ji lives in nowadays, he will certainly laugh at himself. Even more, were he sitting in the ACM contest right now, he may discover that the horse racing problem can be simply viewed as finding the maximum matching in a bipartite graph. Draw Tian’s horses on one side, and the king’s horses on the other. Whenever one of Tian’s horses can beat one from the king, we draw an edge between them, meaning we wish to establish this pair. Then, the problem of winning as many rounds as possible is just to find the maximum matching in this graph. If there are ties, the problem becomes more complicated, he needs to assign weights 0, 1, or -1 to all the possible edges, and find a maximum weighted perfect matching…</p><p>However, the horse racing problem is a very special case of bipartite matching. The graph is decided by the speed of the horses — a vertex of higher speed always beat a vertex of lower speed. In this case, the weighted bipartite matching algorithm is a too advanced tool to deal with the problem.</p><p>In this problem, you are asked to write a program to solve this special case of matching problem.</p></blockquote><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The input consists of up to 50 test cases. Each case starts with a positive integer n ( n&lt;=1000) on the first line, which is the number of horses on each side. The next n integers on the second line are the speeds of Tian’s horses. Then the next n integers on the third line are the speeds of the king’s horses. The input ends with a line that has a single `0’ after the last test case.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each input case, output a line containing a single number, which is the maximum money Tian Ji will get, in silver dollars.</p></blockquote><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">92 83 71</span><br><span class="line">95 87 74</span><br><span class="line">2</span><br><span class="line">20 20</span><br><span class="line">20 20</span><br><span class="line">2</span><br><span class="line">20 19</span><br><span class="line">22 18</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Shanghai+2004" target="_blank" rel="noopener">Shanghai 2004</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>田忌赛马，田忌和齐王都有 $n$ 匹马，赢一局得 $200$，输一局失 $200$，平局财产不动。求田忌最多能赢多少钱。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>贪心</strong></p><p>首先拿田忌最快的马与齐王最快的马比。</p><p>如果田忌的马快就赢一场，否则用最慢的马去比，输一场。</p><p>如果田忌最快的马与齐王最快的马一样快，则拿田忌最慢的马与齐王最慢的马比。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>], b[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        sort(b, b + n);</span><br><span class="line">        <span class="keyword">int</span> min1 = <span class="number">0</span>, min2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = n - <span class="number">1</span>, max2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[max1] &gt; b[max2]) &#123;  <span class="comment">// 田忌最快的马比齐王最快的马快</span></span><br><span class="line">                ++ans;</span><br><span class="line">                max1--;</span><br><span class="line">                max2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[max1] &lt; b[max2]) &#123;  <span class="comment">// 田忌最快的马比齐王最快的马慢</span></span><br><span class="line">                --ans;</span><br><span class="line">                min1++;</span><br><span class="line">                max2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 田忌最快的马与齐王最快的马一样快</span></span><br><span class="line">                <span class="keyword">if</span>(a[min1] &gt; b[min2]) &#123;  <span class="comment">// 田忌最慢的马比齐王最慢的马快</span></span><br><span class="line">                    ++ans;</span><br><span class="line">                    min1++;</span><br><span class="line">                    min2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[min1] &lt; b[max2]) &#123;  <span class="comment">// 田忌最慢的马比齐王最慢的马慢</span></span><br><span class="line">                        --ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    min1++;</span><br><span class="line">                    max2--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans * <span class="number">200</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=2287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 2287&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Here is a famous story in Chinese history.&lt;/p&gt;
&lt;p&gt;That was about 2300 years ago. General Tian Ji was a high official in the country Qi. He likes to play horse racing with the king and others.&lt;/p&gt;
&lt;p&gt;Both of Tian and the king have three horses in different classes, namely, regular, plus, and super. The rule is to have three rounds in a match; each of the horses must be used in one round. The winner of a single round takes two hundred silver dollars from the loser.&lt;/p&gt;
&lt;p&gt;Being the most powerful man in the country, the king has so nice horses that in each class his horse is better than Tian’s. As a result, each time the king takes six hundred silver dollars from Tian.&lt;/p&gt;
&lt;p&gt;Tian Ji was not happy about that, until he met Sun Bin, one of the most famous generals in Chinese history. Using a little trick due to Sun, Tian Ji brought home two hundred silver dollars and such a grace in the next match.&lt;/p&gt;
&lt;p&gt;It was a rather simple trick. Using his regular class horse race against the super class from the king, they will certainly lose that round. But then his plus beat the king’s regular, and his super beat the king’s plus. What a simple trick. And how do you think of Tian Ji, the high ranked official in China?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/06/1573050687823-1573050688065.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Were Tian Ji lives in nowadays, he will certainly laugh at himself. Even more, were he sitting in the ACM contest right now, he may discover that the horse racing problem can be simply viewed as finding the maximum matching in a bipartite graph. Draw Tian’s horses on one side, and the king’s horses on the other. Whenever one of Tian’s horses can beat one from the king, we draw an edge between them, meaning we wish to establish this pair. Then, the problem of winning as many rounds as possible is just to find the maximum matching in this graph. If there are ties, the problem becomes more complicated, he needs to assign weights 0, 1, or -1 to all the possible edges, and find a maximum weighted perfect matching…&lt;/p&gt;
&lt;p&gt;However, the horse racing problem is a very special case of bipartite matching. The graph is decided by the speed of the horses — a vertex of higher speed always beat a vertex of lower speed. In this case, the weighted bipartite matching algorithm is a too advanced tool to deal with the problem.&lt;/p&gt;
&lt;p&gt;In this problem, you are asked to write a program to solve this special case of matching problem.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="竞赛" scheme="http://wutao18.github.io/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="ACM刷题" scheme="http://wutao18.github.io/tags/ACM%E5%88%B7%E9%A2%98/"/>
    
      <category term="贪心" scheme="http://wutao18.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="思维" scheme="http://wutao18.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
</feed>
