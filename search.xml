<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2016 ICPC Mid-Central USA Region J. Windy Path (贪心)</title>
    <url>/2019/08/13/2016-ICPC-Mid-Central-USA-Region-J-Windy-Path-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://www.jisuanke.com/contest/3106?view=challenges" target="_blank" rel="noopener">2016 ICPC Mid-Central USA Region</a><br>题目链接：<a href="https://nanti.jisuanke.com/t/40897" target="_blank" rel="noopener">Windy Path</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/13/1565695184498-1565695184699.png" alt=""></p>
<p>Consider following along the path in the ﬁgure above, starting from $(4,4)$ and moving to $(2,5)$. Then the path turns rightward toward $(1,6)$, then sharp left to $(5,0)$ and ﬁnally sharp left again to $(4,2)$. If we use ‘$L$’ for left and ‘RR’ for right, we see that the sequence of turn directions is given by <code>RLL</code>. Notice that the path does not cross itself: the only intersections of segments are the connection points along the path.</p>
<p>Consider the reverse problem: Given points in an arbitrary order,say $(2,5),(1,6),(4,4),(5,0),(4,2)$,could you ﬁnd an ordering of the points so the turn directions along the path are given by <code>RLL</code>? Of course to follow the path in the ﬁgure,you would start with the third point in the list $(4,4)$,then the ﬁrst $(2,5)$,second $(1,6)$, fourth $(5,0)$, and ﬁfth $(4,2)$, so the permutation of the points relative to the given initial order would be: $3 1  2  4  5$.</p>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The ﬁrst line of the input contains an integer $N$, specifying the number of points such that $3 \le N \le 50$. The following NN lines each describe a point using two integers $x_i$ and $y_i$ such that $0 \le x_i,y_i \le 1000$. The points are distinct and no three are collinear (i.e., on the same line). The last line contains a string of $N - 2$ characters, each of which is either ‘$L$’ or ‘$R$’.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>A permutation of$\{ 1,…,N \}$ that corresponds to a nonintersecting path satisfying the turn conditions. The numbers are to be displayed with separating spaces. (There are always one or more possible solutions, and any one may be used.)</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点的坐标和一个包含 $R$ 和 $L$ 的序列，其中 $L$ 代表左转，$R$ 代表右转，求一个访问每个点顺序满足给定的序列。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心 构造 计算几何</strong></p>
<p>由于是 special judge，只要想出一种构造方法就可以。本题可以贪心。</p>
<ol>
<li>首先选择最下面最左边的点作为起点，(起点不唯一，比如最左边最下面也可以)。</li>
<li>如果第一个字符是 $R$，第二个点选择最左边的点；反之选择最右边的点。</li>
<li>之后每次考察连续两个字符：<ul>
<li>如果是 $RL$，选择右边最后一个</li>
<li>如果是 $LR$，选择左边最后一个</li>
<li>如果是 $RR$，选择右边第一个</li>
<li>如果是 $RR$，选择左边第一个</li>
</ul>
</li>
</ol>
<p>判断点是在向量的左边还是右边可以用 $ToLeftTest$，查询第一个还是最后一个可以用夹角判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路:</span></span><br><span class="line"><span class="comment">    贪心 </span></span><br><span class="line"><span class="comment">    1. R: 左边第一个    </span></span><br><span class="line"><span class="comment">    2. L: 右边第一个    </span></span><br><span class="line"><span class="comment">    3. RL: 右边最后一个 </span></span><br><span class="line"><span class="comment">    4. LR: 左边最后一个 </span></span><br><span class="line"><span class="comment">    5. LL: 左边第一个   </span></span><br><span class="line"><span class="comment">    6. RR: 右边第一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, index;</span><br><span class="line">&#125; p[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area2</span><span class="params">(Point p, Point q, Point s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.x * q.y - p.y * q.x + q.x * s.y - q.y * s.x + s.x * p.y - s.y * p.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断某个点在向量的左边还是右边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toLeftTest</span><span class="params">(Point p, Point q, Point s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> area2(p, q, s) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.y == p2.y)</span><br><span class="line">        <span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">    <span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求向量 pq 与 向量 ps 之间的夹角</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ang</span><span class="params">(Point p, Point q, Point s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1 = q.x - p.x, y1 = q.y - p.y;</span><br><span class="line">    <span class="keyword">double</span> x2 = s.x - p.x, y2 = s.y - p.y;</span><br><span class="line">    <span class="keyword">double</span> ans = (x1 * x2 + y1 * y2) / (<span class="built_in">sqrt</span>(x1 * x1 + y1 * y1) * <span class="built_in">sqrt</span>(x2 * x2 + y2 * y2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; ans; <span class="comment">// 存放答案</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100</span>];      <span class="comment">// 标记已访问过的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        p[i].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">    ans.push_back(p[<span class="number">1</span>]); <span class="comment">// 起点</span></span><br><span class="line">    vis[p[<span class="number">1</span>].index] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> min_ang = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> min_index = <span class="number">1</span>;</span><br><span class="line">    Point tmp, tmp2 = p[<span class="number">1</span>]; <span class="comment">// 保存上两个点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="comment">// 第一个点</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'R'</span>) &#123;</span><br><span class="line">        tmp.x = p[<span class="number">1</span>].x - <span class="number">1</span>;</span><br><span class="line">        tmp.y = p[<span class="number">1</span>].y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> angle = ang(p[<span class="number">1</span>], p[i], tmp);</span><br><span class="line">            <span class="keyword">if</span> (angle &lt; min_ang) &#123;</span><br><span class="line">                min_ang = angle;</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(p[min_index]);</span><br><span class="line">        vis[p[min_index].index] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp.x = p[<span class="number">1</span>].x + <span class="number">1</span>;</span><br><span class="line">        tmp.y = p[<span class="number">1</span>].y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> angle = ang(p[<span class="number">1</span>], p[i], tmp);</span><br><span class="line">            <span class="keyword">if</span> (angle &lt; min_ang) &#123;</span><br><span class="line">                min_ang = angle;</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(p[min_index]);</span><br><span class="line">        vis[p[min_index].index] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = p[min_index];</span><br><span class="line">    <span class="comment">// 之后的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'R'</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">'L'</span>) &#123;</span><br><span class="line">            min_ang = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[p[i].index])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (toLeftTest(tmp2, tmp, p[i]))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> angle = ang(tmp, tmp2, p[i]);</span><br><span class="line">                <span class="keyword">if</span> (min_ang &gt; angle) &#123;</span><br><span class="line">                    min_ang = angle;</span><br><span class="line">                    min_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(p[min_index]);</span><br><span class="line">            vis[p[min_index].index] = <span class="number">1</span>;</span><br><span class="line">            tmp2 = tmp;</span><br><span class="line">            tmp = p[min_index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'R'</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">'R'</span>) &#123;</span><br><span class="line">            min_ang = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[p[i].index])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (toLeftTest(tmp2, tmp, p[i]))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> angle = ang(tmp, tmp2, p[i]);</span><br><span class="line">                <span class="keyword">if</span> (min_ang &lt; angle) &#123;</span><br><span class="line">                    min_ang = angle;</span><br><span class="line">                    min_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(p[min_index]);</span><br><span class="line">            vis[p[min_index].index] = <span class="number">1</span>;</span><br><span class="line">            tmp2 = tmp;</span><br><span class="line">            tmp = p[min_index];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'L'</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">'R'</span>) &#123;</span><br><span class="line">            min_ang = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[p[i].index])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!toLeftTest(tmp2, tmp, p[i]))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> angle = ang(tmp, tmp2, p[i]);</span><br><span class="line">                <span class="keyword">if</span> (min_ang &gt; angle)</span><br><span class="line">                &#123;</span><br><span class="line">                    min_ang = angle;</span><br><span class="line">                    min_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(p[min_index]);</span><br><span class="line">            vis[p[min_index].index] = <span class="number">1</span>;</span><br><span class="line">            tmp2 = tmp;</span><br><span class="line">            tmp = p[min_index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min_ang = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[p[i].index])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!toLeftTest(tmp2, tmp, p[i]))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> angle = ang(tmp, tmp2, p[i]);</span><br><span class="line">                <span class="keyword">if</span> (min_ang &lt; angle) &#123;</span><br><span class="line">                    min_ang = angle;</span><br><span class="line">                    min_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(p[min_index]);</span><br><span class="line">            vis[p[min_index].index] = <span class="number">1</span>;</span><br><span class="line">            tmp2 = tmp;</span><br><span class="line">            tmp = p[min_index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[p[i].index]) &#123;</span><br><span class="line">            ans.push_back(p[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i].index);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, i == ans.size() - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>贪心</tag>
        <tag>ToLeftTest</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 ECNA Regional Contest J. Watch Where You Step</title>
    <url>/2019/08/11/2018-ECNA-Regional-Contest-J-Watch-Where-You-Step/</url>
    <content><![CDATA[<p>题目链接：<a href="https://nanti.jisuanke.com/t/40547" target="_blank" rel="noopener">Watch Where You Step</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定有向图的邻接矩阵，现在需要给该图增加边，使得如果两点可达必直接可达，求需要加边的数量。</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，如果给定 $n$ 个结点的图中任意两点均可达，那么需要增加的边数为有向完全图的边数 $n * (n - 1) - $ 原来有的边数。</p>
<p>所以先将图分解为多个强连通分量，然后将强连通分量与强连通分量之间进行拓扑排序，假设拓扑排序后各个强连通分量的结点数量分别为 $n_1, n_2, … , n_k$，则强连通分量之间需要增加的边数为 $n_1 \times n_2 \times … \times n_k + n_2 \times n_3 \times … \times n_k + … + n_{k - 1} \times n_k - $ 强连通分量之间的所有边数。</p>
<p>可以用 $Tarjan$ 算法加拓扑排序，也可以直接用两遍 $DFS$。</p>
<p>对原图跑一遍 $DFS$，再对反向图跑一遍 $DFS$。由于把强连通分量的所有边反向后还是强连通分量，而强连通分量之间的边反向后 $DFS$ 就不可达了。第一遍 $DFS$ 用栈记录访问顺序，第二遍根据出栈顺序 $DFS$，这样就可以找出所有强连通分量了，顺便还找到拓扑序了，具体见图和代码。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/11/1565509399691-1565509399769.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">3000</span>], gg[<span class="number">3000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis1[<span class="number">3000</span>], vis[<span class="number">3000</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[s].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = g[s][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[to]) &#123;</span><br><span class="line">            dfs(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    vis1[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gg[s].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = gg[s][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis1[to]) &#123;</span><br><span class="line">            res += dfs1(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            <span class="keyword">if</span>(a) &#123;</span><br><span class="line">                g[i].push_back(j);</span><br><span class="line">                gg[j].push_back(i);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(!vis1[h]) &#123;</span><br><span class="line">            vt.push_back(dfs1(h));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vt.size(); ++i) &#123;</span><br><span class="line">        ans += vt[i] * (vt[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vt.size(); ++j) &#123;</span><br><span class="line">            ans += vt[i] * vt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>强连通分量</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 ICPC Asia Urumqi A.coins (概率DP + 期望)</title>
    <url>/2019/08/10/2017-ICPC-Asia-Urumqi-A-coins-%E6%A6%82%E7%8E%87DP-%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<p>题目链接：<a href="https://nanti.jisuanke.com/t/40512" target="_blank" rel="noopener">Coins</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Alice and Bob are playing a simple game. They line up a row of nn identical coins, all with the heads facing down onto the table and the tails upward.</p>
<p>For exactly mm times they select any kk of the coins and toss them into the air, replacing each of them either heads-up or heads-down with the same possibility. Their purpose is to gain as many coins heads-up as they can.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input has several test cases and the first line contains the integer $t (1 \le t \le 1000)$ which is the total number of cases.</p>
<p>For each case, a line contains three space-separated integers $n$, $m (1 \le n, m \le 100)$ and $k (1 \le k \le n)$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output the expected number of coins heads-up which you could have at the end under the optimal strategy, as a real number with the precision of $3$ digits.</p>
</blockquote>
<h2 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 1 1</span><br><span class="line">2 3 1</span><br><span class="line">5 4 3</span><br><span class="line">6 2 3</span><br><span class="line">6 100 1</span><br><span class="line">6 100 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0.500</span><br><span class="line">1.250</span><br><span class="line">3.479</span><br><span class="line">3.000</span><br><span class="line">5.500</span><br><span class="line">5.000</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>桌上放置着 $n$ 个反面朝上的硬币，有 $m$ 此操作，每次选择任意 $k$ 个硬币抛向空中，每个硬币落到桌子后正面朝上和反面朝上的概率相同，求最终正面朝上的硬币的期望。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>概率DP 期望</strong></p>
<p>期望 = 概率 * 总数</p>
<p>$f(i, j)$ 表示为抛 $i$ 枚硬币 $j$ 枚硬币朝上的概率。则有 $f(i, j) = 0.5 \times f(i - 1, j) + 0.5 \times f(i - 1, j - 1)$，其中 $f(i, 0) = 2 ^ i$ 。</p>
<p>$DP(i, j)$ 表示第 $i$ 次操作后有 $j$ 枚正面朝上的硬币的概率，则反面硬币的个数为 $n - j$。</p>
<p>如果 $n - j &gt;= k$，那么只要在反面朝上的硬币中选择 $k$ 枚抛即可。抛完 $k$ 枚硬币后有 $0 \sim k$ 枚硬币可能会正面朝上，递推方程为 $DP(i + 1, j + l) = \sum_{l = 0}^{k} DP(i, j) * f(k, l)$。</p>
<p>如果 $n - j &lt; k$，那么除了要抛 $n - j$ 枚反面朝上的硬币，还要选择 $k - (n - j)$ 枚正面朝上的硬币，这样最后正面朝上的个数是本来正面就朝上的 $j-(k-(n-j))$ 枚加上抛了之后朝上的 $l (0\le l\le k)$ 枚，递推方程为 $DP(i + 1, j - (k - (n - j)) + l) = \sum_{l = 0}^{k} DP(i, j) * f(k, l)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">double</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">double</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="built_in">pow</span>(<span class="number">0.5</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; ++j) &#123;</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; ++l) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (n - j &gt;= k) &#123;</span><br><span class="line">                        dp[i + <span class="number">1</span>][j + l] += dp[i][j] * f[k][l];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i + <span class="number">1</span>][j + l - (k - (n - j))] += dp[i][j] * f[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans += <span class="number">1.0</span> * i * dp[m][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>概率DP</tag>
        <tag>数学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 ACM-ICPC 上海网络赛 B. Light bulbs (差分)</title>
    <url>/2019/09/15/2019-ACM-ICPC-%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E8%B5%9B-B-Light-bulbs-%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>题目链接：<a href="https://nanti.jisuanke.com/t/41399" target="_blank" rel="noopener">Light bulbs</a><br>比赛链接：<a href="https://www.jisuanke.com/contest/3003?view=challenges" target="_blank" rel="noopener">The Preliminary Contest for ICPC Asia Shanghai 2019</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $N$ 个灯泡 (编号从 $0$ 到 $N - 1$)，初始都是关闭的。</p>
<p>给定 $M$ 个操作，每个操作包含 $L$ 和 $R$，对 $[L, R]$ 内的所有灯泡改变状态。</p>
<p>求最后有几个灯泡是亮的。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目挺简单的，翻转奇数次的灯泡是亮的，所以要求每个灯泡翻转的次数。</p>
<p>容易想到可以用差分。</p>
<p>对所有操作的两个端点排序，求差分数组 $d[]$。</p>
<p>然后根据差分数组求前缀和，差分数组相邻两个数 $d[l]$ 和 $d[r]$ 所在的区间 $[l, r)$ 内的每个数都加上 $d[l]$，那么如果 $d[l]$ 为奇数，$ans += (r - l)$。时间复杂度 $O(MlogM)$。</p>
<p>于是就有了下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">2010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="built_in">memset</span>(pos, <span class="number">0</span>, <span class="keyword">sizeof</span>(pos));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            ++d[l];</span><br><span class="line">            --d[r + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(mp[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                pos[cnt++] = l;</span><br><span class="line">                mp[l] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp[r + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                pos[cnt++] = r + <span class="number">1</span>;</span><br><span class="line">                mp[r + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(pos, pos + cnt);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[pos[i - <span class="number">1</span>]] &amp; <span class="number">1</span>) ans += pos[i] - pos[i - <span class="number">1</span>];</span><br><span class="line">            d[pos[i]] = d[pos[i - <span class="number">1</span>]] + d[pos[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[pos[cnt - <span class="number">1</span>]] &amp; <span class="number">1</span>) ans += n - pos[cnt - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就 TLE 了。这题时间和空间卡的很紧。</p>
<h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><p>用 map 存差分数组，还自动排序了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            ++d[l];</span><br><span class="line">            --d[r + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = d.begin();</span><br><span class="line">        <span class="keyword">int</span> p = it-&gt;first;</span><br><span class="line">        <span class="keyword">int</span> v = it-&gt;second;</span><br><span class="line">        ++it;</span><br><span class="line">        <span class="keyword">for</span>(; it != d.end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v &amp; <span class="number">1</span>) ans += it-&gt;first - p;</span><br><span class="line">            it-&gt;second = v + it-&gt;second;</span><br><span class="line">            p = it-&gt;first;</span><br><span class="line">            v = it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v &amp; <span class="number">1</span>) ans += n - p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>差分</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>2015 ACM-ICPC 亚洲区上海站 A - An Easy Physics Problem (计算几何)</title>
    <url>/2019/10/24/2015-ACM-ICPC-%E4%BA%9A%E6%B4%B2%E5%8C%BA%E4%B8%8A%E6%B5%B7%E7%AB%99-A-An-Easy-Physics-Problem-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5572" target="_blank" rel="noopener">HDU 5572</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>On an infinite smooth table, there’s a big round fixed cylinder and a little ball whose volume can be ignored.</p>
<p>Currently the ball stands still at point $A$, then we’ll give it an initial speed and a direction. If the ball hits the cylinder, it will bounce back with no energy losses.</p>
<p>We’re just curious about whether the ball will pass point $B$ after some time.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>First line contains an integer $T$, which indicates the number of test cases.</p>
<p>Every test case contains three lines.</p>
<p>The first line contains three integers $O_x$, $O_y$ and $r$, indicating the center of cylinder is $(O_x, O_y)$ and its radius is $r$.</p>
<p>The second line contains four integers $A_x$, $A_y$, $V_x$ and $V_y$, indicating the coordinate of $A$ is $(A_x, A_y)$ and the initial direction vector is $(V_x, V_y)$.</p>
<p>The last line contains two integers $B_x$ and $B_y$, indicating the coordinate of point $B$ is $(B_x,B_y)$.</p>
<p>⋅ $1 ≤ T ≤ 100.$</p>
<p>⋅ $|O_x|,|O_y|≤ 1000.$</p>
<p>⋅ $1 ≤ r ≤ 100.$</p>
<p>⋅ $|A_x|,|A_y|,|B_x|,|B_y|≤ 1000.$</p>
<p>⋅ $|V_x|,|V_y|≤ 1000.$</p>
<p>⋅ $V_x≠0 or V_y≠0.$</p>
<p>⋅ both $A$ and $B$ are outside of the cylinder and they are not at same position.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For every test case, you should output “ <strong>Case #x: y</strong>“, where $x$ indicates the case number and counts from $1$. $y$ is “ $Yes$” if the ball will pass point $B$ after some time, otherwise $y$ is “ $No$”.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 0 1</span><br><span class="line">2 2 0 1</span><br><span class="line">-1 -1</span><br><span class="line">0 0 1</span><br><span class="line">-1 2 1 -1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case #1: No</span><br><span class="line">Case #2: Yes</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2015ACM%2FICPC%D1%C7%D6%DE%C7%F8%C9%CF%BA%A3%D5%BE-%D6%D8%CF%D6%C8%FC%A3%A8%B8%D0%D0%BB%BB%AA%B6%AB%C0%ED%B9%A4%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2015ACM/ICPC亚洲区上海站-重现赛（感谢华东理工）</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在光滑平面上有一个圆，圆外有两点 $a$，$b$，给定 $a$ 的方向向量，求 $a$ 运动一段时间后能否到达 $b$（$a$ 碰到圆后没有反弹没有能量损失）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分类讨论一下。</p>
<p>点 $a$ 的运动在圆外或者与圆相切时直接判断。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/24/1571926778661-1571926778977.png" alt=""></p>
<p>注意是射线，下图的情况是不行的。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/24/1571926873927-1571926873933.png" alt=""></p>
<p>相交时如果点 $b$ 在圆的另一边也是不行的。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/24/1571926969354-1571926969358.png" alt=""></p>
<p>相交时有两种情况，一种是不经过反射就到达点 $b$，另一种是经过反射才到达点 $b$。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/24/1571927014558-1571927014561.png" alt=""></p>
<p>反射后的射线求一下对称点即可。（代码中的 P3 和 P4 点就是下图中的两点）</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/24/1571928128807-1571928128810.png" alt=""></p>
<p>模板来自kuangbin的计算几何模板。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> db inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line">	Point()&#123;&#125;</span><br><span class="line">	Point(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y)&#123;</span><br><span class="line">		x = _x;</span><br><span class="line">		y = _y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x,&amp;y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (Point b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dcmp(x-b.x) == <span class="number">0</span> &amp;&amp; dcmp(y-b.y) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Point b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dcmp(x-b.x)== <span class="number">0</span>?dcmp(y-b.y)&lt;<span class="number">0</span>:x&lt;b.x;</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.y - y*b.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.x + y*b.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hypot(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">len2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*x + y*y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hypot(x-p.x,y-p.y);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line">	Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x+b.x,y+b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="keyword">double</span> &amp;k)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x*k,y*k);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> /(<span class="keyword">const</span> <span class="keyword">double</span> &amp;k)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x/k,y/k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">rad</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line">		Point p = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">atan2</span>( <span class="built_in">fabs</span>((a-p)^(b-p)),(a-p)*(b-p) ));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point <span class="title">trunc</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> l = len();</span><br><span class="line">		<span class="keyword">if</span>(!dcmp(l))<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		r /= l;</span><br><span class="line">		<span class="keyword">return</span> Point(x*r,y*r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">	Point s,e;</span><br><span class="line">	Line()&#123;&#125;</span><br><span class="line">	Line(Point _s,Point _e)&#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		e = _e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">		s.input();</span><br><span class="line">		e.input();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(e &lt; s)swap(s,e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s.distance(e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> k = <span class="built_in">atan2</span>(e.y-s.y,e.x-s.x);</span><br><span class="line">		<span class="keyword">if</span>(dcmp(k) &lt; <span class="number">0</span>)k += pi;</span><br><span class="line">		<span class="keyword">if</span>(dcmp(k-pi) == <span class="number">0</span>)k -= pi;</span><br><span class="line">		<span class="keyword">return</span> k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = dcmp((p-s)^(e-s));</span><br><span class="line">		<span class="keyword">if</span>(c &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c &gt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">dispointtoline</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>((p-s)^(e-s))/length();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 点 p 在直线上的投影</span></span><br><span class="line">	<span class="function">Point <span class="title">lineprog</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 点 p 关于直线的对称点</span></span><br><span class="line">	<span class="function">Point <span class="title">symmetrypoint</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		Point q = lineprog(p);</span><br><span class="line">		<span class="keyword">return</span> Point(<span class="number">2</span>*q.x-p.x,<span class="number">2</span>*q.y-p.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">	Point p;</span><br><span class="line">	<span class="keyword">double</span> r;</span><br><span class="line">	Circle()&#123;&#125;</span><br><span class="line">	Circle(Point _p,<span class="keyword">double</span> _r)&#123;</span><br><span class="line">		p = _p;</span><br><span class="line">		r = _r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">		p.input();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;r);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">relationline</span><span class="params">(Line v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> dst = v.dispointtoline(p);</span><br><span class="line">		<span class="keyword">if</span>(dcmp(dst-r) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dcmp(dst-r) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 直线和圆的交点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pointcrossline</span><span class="params">(Line v,Point &amp;p1,Point &amp;p2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(*<span class="keyword">this</span>).relationline(v))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		Point a = v.lineprog(p);</span><br><span class="line">		<span class="keyword">double</span> d = v.dispointtoline(p);</span><br><span class="line">		d = <span class="built_in">sqrt</span>(r*r-d*d);</span><br><span class="line">		<span class="keyword">if</span>(dcmp(d) == <span class="number">0</span>)&#123;</span><br><span class="line">			p1 = a;</span><br><span class="line">			p2 = a;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p1 = a + (v.e-v.s).trunc(d);</span><br><span class="line">		p2 = a - (v.e-v.s).trunc(d);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Circle o;</span><br><span class="line">        o.input();</span><br><span class="line">        Point a, b, c;</span><br><span class="line">        a.input();</span><br><span class="line">        Point v;</span><br><span class="line">        v.input();  <span class="comment">// 方向向量</span></span><br><span class="line">        b.input(); </span><br><span class="line">        c = a + v;</span><br><span class="line">        Line l = Line(a, c);  <span class="comment">// 射线ac代表a运动的方向</span></span><br><span class="line">        Point p1, p2, p3;</span><br><span class="line">        <span class="keyword">int</span> cnt = o.pointcrossline(l, p1, p2);  <span class="comment">// 求直线ac与圆的交点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">2</span>) &#123;  <span class="comment">// 判断交点在线段外还是线段内</span></span><br><span class="line">            <span class="keyword">if</span>((p1 - a)*(c - a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span> || cnt == <span class="number">1</span>) &#123;  <span class="comment">// 没有交点或者直线ac与圆相切</span></span><br><span class="line">            <span class="comment">// 判断射线ac是否经过点b</span></span><br><span class="line">            <span class="keyword">if</span>(dcmp((b - a)^(c - a)) == <span class="number">0</span> &amp;&amp; dcmp((b - a)*(c - a)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%d: Yes\n"</span>, ++kase);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%d: No\n"</span>, ++kase);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  找从圆外进入圆内的一个交点 p3</span></span><br><span class="line">            <span class="keyword">if</span>(p1.dis2(a) &lt; p2.dis2(a)) &#123;</span><br><span class="line">                p3 = p1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p3 = p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断点b是否在线段ap3上</span></span><br><span class="line">            <span class="keyword">if</span>(dcmp((b - a)^(c - a)) == <span class="number">0</span> &amp;&amp; dcmp((b - a)*(c - a)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((p3 - a)*(p3 - b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Case #%d: No\n"</span>, ++kase);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Case #%d: Yes\n"</span>, ++kase);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反弹的情况</span></span><br><span class="line">            Line tmp = Line(o.p, p3);</span><br><span class="line">            Point p4 = tmp.symmetrypoint(a); <span class="comment">// 反射后的一个点 点a关于圆心到交点p3所在直线的对称点</span></span><br><span class="line">            <span class="comment">// 判断反射后能否到达点b</span></span><br><span class="line">            <span class="keyword">if</span>(dcmp((b - p3)^(p4 - p3)) == <span class="number">0</span> &amp;&amp; dcmp((b - p3)*(p4 - p3)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%d: Yes\n"</span>, ++kase);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Case #%d: No\n"</span>, ++kase);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 ICPC Asia Singapore Regional A. Largest Triangle (计算几何)</title>
    <url>/2019/10/05/2018-ICPC-Asia-Singapore-Regional-A-Largest-Triangle-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p>题目链接：<a href="https://open.kattis.com/problems/largesttriangle" target="_blank" rel="noopener">Kattis - largesttriangle</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Given $N$ points on a $2$-dimensional space, determine the area of the largest triangle that can be formed using $3$ of those $N$ points. If there is no triangle that can be formed, the answer is $0$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains an integer $N (3≤N≤5000)$ denoting the number of points. Each of the next $N$ lines contains two integers $x$ and $y (0≤x,y≤4⋅10^7)$. There are no specific constraints on these $N$ points, i.e. the points are not necessarily distinct, the points are not given in specific order, there may be $3$ or more collinear points, etc.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print the answer in one line. Your answer should have an absolute error of at most $10^{−5}$.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0 0</span><br><span class="line">0 5</span><br><span class="line">7 7</span><br><span class="line">0 10</span><br><span class="line">0 0</span><br><span class="line">20 0</span><br><span class="line">10 10</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">100.00000</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="https://open.kattis.com/problem-sources/2018%20ICPC%20Asia%20Singapore%20Regional" target="_blank" rel="noopener">2018 ICPC Asia Singapore Regional</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出 $N$ 个点，选择其中 $3$ 个点组成三角形，求最大面积的三角形的面积，如果不能组成三角形，输出 $0$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大面积的三角形一定在凸包上，所以先求凸包。</p>
<p>接下来在凸包上枚举三个点。直接三重循环肯定超时。</p>
<p>可以枚举凸包上的两个点，另外一个点根据面积的单调性枚举。时间复杂度 $O(N^2)$。</p>
<p>还有 $O(NlogN)$ 的做法，可以参考<a href="https://arxiv.org/abs/1705.11035" target="_blank" rel="noopener">这篇论文</a>。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">area</span><span class="params">(Point A, Point B, Point C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>((A - B).cross(A - C));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size(), cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Polygon <span class="title">ans</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &gt;= <span class="number">2</span> &amp;&amp; (ans[cnt - <span class="number">1</span>] - ans[cnt - <span class="number">2</span>]).cross(p[i] - ans[cnt - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[cnt++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &gt;= t &amp;&amp; (ans[cnt - <span class="number">1</span>] - ans[cnt - <span class="number">2</span>]).cross(p[i - <span class="number">1</span>] - ans[cnt - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[cnt++] = p[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ans.resize(cnt - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point tmp;</span><br><span class="line">        tmp.input();</span><br><span class="line">        p.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    p = Andrew(p);</span><br><span class="line">    n = p.size();</span><br><span class="line">    db ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(k + <span class="number">1</span> &lt; n &amp;&amp; area(p[i], p[j], p[k]) &lt; area(p[i], p[j], p[k + <span class="number">1</span>])) &#123;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, area(p[i], p[j], p[k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans * <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 ACM-ICPC 南京 现场赛 H. Prince and Princess</title>
    <url>/2019/10/27/2019-ACM-ICPC-%E5%8D%97%E4%BA%AC%E7%AB%99-H-Prince-and-Princess/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>王子想要娶公主，但是需要完成一个挑战：在一些房间中找出公主在哪。</p>
<p>每个房间有一个人，他们彼此知道谁在哪个房间。可以问他们三种问题：</p>
<ul>
<li>你是谁？</li>
<li>在某个房间是谁？</li>
<li>公主在哪个房间？</li>
</ul>
<p>有三类人，一类一定说真话，一类一定说假话，一类可能说真话可能说假话。</p>
<p>王子知道这三类人的人数分别为 $a$, $b$, $c$，求能否通过问一些问题找到公主在哪，如果能，输出最少需要的问题数。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第三类人有可能说假话，因此最坏情况就是说假话，所以把他们视为第二类人。</p>
<p>首先问所有人第三个问题，那么最坏情况就是说真话的人都说出公主的位置，说假话的人都选择一个不是公主的人说他是公主。所以最后只会问到两个位置。那么只要说真话的人数量比较多，就一定能确认公主在哪个房间。否则是无法确定的。所以我一开始以为问问题的次数为 $a + b + c$。</p>
<p>后来队友给了个样例，发现其实不需要问这么多，只要说真话的人比说假话的人多就行。也就是说假话的只有 $b + c$ 个人，那么只要再问说真话的 $b + c + 1$ 个人就可以了。</p>
<p>还有特殊情况，就是所有人都说真话，只要问一个人就行了。</p>
<p>还有更特殊的情况(队友想到的)，就是 $1 0 0$ 的情况，不需要问问题，因为那个人就是公主。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b + c) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (b + c) * <span class="number">2</span> + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>思维</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 ACM-ICPC 南京 现场赛 K. Triangle (二分)</title>
    <url>/2019/10/28/2019-ACM-ICPC-%E5%8D%97%E4%BA%AC-%E7%8E%B0%E5%9C%BA%E8%B5%9B-K-Triangle-%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个三角形和一个点 $p$，如果该点不在三角形边上直接输出 $-1$，否则在三角形上找一点 $q$，使得线段 $pq$ 平分三角形面积。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看完题想都没想直接二分了。</p>
<p>就是比赛时复制粘贴的时候改错了，贡献了三发罚时。</p>
<p>板子来自 kuangbin 的模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> db inf = <span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	db x, y;</span><br><span class="line">	Point()&#123;&#125;</span><br><span class="line">	Point(db _x, db _y)&#123;</span><br><span class="line">		x = _x;</span><br><span class="line">		y = _y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (Point b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sgn(x-b.x) == <span class="number">0</span> &amp;&amp; sgn(y-b.y) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x-b.x, y-b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//叉积</span></span><br><span class="line">	db <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.y - y*b.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//点积</span></span><br><span class="line">	db <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.x + y*b.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回两点的距离</span></span><br><span class="line">	<span class="function">db <span class="title">dis</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hypot(x-p.x, y-p.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x+b.x, y+b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> *(<span class="keyword">const</span> db &amp;k)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x*k, y*k);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> /(<span class="keyword">const</span> db &amp;k)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x/k, y/k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">	Point s,e;</span><br><span class="line">	Line()&#123;&#125;</span><br><span class="line">	Line(Point _s,Point _e)&#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		e = _e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 点在线段上的判断</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">pointonseg</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sgn((p-s)^(e-s)) == <span class="number">0</span> &amp;&amp; sgn((p-s) * (p-e)) &lt;= <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 求两直线的交点</span></span><br><span class="line">	<span class="function">Point <span class="title">crosspoint</span><span class="params">(Line v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a1 = (v.e-v.s)^(s-v.s);</span><br><span class="line">		<span class="keyword">double</span> a2 = (v.e-v.s)^(e-v.s);</span><br><span class="line">		<span class="keyword">return</span> Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求点a和点b的中点</span></span><br><span class="line"><span class="function">Point <span class="title">get_mid</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Point a, b, c, p;</span><br><span class="line">        Line ab, bc, ac;</span><br><span class="line">        a.input(), b.input(), c.input(), p.input();</span><br><span class="line">        ab = Line(a, b); bc = Line(b, c); ac = Line(a, c);</span><br><span class="line">        db area = <span class="built_in">fabs</span>((b - a) ^ (c - a) * <span class="number">0.5</span>);  <span class="comment">// 三角形面积</span></span><br><span class="line">        <span class="keyword">if</span>(ab.pointonseg(p)) &#123;  <span class="comment">// 点p在线段ab上</span></span><br><span class="line">            <span class="keyword">if</span>(a.dis(p) &lt; b.dis(p)) &#123;  <span class="comment">// 点p靠近点a，则另一点一定在线段bc上</span></span><br><span class="line">                Point l = c, r = b;</span><br><span class="line">                Point mid = get_mid(l, r);</span><br><span class="line">                <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(times--) &#123;</span><br><span class="line">                    mid = get_mid(l, r);</span><br><span class="line">                    db s = <span class="built_in">fabs</span>((mid - p) ^ (b - p));</span><br><span class="line">                    <span class="keyword">if</span>(sgn(s - area) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        l = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sgn(s - area) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, mid.x, mid.y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 点p靠近点b，则另一点一定在线段ac上</span></span><br><span class="line">                Point l = c, r = a;</span><br><span class="line">                Point mid = get_mid(l, r);</span><br><span class="line">                <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(times--) &#123;</span><br><span class="line">                    mid = get_mid(l, r);</span><br><span class="line">                    db s = <span class="built_in">fabs</span>((mid - p) ^ (a - p));</span><br><span class="line">                    <span class="keyword">if</span>(sgn(s - area) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        l = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sgn(s - area) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, mid.x, mid.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bc.pointonseg(p)) &#123;  <span class="comment">// 另外两种情况复制粘贴就行了</span></span><br><span class="line">            <span class="keyword">if</span>(b.dis(p) &lt; c.dis(p)) &#123;</span><br><span class="line">                Point l = a, r = c;</span><br><span class="line">                Point mid = get_mid(l, r);</span><br><span class="line">                <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(times--) &#123;</span><br><span class="line">                    mid = get_mid(l, r);</span><br><span class="line">                    db s = <span class="built_in">fabs</span>((mid - p) ^ (c - p));</span><br><span class="line">                    <span class="keyword">if</span>(sgn(s - area) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        l = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sgn(s - area) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, mid.x, mid.y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Point l = a, r = b;</span><br><span class="line">                Point mid = get_mid(l, r);</span><br><span class="line">                <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(times--) &#123;</span><br><span class="line">                    mid = get_mid(l, r);</span><br><span class="line">                    db s = <span class="built_in">fabs</span>((mid - p) ^ (b - p));</span><br><span class="line">                    <span class="keyword">if</span>(sgn(s - area) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        l = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sgn(s - area) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, mid.x, mid.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ac.pointonseg(p)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.dis(p) &lt; c.dis(p)) &#123;</span><br><span class="line">                Point l = b, r = c;</span><br><span class="line">                Point mid = get_mid(l, r);</span><br><span class="line">                <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(times--) &#123;</span><br><span class="line">                    mid = get_mid(l, r);</span><br><span class="line">                    db s = <span class="built_in">fabs</span>((mid - p) ^ (c - p));</span><br><span class="line">                    <span class="keyword">if</span>(sgn(s - area) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        l = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sgn(s - area) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, mid.x, mid.y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Point l = b, r = a;</span><br><span class="line">                Point mid = get_mid(l, r);</span><br><span class="line">                <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(times--) &#123;</span><br><span class="line">                    mid = get_mid(l, r);</span><br><span class="line">                    db s = <span class="built_in">fabs</span>((mid - p) ^ (a - p));</span><br><span class="line">                    <span class="keyword">if</span>(sgn(s - area) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        l = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sgn(s - area) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, mid.x, mid.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赛后发现直接推也可以，也不用写这么长的代码了 (<del>虽然大部分是复制粘贴</del>)。<del>感觉在演队友</del>。</p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年百度之星·程序设计大赛 - 初赛四 1001 Strassen</title>
    <url>/2019/08/25/2019-%E5%B9%B4%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%C2%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-%E5%88%9D%E8%B5%9B%E5%9B%9B-1001-Strassen/</url>
    <content><![CDATA[<p>比赛链接：<a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=864" target="_blank" rel="noopener">2019 年百度之星·程序设计大赛 - 初赛四</a><br>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6719" target="_blank" rel="noopener">HDU-6719 Strassen</a></p>
<p><del>C++ 没写出来</del></p>
<p>于是直接上 <code>Java</code> 暴力。</p>
<p>好像可以用 <code>__int128</code>。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line">        <span class="keyword">int</span> T;</span><br><span class="line">        T = in.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(T &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            T--;</span><br><span class="line">            BigInteger a, b, n;</span><br><span class="line">            n = in.nextBigInteger();</span><br><span class="line">            a = in.nextBigInteger();</span><br><span class="line">            b = in.nextBigInteger();</span><br><span class="line">            BigInteger ans = f(n, a, b);</span><br><span class="line">            BigInteger mod = <span class="keyword">new</span> BigInteger(<span class="string">"1000000007"</span>);</span><br><span class="line">            System.out.println(ans.remainder(mod));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">f</span> <span class="params">(BigInteger n, BigInteger a, BigInteger b)</span> </span>&#123;</span><br><span class="line">        BigInteger c = <span class="keyword">new</span> BigInteger(<span class="string">"18"</span>);</span><br><span class="line">        BigInteger d = <span class="keyword">new</span> BigInteger(<span class="string">"7"</span>);</span><br><span class="line">        BigInteger e = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">if</span>((n).equals(BigInteger.ONE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ( ( (n.pow(<span class="number">3</span>)).multiply(b) ).add( ((n.subtract(BigInteger.ONE)).multiply(n.pow(<span class="number">2</span>))).multiply(a) ) ).min( ( (c.multiply( ((n.divide(e)).pow(<span class="number">2</span>)) )).multiply(a) ).add( (d.multiply(f(n.divide(e), a, b))) ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>Java</tag>
        <tag>暴力</tag>
        <tag>递归</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第七场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%B8%83%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=854" target="_blank" rel="noopener">2019 Multi-University Training Contest 7</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+7&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 7</a></p>
<h2 id="1001-A-B-C"><a href="#1001-A-B-C" class="headerlink" title="1001 A + B = C"></a>1001 A + B = C</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><blockquote>
<p>给出 $a, b, c$，求 $x, y, z$ 满足 $a\cdot 10^x + b\cdot 10^y = c\cdot 10^z$。$a, b, c \le 10^{100000}$。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>补零到 $a, b, c$ 长度相等之后，可能的情况只有四种: $b | (c − a), b | (10 · c − a), a | (c − b), a | (10 · c − b)$。</p>
<p><code>Java</code> 写炸了。</p>
<h2 id="1006-Final-Exam-HDU-6651"><a href="#1006-Final-Exam-HDU-6651" class="headerlink" title="1006 Final Exam (HDU 6651)"></a>1006 <a href="https://wutao18.github.io/2019/08/12/HDU-6651-Final-Exam-%E6%80%9D%E7%BB%B4/">Final Exam</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6651" target="_blank" rel="noopener">(HDU 6651)</a></h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><blockquote>
<p>一次考试共有 $n$ 道题，总分为 $m$ 分。每道题的分数不一定，可能是 $0$ 分，也可能是 $m$ 分，分数一定是整数。如果一道题分数为 $x$，那么复习这道题的时间为 $x + 1$，现在要保证在考试中做出 $k$ 题，求准备考试的时间最少为多少。</p>
</blockquote>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p><strong>思维</strong></p>
<p>如果做不出 $k$ 题，那么也就是复习时间最少的 $n − k + 1$ 道题的难度都小于等于复习的时间。因此想要做出 $k$ 题，只要让复习时间最少的 $n − k + 1$ 道题的复习时间总和 $&gt; m$ 即可。</p>
<p>也就是 $n - k + 1$ 道题的复习时间总和为 $m + 1$，剩下 $k - 1$ 道题的复习时间不是最少的 $k - 1$ 道题即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n, m, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m + <span class="number">1</span> + (m / (n - k + <span class="number">1</span>) + <span class="number">1</span>) * (k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1011-Kejin-Player-HDU-6656"><a href="#1011-Kejin-Player-HDU-6656" class="headerlink" title="1011 Kejin Player (HDU 6656)"></a>1011 <a href="https://wutao18.github.io/2019/08/13/HDU-6656-Kejin-Player-%E6%9C%9F%E6%9C%9BDP-%E9%80%86%E5%85%83/">Kejin Player</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6656" target="_blank" rel="noopener">(HDU 6656)</a></h2><h3 id="题意：-2"><a href="#题意：-2" class="headerlink" title="题意："></a>题意：</h3><blockquote>
<p>从 $i$ 级升级到 $i + 1$ 级需要花费 $a_i$ RMB，成功的概率为 $p_i = \frac{r_i}{s_i}$，若失败则降到 $x_i$ 级，然后给出 $q$ 个询问求 $l$ 级升级到 $r$ 级花费的期望。 </p>
</blockquote>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p><strong>期望DP 逆元</strong></p>
<p>设 $g(l, r)$ 为 $l$ 升到 $r$ 的期望，这种期望满足减法 $g(l, r) = g(1, r) − g(1, l)$。因为升级只能一级一级升, 所以要从 $1$ 升级到 $r$, 必然要经过 $l$。可以降维，用 $dp[i]$ 表示从 $1$ 升到 $i$ 的期望，则 $g(l, r) = dp[r] − dp[l]$。</p>
<p>从 $dp[i]$ 转移至 $dp[i + 1]$，假设尝试了 $t$ 次才成功，那么也就是前面 $t - 1$ 次都是失败的，所以下一状态的花费为当前状态的花费 + 成功的花费 + 失败的花费 + 失败后再次回到当前状态的花费。于是：</p>
<script type="math/tex; mode=display">dp[i + 1] = dp[i] + 1 \times a[i] + (t - 1) \times a[i] + (t- 1) \times (dp[i] - dp[x_i])</script><p>又 $\frac{t - 1}{t} = 1 - \frac{r_i}{s_i}$，即 $t = \frac{s_i}{r_i}$</p>
<p>于是状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i + 1] = dp[i] + \frac{s_i}{r_i} \times a[i] + (\frac{s_i}{r_i} - 1) \times (dp[i] - dp[x_i])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll r[maxn], s[maxn], x[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;r[i], &amp;s[i], &amp;x[i], &amp;a[i]);</span><br><span class="line">            ll t = (s[i] * qmod(r[i], mod - <span class="number">2</span>, mod)) % mod;</span><br><span class="line">            dp[i + <span class="number">1</span>] = (dp[i] + (t * a[i]) % mod + ((t - <span class="number">1</span>) * (dp[i] - dp[x[i]])) % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (dp[r] - dp[l] + mod) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>动态规划</tag>
        <tag>模拟</tag>
        <tag>思维</tag>
        <tag>期望DP</tag>
        <tag>逆元</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第一场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%B8%80%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=848" target="_blank" rel="noopener">2019 Multi-University Training Contest 1</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+1&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 1</a></p>
<h2 id="1002-Operation-HDU-6579"><a href="#1002-Operation-HDU-6579" class="headerlink" title="1002 Operation (HDU-6579)"></a>1002 Operation <a href="http://acm.hdu.edu.cn/showproblem.php?pid=65879" target="_blank" rel="noopener">(HDU-6579)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定包含 $n$ 个数的序列，$m$ 个询问。询问有两种操作，操作 $0$ 表示在数组最后添加一个新元素，操作 $1$ 表示查询区间 [l,r] 的子集的异或最大值。</p>
<p>询问强制在线。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>线性基 贪心</strong></p>
<h2 id="1004-Vacation-HDU-6581"><a href="#1004-Vacation-HDU-6581" class="headerlink" title="1004 Vacation (HDU-6581)"></a>1004 Vacation <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6581" target="_blank" rel="noopener">(HDU-6581)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一条路上有 $n + 1$ 辆车。第 $i$ 辆车的长度为 $l_i$，离终点的距离为 $s_i$，最大车速为 $v_i$，$i$ 越大越靠近终点。每辆车不能超越前面的车，但车头可以贴在前面车的车尾。每辆车经过了终点，仍继续在路上跑。求第 $0$ 辆车 (最后一辆车) 车头通过终点线的最少需多少时间。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心 二分</strong></p>
<p>二分时间。判断 $mid = (l + r) / 2$ 时间能否最后一辆车到达，若能到达则 $r = mid$，否则 $l = mid$。</p>
<p>接下来是如何判断时间 $t$ 内最后一辆车能否到达终点。</p>
<p>从第一辆车 (最靠近终点) 开始枚举，维护一个 $cur$ 表示第 $i$ 辆车车头到终点的距离。第 $i$ 辆车经过 $t$ 时间后可以行驶 $car[i].v \times t$ 的距离，距离终点 $car[i].s - car[i].v \times t$。但是如果前面有车，就要比较前车车尾离终点的距离 $cur + car[i].l$ 谁更近。如果 $car[i].s - car[i].v \times t \le cur + car[i].l$，也就是第 $i$ 辆车行驶 $t$ 时间后距离终点更近，那么由于不能超过前车，也就是只能贴在前车的车尾，$cur$ 更新为前车车尾到终点的距离 $cur + car[i + 1].l$。如果 $car[i].s - car[i].v \times t &gt; cur + car[i].l$，也就是不会超过前车，那么 $cur$ 就是当前车行驶 $t$ 时间后车头距离终点的距离。如果第 $0$ 辆车行驶 $t$ 时间后 $cur \le 0$，说明可以到达。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/28/1567004077190-1567004077602.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CAR</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, s, v;</span><br><span class="line">&#125; car[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cur = car[n].s - car[n].v * x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (car[i].s - car[i].v * x &lt;= cur + car[i + <span class="number">1</span>].l) cur += car[i + <span class="number">1</span>].l;</span><br><span class="line">        <span class="keyword">else</span> cur = car[i].s - car[i].v * x;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur &lt;= eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;car[i].l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;car[i].s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;car[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-Path-HDU-6582"><a href="#1005-Path-HDU-6582" class="headerlink" title="1005 Path (HDU-6582)"></a>1005 Path <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6582" target="_blank" rel="noopener">(HDU-6582)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定 $n$ 个结点，$m$ 条边的有向图，现在要删除一些边，使得结点 $1$ 到 $n$ 的最短路的长度增加，删除边的代价为边的权值，求最少的代价。</p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>最短路 最小割</strong></p>
<p>首先要找出所有的最短路，得到最短路图。对最短路图求最小割就是答案。</p>
<p>所有最短路的求法：先跑一遍单源最短路，可以用 $Dijkstra$ 算法。$Dijkstra$ 算法得到的是起点到所有点的最短距离，存放在 $d$ 数组中。那么遍历所有的边，如果 $d[i] + w_{ij} = d[j]$ ($w_{ij}$ 表示结点 $i$ 到结点 $j$ 的边的权值)，那么该条边一定在最短路图上。</p>
<p>至于最小割用 $Dinic$ 算法求解即可。</p>
<h2 id="1013-Code-HDU-6590"><a href="#1013-Code-HDU-6590" class="headerlink" title="1013 Code (HDU-6590)"></a><a href="https://wutao18.github.io/2019/08/21/HDU-6590-Code-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/">1013 Code</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6590" target="_blank" rel="noopener">(HDU-6590)</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给出两类点的坐标，问能否用一条直线将两类点分开。</p>
</blockquote>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>题目看懂了就很好做了。</p>
<p>就是分别对两类点求凸包，然后判断两个凸包是否相交。若不相交，则能够用一条直线分开两类点，否则不能。</p>
<p>其实就是判断凸包是否相交的模板题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (cross(a, b) &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span> </span>&#123;</span><br><span class="line">    Polygon u, l;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; s.size() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = u.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(u[n - <span class="number">2</span>], u[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.size() ; n &gt;=<span class="number">2</span> &amp;&amp; !isclock(l[n<span class="number">-2</span>],l[n<span class="number">-1</span>],s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线段相交</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),</span><br><span class="line">            c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(cross(p2 - p1, p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Polygon s1, Polygon s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = s1.size(), c2 = s2.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s1[i], s2)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Infinite loop!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c2; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s2[i], s1)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Infinite loop!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Intersection(s1[i], s1[(i + <span class="number">1</span>) % c1], s2[j], s2[(j + <span class="number">1</span>) % c2])) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Infinite loop!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Successful!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        Polygon s1, s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;x1, &amp;x2, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">1</span>) &#123;</span><br><span class="line">                s1.push_back(Point(x1, x2));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s2.push_back(Point(x1, x2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Successful!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.size()) s1 = Andrew(s1);</span><br><span class="line">        <span class="keyword">if</span>(s2.size()) s2 = Andrew(s2);</span><br><span class="line">        solve(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>贪心</tag>
        <tag>凸包</tag>
        <tag>二分</tag>
        <tag>线性基</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>Dinic</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第三场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%B8%89%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=850" target="_blank" rel="noopener">2019 Multi-University Training Contest 3</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+3&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 3</a></p>
<h2 id="1002-Blow-up-the-city-HDU-6604"><a href="#1002-Blow-up-the-city-HDU-6604" class="headerlink" title="1002 Blow up the city (HDU-6604)"></a>1002 Blow up the city <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6604" target="_blank" rel="noopener">(HDU-6604)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定 $n$ 个点和 $m$ 条边的有向无环图，给出 $q$ 次询问，每个询问给出 $a$ 和 $b$，求有多少个点，满足该点删去后 $a$ 和 $b$ 中至少一个点不能到达出度为 $0$ 的点。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>支配树/灭绝树 拓扑排序 最近公共祖先</strong></p>
<h2 id="1006-Fansblog-HDU-6608"><a href="#1006-Fansblog-HDU-6608" class="headerlink" title="1006 Fansblog (HDU-6608)"></a>1006 Fansblog <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6608" target="_blank" rel="noopener">(HDU-6608)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定素数$ P(1e^9\leq P\leq 1e^{14})$，试找出小于$P$的最大素数$ Q$，求出$ Q!  mod  P$。</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong><a href="https://zh.wikipedia.org/wiki/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">威尔逊定理</a> 逆元 质数的密度分布 Miller-Rabin素数测试</strong></p>
<p>威尔逊定理：当且仅当 $P$ 为素数时：$(P - 1)!\equiv -1 mod P$</p>
<p>即 $(P-1)!\equiv(P-1) mod P$，由于 $(P - 1)! = (Q!) \cdot (Q + 1) \cdot (Q + 2) \cdot … \cdot (P - 1)$，可得 $Q! mod P=\frac {(P - 1)}{(Q + 1) \cdot (Q + 2) \cdot … \cdot (P - 1)} mod P=\frac {1}{(Q + 1) \cdot (Q + 2) \cdot … \cdot (P - 2)} mod P$ </p>
<p>可以使用 <strong>$Miller-Rabin$ 素数测试</strong>判断素数，也可直接使用试除法。<br>素数间的间隔不超过 $600$ (<a href="https://zhuanlan.zhihu.com/p/20046958" target="_blank" rel="noopener">素数间的大间隔(Large gaps between primes)</a>)，因此可直接从 $P - 1$ 开始查找 $Q$。<br>注意数很大，需要使用快速乘。(WA了好几发) </p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mulmod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans + a) % m;</span><br><span class="line">        a = (a &lt;&lt; <span class="number">1</span>) % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = mulmod(ans, a, m);</span><br><span class="line">        a = mulmod(a, a, m);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabbin</span><span class="params">(ll n, ll a)</span> </span>&#123;</span><br><span class="line">    ll d = n - <span class="number">1</span>, s = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (!(d &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        d &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = qmod(a, d, n);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span> || t == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        t = mulmod(t, t, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll i, tab[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == tab[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!n % tab[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; tab[i] &amp;&amp; !Miller_Rabbin(n, tab[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (ll i = n - <span class="number">1</span>;; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_prime(i)) &#123;</span><br><span class="line">                ll ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (ll j = i + <span class="number">1</span>; j &lt;= n - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                    ans = mulmod(ans, qmod(j, n - <span class="number">2</span>, n), n);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = (ans + n) % n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1007-Find-the-answer-HDU-6609"><a href="#1007-Find-the-answer-HDU-6609" class="headerlink" title="1007 Find the answer (HDU-6609)"></a>1007 Find the answer <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6609" target="_blank" rel="noopener">(HDU-6609)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定 $n$ 个整数 $W_i(1\leq i\leq n)$ 和一个整数 $m$，对于每个$ i(1\leq i \leq n)$，求至少需要删除多少个 $W_k(1\leq k &lt; i)$，使得$\sum_{j=1}^iW_j\leq m$。其中 $1\leq W_i\leq m(1\leq i\leq n)$ </p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>multiset STL</strong></p>
<p>神仙做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; ll m;</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            ll tmp = sum;</span><br><span class="line">            <span class="keyword">if</span>(tmp + a[i] &gt; m) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = s.end();</span><br><span class="line">                <span class="keyword">while</span>(tmp + a[i] &gt; m) &#123;</span><br><span class="line">                   --it;</span><br><span class="line">                   tmp -= *it;</span><br><span class="line">                   ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,cnt + res);</span><br><span class="line">            s.insert(a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">            <span class="keyword">auto</span> it = s.end();</span><br><span class="line">            <span class="keyword">while</span>(sum &gt; m) &#123;</span><br><span class="line">                --it;</span><br><span class="line">                sum -= *it;</span><br><span class="line">                s.erase(s.find(*it));</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>STL</tag>
        <tag>逆元</tag>
        <tag>数论</tag>
        <tag>支配树</tag>
        <tag>拓扑排序</tag>
        <tag>最近公共祖先</tag>
        <tag>威尔逊定理</tag>
        <tag>素数</tag>
        <tag>Miller-Rabin素数测试</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第五场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%BA%94%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=852" target="_blank" rel="noopener">2019 Multi-University Training Contest 5</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+5&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 5</a></p>
<p>罚时爆炸 自闭场</p>
<h2 id="1004-equation-HDU-6627"><a href="#1004-equation-HDU-6627" class="headerlink" title="1004 equation (HDU 6627)"></a>1004 <a href="https://wutao18.github.io/2019/08/15/HDU-6627-equation-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/">equation</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6627" target="_blank" rel="noopener">(HDU 6627)</a></h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><blockquote>
<p>给定一个整数 $C$ 和 $N$ 组 $a_i,b_i$，求 $∑_{i=1}^N|a_i\cdot x + b_i| = C$ 的所有解，如果有无穷多个解就输出 -1.</p>
</blockquote>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>分类讨论</strong></p>
<p>分类讨论去绝对值。根据 $b_i / a_i$ 排序，可得各段区间：$[-b_0/a_0, ∞), [-b_1/a_1, -b_0/a_0), [-b_2/a_2, -b_1/a_1), … ,[-b_n/a_n, -b_{n-1}/a_{n-1}), [∞, -b_n/a_n)$ 设 $suma = \sum_{i=1}^Na_i, sumb = \sum_{i=1}^Nb_i$，依次让 $a_ix+b_i$ 变成 $-a_ix-b_i$，也就是 $suma - 2a_i, sumb-2b_i$，求出 $x_i = \frac{c - sumb}{suma}$ 并判断是否在区间内。无穷解的情况：$suma = 0, sumb = c$。 </p>
<p>感谢杭电没有卡 $double$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coefficient</span> &#123;</span></span><br><span class="line">    ll a, b;</span><br><span class="line">&#125; co[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Coefficient c1, Coefficient c2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.b * <span class="number">1.0</span> / c1.a &lt; c2.b * <span class="number">1.0</span> / c2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Coefficient&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        ll c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;c);</span><br><span class="line">        ll suma = <span class="number">0</span>, sumb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;co[i].a, &amp;co[i].b);</span><br><span class="line">            suma += co[i].a;</span><br><span class="line">            sumb += co[i].b;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(co + <span class="number">1</span>, co + n + <span class="number">1</span>, cmp);</span><br><span class="line">        Coefficient t;</span><br><span class="line">        t.a = suma, t.b = sumb;</span><br><span class="line">        <span class="keyword">if</span>((c - sumb) * <span class="number">1.0</span> / suma &gt;= -co[<span class="number">1</span>].b * <span class="number">1.0</span> / co[<span class="number">1</span>].a) &#123;</span><br><span class="line">            t.b = c - t.b;</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            suma -= co[i].a * <span class="number">2</span>;</span><br><span class="line">            sumb -= co[i].b * <span class="number">2</span>;</span><br><span class="line">            t.a = suma;</span><br><span class="line">            t.b = sumb;</span><br><span class="line">            <span class="keyword">if</span>(!suma) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sumb == c) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>((c - sumb) * <span class="number">1.0</span> / suma &gt;= -co[i + <span class="number">1</span>].b * <span class="number">1.0</span> / co[i + <span class="number">1</span>].a &amp;&amp; (c - sumb) * <span class="number">1.0</span> / suma &lt; -co[i].b * <span class="number">1.0</span> / co[i].a) &#123;</span><br><span class="line">                    t.b = c - t.b;</span><br><span class="line">                    ans.push_back(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>((c - sumb) * <span class="number">1.0</span> / suma &lt; -co[i].b * <span class="number">1.0</span> / co[i].a) &#123;</span><br><span class="line">                    t.b = c - t.b;</span><br><span class="line">                    ans.push_back(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans.size());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i].b * <span class="number">1.0</span> / ans[i].a &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" -"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                ll g = gcd(<span class="built_in">abs</span>(ans[i].b), <span class="built_in">abs</span>(ans[i].a));</span><br><span class="line">                <span class="keyword">if</span>(ans[i].b == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0/1"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, <span class="built_in">abs</span>(ans[i].b) / g, <span class="built_in">abs</span>(ans[i].a) / g);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-permutation-1-HDU-6628"><a href="#1005-permutation-1-HDU-6628" class="headerlink" title="1005 permutation 1 (HDU 6628)"></a>1005 <a href="https://wutao18.github.io/2019/08/14/HDU-6628-permutation-1-%E6%9A%B4%E5%8A%9B/">permutation 1</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6628" target="_blank" rel="noopener">(HDU 6628)</a></h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><blockquote>
<p>定义排列 $p_1, p_2, … , p_n$ 的 “difference sequence” 为 $p_2-p_1, p_3-p_2,…,p_n-p_{n-1}$。现在给定 $N$ 和 $K$，求长度为 $N$ 的所有排列中 “difference sequence” 的字典序第 $K$ 小的排列。</p>
</blockquote>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><strong>暴力 STL 全排列</strong></p>
<p>题目给定 $K$ 的范围不超过 $10^4$，而 $8! = 40320 &gt; K$，因此可以预处理 $N &lt;= 8$ 的情况，当 $N &gt; 8$ 时暴力求 $a[1] = n$ 的全排列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125; ans[<span class="number">10</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(P p1, P p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.str &lt; p2.str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// for(int j = 0; j &lt; i; ++j) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; a[j] &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                ans[i][cnt].num[j] = a[j];</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i) ans[i][cnt].str += a[j + <span class="number">1</span>] - a[j] + <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span>(next_permutation(a + <span class="number">1</span>, a + <span class="number">1</span> + i));</span><br><span class="line">        sort(ans[i] + <span class="number">1</span>, ans[i] + cnt, cmp);</span><br><span class="line">        <span class="comment">// for(int j = 1; j &lt; cnt; ++j) &#123; for(int k = 1; k &lt;= i; ++k) cout &lt;&lt; ans[i][j].num[k] &lt;&lt; ""; cout &lt;&lt; endl;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[n][k].num[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, j == n? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a[<span class="number">30</span>];</span><br><span class="line">            a[<span class="number">1</span>] = n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                a[i] = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                next_permutation(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, i == n? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1006-string-matching-HDU-6629"><a href="#1006-string-matching-HDU-6629" class="headerlink" title="1006 string matching (HDU 6629)"></a>1006 string matching <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6629" target="_blank" rel="noopener">(HDU 6629)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定字符串 $s[0…len - 1]$，对于每个 $i &gt; 0$，用下图的程序求 $s[i…len - 1]$ 与 $s[0…len - 1]$ 的最长公共前缀的长度时，字符比较的操作进行了几次？<br><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/05/1565006124079-1565006124262.png" alt=""></p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>扩展KMP/Z函数</strong></p>
<p>签到题，扩展KMP (Z函数) 的裸题，cin 被卡了，改成 scanf 就过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Z函数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">z_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">z</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r)</span><br><span class="line">            z[i] = min(r - i + <span class="number">1</span>, z[i - l]);</span><br><span class="line">        <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]])</span><br><span class="line">            ++z[i];</span><br><span class="line">        <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r)</span><br><span class="line">            l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = z_function();</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = v.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v[i] + i &gt;= len) ans += v[i]; <span class="comment">// while 循环中 i + k &gt;= len 就退出循环了</span></span><br><span class="line">            <span class="keyword">else</span> ans += v[i] + <span class="number">1</span>; <span class="comment">// otherwise 语句，多比较一次才退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1007-permutation-2-HDU-6630"><a href="#1007-permutation-2-HDU-6630" class="headerlink" title="1007 permutation 2 (HDU 6630)"></a>1007 permutation 2 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6630" target="_blank" rel="noopener">(HDU 6630)</a></h2><p>$solved by ch$</p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定三个正整数 $N, x, y$，求 $1 \sim N$ 的全排列中满足下列条件的个数。</p>
<ol>
<li>$p_1 = x$</li>
<li>$p_N = y$</li>
<li>对于所有 $1 \le i &lt; N, |p_i - p_{i + 1}|\le 2$</li>
</ol>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>DP/动态规划</strong></p>
<p>特殊情况有点多，WA 了好几次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll dp[maxn] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>]) % mod;</span><br><span class="line">        <span class="comment">// if(i &lt;= 20)cout &lt;&lt; dp[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;x, &amp;y); <span class="comment">// cout &lt;&lt; dp[0] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; (dp[y - 1] - dp[x] + mod) % mod &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(y - x == <span class="number">1</span> &amp;&amp; n &gt; <span class="number">3</span> &amp;&amp; x == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y - x == <span class="number">1</span> &amp;&amp; n &gt; <span class="number">3</span> &amp;&amp; y == n) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y - x == <span class="number">1</span> &amp;&amp; n &gt; <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[y - x - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y - x == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[y - x - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">1</span> || y == n) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[y - x - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[y - x - <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>动态规划</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
        <tag>全排列</tag>
        <tag>扩展KMP</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第九场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%B9%9D%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=856" target="_blank" rel="noopener">2019 Multi-University Training Contest 9</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 9</a></p>
<h2 id="1005-Rikka-with-Game-HDU-6684"><a href="#1005-Rikka-with-Game-HDU-6684" class="headerlink" title="1005 Rikka with Game (HDU 6684)"></a>1005 Rikka with Game <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6684" target="_blank" rel="noopener">(HDU 6684)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>Rikka 和 Yuta 玩游戏。给定一个字符串。两人轮流对字符串操作。可以选择结束游戏，也可以改变其中一个字符，改变规则是：$a\rightarrow b,b\rightarrow c,…,y\rightarrow z,z\rightarrow a.$。Rikka 想要字典序最小，而 Yuta 想要字典序最大。求最终的字符串是什么。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">'z'</span> &amp;&amp; s[<span class="number">0</span>] != <span class="string">'y'</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] ==  <span class="string">'z'</span>) &#123;</span><br><span class="line">            s[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] &lt; <span class="string">'y'</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'z'</span>) &#123;</span><br><span class="line">                    s[i] = <span class="string">'b'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1006-Rikka-with-Coin-HDU-6685"><a href="#1006-Rikka-with-Coin-HDU-6685" class="headerlink" title="1006 Rikka with Coin (HDU 6685)"></a>1006 <a href="https://wutao18.github.io/2019/08/20/HDU-6685-Rikka-with-Coin-%E6%9E%9A%E4%B8%BE-%E6%80%9D%E7%BB%B4/">Rikka with Coin</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685" target="_blank" rel="noopener">(HDU 6685)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给出 $n$ 种物品的价格，现在要从无限枚 $10$元，$20$元，$50$元，$100$元的硬币中选出最少的硬币，满足能购买任何一种物品都不用找零。</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>显然如果个位不为零时没有可行方案。</p>
<p>接下来考虑可行方案的求解。</p>
<p>$10$ 分的硬币多只会用一个，如果用了两个，直接替换成一个 $10$ 分一个 $20$ 分一定不亏。</p>
<p>$20$ 分的硬币多只会用三个，如果用了四个，直接替换成一个 $10$ 分两个 $20$ 分一个 $50$ 分一定不亏。</p>
<p>$50$ 分的硬币多只会用一个，如果用了两个，直接替换成一个 $50$ 分和一个一元一定不亏。 </p>
<p>因此，直接暴力枚举 $10$, $20$, $50$ 的硬币的数量即可，整百的部分用一元硬币填充。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= c; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i * <span class="number">50</span> + j * <span class="number">20</span> + k * <span class="number">10</span> == n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">            <span class="keyword">if</span>(w[i] % <span class="number">10</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">1</span>; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(w[i] &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(judge(w[i], j, k, l)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                flag = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(judge(w[i] % <span class="number">100</span> + <span class="number">100</span>, j, k, l)) &#123;</span><br><span class="line">                                cnt = max(cnt, (w[i] - <span class="number">100</span>) / <span class="number">100</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(judge(w[i] % <span class="number">100</span>, j, k, l)) &#123;</span><br><span class="line">                                cnt = max(cnt, w[i] / <span class="number">100</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                flag = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                        ans = min(ans, cnt + j + k + l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
        <tag>思维</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第二场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=849" target="_blank" rel="noopener">2019 Multi-University Training Contest 2</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+2&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 2</a></p>
<h2 id="1005-Everything-Is-Generated-In-Equal-Probability-HDU-6595"><a href="#1005-Everything-Is-Generated-In-Equal-Probability-HDU-6595" class="headerlink" title="1005 Everything Is Generated In Equal Probability (HDU-6595)"></a>1005 Everything Is Generated In Equal Probability <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6595" target="_blank" rel="noopener">(HDU-6595)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给出一个整数 $N$，在 $[1,N]$ 中随机生成一个 $n$。然后生成长度为 $n$ 的全排列 $[1, n]$。</p>
<p>对该排列运行一个程序，程序先求当前排列的逆序对对数，然后随机从全排列中选出一个子序列。对该子序列继续进行本程序递归，直到子序列长度为 $0$ 则退出，程序返回逆序对数的总数。求程序产生的答案的期望。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll m)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = (ans * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll k = qpow(<span class="number">9</span>, mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        ll ans = n * n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * k % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1010-Just-Skip-The-Problem-HDU-6600"><a href="#1010-Just-Skip-The-Problem-HDU-6600" class="headerlink" title="1010 Just Skip The Problem (HDU-6600)"></a>1010 Just Skip The Problem <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6600" target="_blank" rel="noopener">(HDU-6600)</a></h2><p>$solved by zmz$</p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一个数 $n$，可以多次询问 $y_i$ ，然后可以知道 $n xor y_i$ 是否等于 $y_i$，询问最少次数就能知道 $n$ 是多少，求询问次数最少的询问方案数。</p>
<p>结果对 $1e6+3$ 取模。</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>答案为 $n! mod 1e6+3$。</p>
<p>当 $n \ge 1e6+3$ 时答案为 $0$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line">ll fac[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mod; ++i) &#123;</span><br><span class="line">        fac[i] = i * fac[i - <span class="number">1</span>];</span><br><span class="line">        fac[i] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= mod) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, fac[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1011-Keen-On-Everything-But-Triangle-HDU-6601"><a href="#1011-Keen-On-Everything-But-Triangle-HDU-6601" class="headerlink" title="1011 Keen On Everything But Triangle (HDU-6601)"></a>1011 Keen On Everything But Triangle <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6601" target="_blank" rel="noopener">(HDU-6601)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定 $n$ 个数，$q$ 个询问。</p>
<p>每个询问给定一个区间 $[L,R]$，问区间内能组成三角形的最大周长是多少。</p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>主席树 枚举</strong></p>
<p>主席树求区间第 $k$ 大，从第一大，第二大，第 $k$ 大这样不断枚举，只要符合条件就输出。</p>
<p>不能构成三角形的数列为斐波那契数列。由于斐波那契数列第 $40$ 多项就超过 $1e9$，因此枚举次数不会很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, sum;</span><br><span class="line">&#125; ns[MAXN * <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ct;</span><br><span class="line"><span class="keyword">int</span> rt[MAXN * <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">(<span class="keyword">int</span>&amp; now, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">    now = ++ct;</span><br><span class="line">    ns[now] = ns[old];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span>&amp; now)</span> </span>&#123;</span><br><span class="line">    ns[now].sum = ns[ns[now].ls].sum + ns[ns[now].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; now, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    now = ++ct;</span><br><span class="line">    ns[now].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ns[now].ls, l, m);</span><br><span class="line">    build(ns[now].rs, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; now, <span class="keyword">int</span> old, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cpy(now, old);</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ns[now].sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) update(ns[now].ls, ns[old].ls, l, m, x);</span><br><span class="line">    <span class="keyword">else</span> update(ns[now].rs, ns[old].rs, m + <span class="number">1</span>, r, x);</span><br><span class="line">    pushUp(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = ns[ns[t].ls].sum - ns[ns[s].ls].sum;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; s &lt;&lt; " " &lt;&lt; t &lt;&lt; " " &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= cnt) <span class="keyword">return</span> query(ns[s].ls, ns[t].ls, l, m, k);</span><br><span class="line">    <span class="keyword">return</span> query(ns[s].rs, ns[t].rs, m + <span class="number">1</span>, r, k - cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ct = <span class="number">0</span>;</span><br><span class="line">    build(rt[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN];</span><br><span class="line"><span class="keyword">int</span> c[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="comment">// scanf("%d%d", &amp;n, &amp;m);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sz = unique(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">        init(sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            a[i] = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + sz, a[i]) - b;</span><br><span class="line">            update(rt[i], rt[i - <span class="number">1</span>], <span class="number">1</span>, sz, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="keyword">int</span> s, t, k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;t);</span><br><span class="line">            <span class="comment">// printf("%d", t - s + 1);</span></span><br><span class="line">            <span class="comment">// printf("%d\n", b[query(rt[s - 1], rt[t], 1, sz, k)]);</span></span><br><span class="line">            <span class="keyword">if</span>(t - s + <span class="number">1</span> &lt; <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = t - s + <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    c[cnt] = b[query(rt[s - <span class="number">1</span>], rt[t], <span class="number">1</span>, sz, i)];</span><br><span class="line">                    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span> &amp;&amp; c[cnt - <span class="number">2</span>] &lt; c[cnt - <span class="number">1</span>] + c[cnt]) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, c[cnt - <span class="number">2</span>] * <span class="number">1l</span>l + c[cnt - <span class="number">1</span>] * <span class="number">1l</span>l + c[cnt] * <span class="number">1l</span>l);</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>枚举</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第八场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E5%85%AB%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=855" target="_blank" rel="noopener">2019 Multi-University Training Contest 8</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+8&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 8</a></p>
<h2 id="1003-Acesrc-and-Good-Numbers-HDU-6659"><a href="#1003-Acesrc-and-Good-Numbers-HDU-6659" class="headerlink" title="1003 Acesrc and Good Numbers HDU 6659"></a>1003 <a href="https://wutao18.github.io/2019/08/19/HDU-6659-Acesrc-and-Good-Numbers-%E6%95%B0%E5%AD%A6-%E6%80%9D%E7%BB%B4/">Acesrc and Good Numbers</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6659" target="_blank" rel="noopener">HDU 6659</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>定义 $f(d, n)$ 为十进制下 $1$ 到 $n$ 所有数的数位中数字 $d$ 出现的次数。给定 $x$，找出最大的 $n(n \le x)$ 满足 $f(d, n) = n$。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看到了一个神仙做法。</p>
<p>显然如果 $f(d, x) = x$ 时就直接输出。</p>
<p>否则，需要缩小 $x$。令 $f(d, x) = y$，则需要将 $x$ 缩小 $\lceil \frac{|x - y|}{18} \rceil$。即 $x = x - abs(f(d, x) - x) / 18$。原因是 $f(d, x)$ 与 $f(d, x - 1)$ 最多相差 $18$ 个 $d$ $ (e.g.  f(9, 10^{18}-1) to f(9, 10^{18}-2))$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 1 到 n 中数字 x 出现的次数</span></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll d, ll n)</span> </span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>, k;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; k = n / i; i *= <span class="number">10</span>) &#123;</span><br><span class="line">        cnt += (k / <span class="number">10</span>) * i;</span><br><span class="line">        <span class="keyword">int</span> cur = k % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; d) &#123;</span><br><span class="line">            cnt += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur == d) &#123;</span><br><span class="line">            cnt += n - k * i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll d, x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ll num = f(d, x);</span><br><span class="line">            <span class="keyword">if</span> (num == x) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x -= max(<span class="number">1L</span>L, <span class="built_in">abs</span>(num - x) / <span class="number">18</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/jk_chen_acmer/article/details/99595262" target="_blank" rel="noopener">2019 Multi-University Training Contest 8——Acesrc and Good Numbers（数学 想法）</a></p>
<h2 id="1009-Calabash-and-Landlord-HDU-6665"><a href="#1009-Calabash-and-Landlord-HDU-6665" class="headerlink" title="1009 Calabash and Landlord HDU 6665"></a>1009 <a href="https://wutao18.github.io/2019/08/14/HDU-6665-Calabash-and-Landlord-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/">Calabash and Landlord</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6665" target="_blank" rel="noopener">HDU 6665</a></h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给出两个矩形，求矩形把平面分割成几块。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>分类讨论</strong></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/14/1565792338325-1565792338743.png" alt=""></p>
<p>听说只要离散化到 $5*5$ 的格子里然后 $DFS$ 就可以了，有空再补。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;p[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll maxx = <span class="number">0</span>, maxy = <span class="number">0</span>, minx = inf, miny = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        p[<span class="number">3</span>].x = p[<span class="number">1</span>].x;</span><br><span class="line">        p[<span class="number">3</span>].y = p[<span class="number">2</span>].y;</span><br><span class="line">        p[<span class="number">4</span>].x = p[<span class="number">2</span>].x;</span><br><span class="line">        p[<span class="number">4</span>].y = p[<span class="number">1</span>].y;</span><br><span class="line">        ll s1 = (p[<span class="number">2</span>].x - p[<span class="number">1</span>].x) * (p[<span class="number">2</span>].y - p[<span class="number">1</span>].y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        p[<span class="number">7</span>].x = p[<span class="number">5</span>].x;</span><br><span class="line">        p[<span class="number">7</span>].y = p[<span class="number">6</span>].y;</span><br><span class="line">        p[<span class="number">8</span>].x = p[<span class="number">6</span>].x;</span><br><span class="line">        p[<span class="number">8</span>].y = p[<span class="number">5</span>].y;</span><br><span class="line">        ll s2 = (p[<span class="number">6</span>].x - p[<span class="number">5</span>].x) * (p[<span class="number">6</span>].y - p[<span class="number">5</span>].y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            maxx = max(maxx, p[i].x);</span><br><span class="line">            maxy = max(maxy, p[i].y);</span><br><span class="line">            minx = min(minx, p[i].x);</span><br><span class="line">            miny = min(miny, p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= 8; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; p[i].x &lt;&lt; " " &lt;&lt; p[i].y &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">1</span>].y == p[<span class="number">5</span>].y &amp;&amp; p[<span class="number">3</span>].x == p[<span class="number">7</span>].x &amp;&amp; p[<span class="number">3</span>].y == p[<span class="number">7</span>].y &amp;&amp; p[<span class="number">6</span>].x == p[<span class="number">2</span>].x &amp;&amp; p[<span class="number">6</span>].y == p[<span class="number">2</span>].y &amp;&amp; p[<span class="number">4</span>].x == p[<span class="number">8</span>].x &amp;&amp; p[<span class="number">4</span>].y == p[<span class="number">8</span>].y) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll s = (maxx - minx) * (maxy - miny); <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == s || s2 == s) &#123;</span><br><span class="line">            <span class="keyword">if</span>((p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">2</span>].x == p[<span class="number">6</span>].x)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">5</span>].y == p[<span class="number">1</span>].y || p[<span class="number">6</span>].y == p[<span class="number">2</span>].y) <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>((p[<span class="number">1</span>].y == p[<span class="number">5</span>].y &amp;&amp; p[<span class="number">2</span>].y == p[<span class="number">6</span>].y)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">5</span>].x == p[<span class="number">1</span>].x || p[<span class="number">6</span>].x == p[<span class="number">2</span>].x) <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">4</span>].y &gt;= p[<span class="number">7</span>].y || p[<span class="number">8</span>].y &gt;= p[<span class="number">3</span>].y || p[<span class="number">5</span>].x &gt;= p[<span class="number">2</span>].x || p[<span class="number">1</span>].x &gt;= p[<span class="number">6</span>].x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((p[<span class="number">2</span>].x - p[<span class="number">1</span>].x) * (p[<span class="number">6</span>].y - p[<span class="number">5</span>].y) == s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">6</span>].y &gt; p[<span class="number">2</span>].y &amp;&amp; p[<span class="number">5</span>].y &lt; p[<span class="number">1</span>].y &amp;&amp; p[<span class="number">1</span>].x &lt; p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">2</span>].x &gt; p[<span class="number">6</span>].x) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"6\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">1</span>].y == p[<span class="number">5</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">3</span>].x == p[<span class="number">7</span>].x &amp;&amp; p[<span class="number">3</span>].y == p[<span class="number">7</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">2</span>].x == p[<span class="number">6</span>].x &amp;&amp; p[<span class="number">2</span>].y == p[<span class="number">6</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">4</span>].x == p[<span class="number">8</span>].x &amp;&amp; p[<span class="number">4</span>].y == p[<span class="number">8</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"5\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((p[<span class="number">6</span>].x - p[<span class="number">5</span>].x) * (p[<span class="number">2</span>].y - p[<span class="number">1</span>].y) == s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">2</span>].y &gt; p[<span class="number">6</span>].y &amp;&amp; p[<span class="number">1</span>].y &lt; p[<span class="number">5</span>].y &amp;&amp; p[<span class="number">5</span>].x &lt; p[<span class="number">1</span>].x &amp;&amp; p[<span class="number">6</span>].x &gt; p[<span class="number">2</span>].x) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"6\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">1</span>].y == p[<span class="number">5</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">3</span>].x == p[<span class="number">7</span>].x &amp;&amp; p[<span class="number">3</span>].y == p[<span class="number">7</span>].y) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">2</span>].x == p[<span class="number">6</span>].x &amp;&amp; p[<span class="number">2</span>].y == p[<span class="number">6</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">4</span>].x == p[<span class="number">8</span>].x &amp;&amp; p[<span class="number">4</span>].y == p[<span class="number">8</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"5\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1010-Quailty-and-CCPC-HDU-6666"><a href="#1010-Quailty-and-CCPC-HDU-6666" class="headerlink" title="1010 Quailty and CCPC HDU 6666"></a>1010 Quailty and CCPC <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6666" target="_blank" rel="noopener">HDU 6666</a></h2><p>签到题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Team</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    ll p, t;</span><br><span class="line">&#125; te[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Team t1, Team t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.p == t2.p) <span class="keyword">return</span> t1.t &lt; t2.t;</span><br><span class="line">    <span class="keyword">return</span> t1.p &gt; t2.p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%lld%lld"</span>, &amp;te[i].name, &amp;te[i].p, &amp;te[i].t);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(te, te + n, cmp);</span><br><span class="line">        <span class="comment">// d *= 0.1;</span></span><br><span class="line">        <span class="comment">// double l = floor(d * n), r = ceil(d * n);</span></span><br><span class="line">        <span class="comment">// double de = d * n - floor(d * n);</span></span><br><span class="line">        <span class="keyword">if</span>((d * n) % <span class="number">10</span> == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = d * n / <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, te[ans].name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Quailty is very great\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1011-Roundgod-and-Milk-Tea-HDU-6667"><a href="#1011-Roundgod-and-Milk-Tea-HDU-6667" class="headerlink" title="1011 Roundgod and Milk Tea HDU 6667"></a>1011 <a href="https://wutao18.github.io/2019/08/14/HDU-6667-Roundgod-and-Milk-Tea-%E6%80%9D%E7%BB%B4/">Roundgod and Milk Tea</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6667" target="_blank" rel="noopener">HDU 6667</a></h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><p>有 $n$ 个班级，每个班有 $a_i$ 个人，做了 $b_i$ 杯奶茶，每个班的每个人最多喝一杯奶茶且不能和自己班做的奶茶，问最多共有多少人喝到奶茶。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>最初的想法是用一个 $sum$ 记录所有剩余的奶茶数，然后每个组能喝的奶茶数为 $sum -$ 该组的奶茶(自己不能喝自己的) $+$ 上一组做的奶茶 (上一组减掉的加回来)。后来发现有点问题，就是中间一步减掉自己的奶茶可能是减多的，也就是上一组喝掉的可能就是当前组的奶茶，那么当前组剩余的奶茶是比原来少的，于是就用 $tmp2$ 保存上一组喝掉的奶茶数，每次让上一组喝掉当前组的奶茶，如果不够喝再用 $tmp$ 保存还要喝掉的奶茶数，往下迭代。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Team</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll m, n;  <span class="comment">// 人数 奶茶数</span></span><br><span class="line">&#125; t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Team t1, Team t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.m &gt; t2.m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;t[i].m, &amp;t[i].n);</span><br><span class="line">            sum += t[i].n;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(t, t + n, cmp);</span><br><span class="line">        ll ans = <span class="number">0</span>; </span><br><span class="line">        ll tmp = t[<span class="number">0</span>].n; <span class="comment">// tmp 保存喝掉的奶茶数 第一组一定要被喝</span></span><br><span class="line">        ll tmp2 = <span class="number">0</span>; <span class="comment">// tmp2 保存的是上一组喝掉的奶茶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i) &#123;</span><br><span class="line">                <span class="comment">// 上一组喝掉的奶茶数+之前喝掉的奶茶数</span></span><br><span class="line">                <span class="keyword">if</span>(t[i].n &lt; tmp2 + tmp) &#123;</span><br><span class="line">                    t[i].n = <span class="number">0</span>;</span><br><span class="line">                    tmp = tmp2 + tmp - t[i].n;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t[i].n = t[i].n - (tmp2 + tmp);</span><br><span class="line">                    tmp = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= t[i].n; <span class="comment">// 自己不能喝自己的奶茶</span></span><br><span class="line">            <span class="keyword">if</span>(i) sum += t[i - <span class="number">1</span>].n; <span class="comment">// 可以喝上一组的奶茶</span></span><br><span class="line">            <span class="comment">// 剩余的奶茶数与第 i 组人数比较</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= t[i].m) &#123;</span><br><span class="line">                ans += t[i].m;</span><br><span class="line">                sum -= t[i].m;</span><br><span class="line">                tmp2 = t[i].m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += sum;</span><br><span class="line">                sum -= sum;</span><br><span class="line">                tmp2 = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比赛中完全想复杂了，其实完全可以很快处理。把每个人能喝的奶茶加起来和所有的奶茶比较即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">            sum += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += min(a[i], sum - b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(ans, sum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>数学</tag>
        <tag>思维</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第六场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E5%85%AD%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=853" target="_blank" rel="noopener">2019 Multi-University Training Contest 6</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+6&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 6</a></p>
<h2 id="1002-Nonsense-Time-HDU-6635"><a href="#1002-Nonsense-Time-HDU-6635" class="headerlink" title="1002 Nonsense Time (HDU 6635)"></a>1002 Nonsense Time <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6635" target="_blank" rel="noopener">(HDU 6635)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定包含 $n$ 个不同数字的排列 $p$。一开始所有数字都冻住。再给出一个长度为 $n$ 的数组 $k$，$k[i]$ 表示 $p[k[i]]$ 在第 $i$ 时刻解冻。输出 $n$ 个数，表示第 $i$ 个时刻数组 $p$ 中解冻的数字的最长上升子序列的长度。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>思维 LIS</strong></p>
<p>倒过来考虑 (时光倒流)。一开始所有数都是解冻的，一个一个开始冰冻。每冰冻一个数字，判断是否在当前最长上升子序列内，如果不在就输出当前最长上升子序列的长度，否则重新计算最长上升子序列。</p>
<p>由于给定的排列是随机的，随机排列的期望 $LIS$ 的长度是 $O(\sqrt{n})$，一个数在最长上升子序列内的概率为 $1 / \sqrt{n}$，那么期望删除 $O(\sqrt{n})$ 个数才会修改 $LIS$。期望时间复杂度为 $O(n\sqrt{n}logn)$。</p>
<h2 id="1008-TDL-HDU-6641"><a href="#1008-TDL-HDU-6641" class="headerlink" title="1008 TDL (HDU 6641)"></a>1008 TDL <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6641" target="_blank" rel="noopener">(HDU 6641)</a></h2><p>$solved by zmz$</p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>定义 $f(n, m)$ 为第 $m$ 小的整数 $x$ 满足 $x&gt;n$ 并且 $gcd(x,n)=1$。给定 $m$ 和 $k$，求满足 $(f(n,m)-n)⊕n=k$ 的最小正整数 $n$。($⊕$ 代表按位异或)</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>质数的密度分布</strong></p>
<p>$f(n,m)-n$ 不会超过第 $m$ 个与 $n$ 互质的质数，$m$ 是比较小的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll k, m;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; m;</span><br><span class="line">        ll left = k - <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>)left = <span class="number">1</span>;</span><br><span class="line">        ll right = k + <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            ll cnt = <span class="number">0</span>, tmp = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(tmp, i) == <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; i &lt;&lt; " " &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; "tmp:" &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> ((k ^ i) == tmp - i - <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1012-Stay-Real-HDU-6645"><a href="#1012-Stay-Real-HDU-6645" class="headerlink" title="1012 Stay Real (HDU 6645)"></a>1012 Stay Real <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6645" target="_blank" rel="noopener">(HDU 6645)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一个小根堆，两个人每次从叶子节点取出一个数累加到自身的分数，堆为空时游戏结束，两个人选择最优策略。求两个人最终的分数。</p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心 排序</strong></p>
<p>两个人每次取最大的值，因此直接排序后间隔着累加就行，也可以使用优先队列。时间复杂度 $O(nlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        ll s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n - i) % <span class="number">2</span>) s1 += a[i];</span><br><span class="line">            <span class="keyword">else</span> s2 += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>素数</tag>
        <tag>LIS</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第十场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E5%8D%81%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=857" target="_blank" rel="noopener">2019 Multi-University Training Contest 10</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+10&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 10</a></p>
<h2 id="1003-Valentine’s-Day-HDU-6693"><a href="#1003-Valentine’s-Day-HDU-6693" class="headerlink" title="1003 Valentine’s Day (HDU 6693)"></a>1003 <a href="https://wutao18.github.io/2019/08/22/HDU-6693-Valentine-s-Day-%E6%A6%82%E7%8E%87/">Valentine’s Day</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6693" target="_blank" rel="noopener">(HDU 6693)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>有 $n$ 种礼物，第 $i$ 种礼物能让女朋友开心的概率为 $P_i$，挑一些礼物，问让女朋友开心一次的概率最大为多少。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>概率 贪心</strong></p>
<p>如果有概率大于等于 $0.5$ 的礼物，输出其中最大的。</p>
<p>否则，对概率从大到小。暴力枚举选择前 $k$ 大的礼物的的概率，求最大值即可。</p>
<p>此题有原题。见 <a href="https://codeforces.com/problemset/problem/442/B" target="_blank" rel="noopener">CodeForces 442B</a></p>
<p>相关证明见官方题解：<a href="https://codeforces.com/blog/entry/12739" target="_blank" rel="noopener">Codeforces #253 editorial</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>, maxa = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[i]);</span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(maxa = <span class="number">-1</span>) maxa = p[i];</span><br><span class="line">                <span class="keyword">else</span> maxa = max(maxa, p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, maxa);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(p, p + n);</span><br><span class="line">            <span class="keyword">double</span> tmp1 = p[n - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> tmp2 = p[n - <span class="number">1</span>] * (<span class="number">1</span> - p[n - <span class="number">2</span>]) + p[n - <span class="number">2</span>] * (<span class="number">1</span> - p[n - <span class="number">1</span>]);</span><br><span class="line">            ans = tmp2;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp1 &lt; tmp2 &amp;&amp; k &lt;= n) &#123;</span><br><span class="line">                ans = tmp2;</span><br><span class="line">                tmp1 = tmp2;</span><br><span class="line">                tmp2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= n - k; --i) &#123;</span><br><span class="line">                    <span class="keyword">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= n - k; --j) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j == i) &#123;</span><br><span class="line">                            tmp *= p[j];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            tmp *= <span class="number">1</span> - p[j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp2 += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, max(ans, tmp2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-Welcome-Party-HDU-6695"><a href="#1005-Welcome-Party-HDU-6695" class="headerlink" title="1005 Welcome Party (HDU 6695)"></a>1005 <a href="https://wutao18.github.io/2019/08/23/HDU-6695-Welcome-Party-%E8%B4%AA%E5%BF%83/">Welcome Party</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6695" target="_blank" rel="noopener">(HDU 6695)</a></h2><p>$solved by ch$</p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>有 $n$ 个人，$2$ 种节目，每个人要表演其中的一种节目，每种节目至少有一人表演。用 $x_i$ 和 $y_i$ 表示第 $i (1\le i\le n)$ 个人表演两种节目的能力值。现在要使表演第一种节目的人中的能力最大值与表演第二种节目的人中的能力最大值之差最小，求这个最小值。</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心</strong></p>
<p>如下图，维护两个集合 $s_1$ 和 $s_2$。 </p>
<p>按 $x$ 从大到小枚举。假设 $x_i$ 为 $x$ 中的最大值 (下图中的 $4$)，则比 $x_i$ 大的都选择 $y$，也就是取 $s_1$ 中的最大值 (下图中的 $8$)。比 $x_i$ 小的取与 $x_i$ 最接近的 $y$ (下图中的 $3$)，因为更大的 $y$ 可以选择 $x$ (下图中的 $7$ 可以用 $2$ 替换)。然后取两个的较大值更新到 $ans$ (下图中 $|3 - 4| &lt; |8 - 4|$ 取 $8 - 4$)，维护最小值 $ans$ 即可。</p>
<p>比赛中队友 (线段树大佬) 用线段树过的。赛后我用 $multiset$ 写了一下。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/23/1566573834928-1566573834928.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">2e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span> &#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125; s[maxn];</span><br><span class="line">ll maxy[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(STU s1, STU s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.x &gt; s2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;ll&gt; s1, s2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s[i].x &gt;&gt; s[i].y;</span><br><span class="line">            s2.insert(s[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(s, s + n, cmp);</span><br><span class="line">        ll ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s2.erase(s2.find(s[i].y));  <span class="comment">// 一个人只能选择一种表演</span></span><br><span class="line">            <span class="keyword">if</span>(!s1.empty()) &#123;</span><br><span class="line">                ans = min(ans, <span class="built_in">abs</span>(*s1.rbegin() - s[i].x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.empty()) &#123;</span><br><span class="line">                <span class="built_in">multiset</span>&lt;ll&gt;::iterator it = s2.lower_bound(s[i].x); <span class="comment">// 找到第一个大于等于 s[i].x 的 y</span></span><br><span class="line">                <span class="keyword">if</span>(it == s2.end()) &#123;</span><br><span class="line">                    --it;</span><br><span class="line">                &#125;</span><br><span class="line">                ll tmp = <span class="built_in">abs</span>(*it - s[i].x);</span><br><span class="line">                <span class="keyword">if</span>(tmp &lt; ans &amp;&amp; (s1.empty() || *it &gt; *s1.rbegin())) &#123;</span><br><span class="line">                    ans = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(it != s2.begin()) &#123;  <span class="comment">// 找到最后一个小于 s[i].x 的 y</span></span><br><span class="line">                    --it;</span><br><span class="line">                    tmp = <span class="built_in">abs</span>(*it - s[i].x);</span><br><span class="line">                    <span class="keyword">if</span>(tmp &lt; ans &amp;&amp; (s1.empty() || *it &gt; *s1.rbegin())) &#123;</span><br><span class="line">                        ans = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                s1.insert(s[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1007-Closest-Pair-of-Segments-HDU-6697"><a href="#1007-Closest-Pair-of-Segments-HDU-6697" class="headerlink" title="1007 Closest Pair of Segments (HDU 6697)"></a>1007 <a href="https://wutao18.github.io/2019/08/24/HDU-6697-Closest-Pair-of-Segments-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E6%9A%B4%E5%8A%9B/">Closest Pair of Segments</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6697" target="_blank" rel="noopener">(HDU 6697)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>类似于计算几何中的最近点对问题，本题求的是最近线段对。</p>
<p>给定 $n$ 条线段，求出最近线段对之间的距离。</p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>暴力 剪枝</strong></p>
<p>比赛时我用了三角剖分，结果超时了。</p>
<p>赛后补题时看到了这篇博客：<a href="https://www.cnblogs.com/dd-bond/p/11391771.html" target="_blank" rel="noopener">HDU 6697 Closest Pair of Segments（线段距离）</a></p>
<p>原来暴力加上剪枝就能过。思路是这样的：</p>
<p>首先将线段的左侧端点按照横坐标为第一关键字，纵坐标为第二关键字排序。然后暴力找所有线段对，维护最小值 $ans$。如果当前查询的线段对中，右侧线段的左端点与左侧线段的右端点的横坐标差值大于 $ans$ 时，就不用再找更右侧的直线了。这样剪枝能大大减少时间复杂度。</p>
<p>时限给了 20s，大概 1.3s 就能跑完。</p>
<p><del>题解看不懂</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point s, e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();</span><br><span class="line">        e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.dis(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点到直线的距离</span></span><br><span class="line">    <span class="function">db <span class="title">point_to_line</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>((p - s).cross(e - s) / length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点到线段的距离</span></span><br><span class="line">    <span class="function">db <span class="title">point_to_seg</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dcmp((p - s).dot((e - s))) &lt; <span class="number">0</span> || dcmp((p - e).dot((s - e))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> min(p.dis(s), p.dis(e));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> point_to_line(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线段到线段的距离</span></span><br><span class="line">    <span class="function">db <span class="title">seg_to_seg</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> min(min(point_to_seg(l.s), point_to_seg(l.e)), min(l.point_to_seg(s), l.point_to_seg(e)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Line l1, Line l2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> l1.s &lt; l2.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            l[i].input();</span><br><span class="line">			<span class="keyword">if</span>(l[i].e &lt; l[i].s) swap(l[i].s, l[i].e);</span><br><span class="line">        &#125;</span><br><span class="line">		sort(l, l + n, cmp);</span><br><span class="line">		<span class="keyword">double</span> ans = <span class="number">1e10</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 剪枝部分</span></span><br><span class="line">				<span class="keyword">if</span>(dcmp((l[j].s.x - l[i].e.x) - ans) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ans = min(ans, l[i].seg_to_seg(l[j])); <span class="comment">// 更新最小值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1009-Block-Breaker-HDU-6699"><a href="#1009-Block-Breaker-HDU-6699" class="headerlink" title="1009 Block Breaker (HDU 6699)"></a>1009 Block Breaker <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6699" target="_blank" rel="noopener">(HDU 6699)</a></h2><p>$solved by zmz$</p>
<p>队友签的到。</p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>暴力</tag>
        <tag>概率</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 杭电多校 第四场</title>
    <url>/2019/08/29/2019-%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E5%9B%9B%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=851" target="_blank" rel="noopener">2019 Multi-University Training Contest 4</a></p>
<p>补题链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+4&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 4</a></p>
<h2 id="1001-AND-Minimum-Spanning-Tree-HDU-6614"><a href="#1001-AND-Minimum-Spanning-Tree-HDU-6614" class="headerlink" title="1001 AND Minimum Spanning Tree (HDU 6614)"></a>1001 AND Minimum Spanning Tree <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6614" target="_blank" rel="noopener">(HDU 6614)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一个有 $N$ 个结点的完全图，编号从 $1$ 到 $N$。结点 $x$ 与结点 $y$ $(1\leq x, y\leq N, x \neq y)$ 的边的权值为 $x$ 与 $y$ 按位与的值，求该图的最小生成树。</p>
</blockquote>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>位运算</strong></p>
<p>偶数与 1 按位与的值一定是 0，奇数与 1 按位与的值一定是 1。<br>因此，让所有的偶数结点与结点 $1$ 相连即可。<br>接着连接奇数结点。一个数 $x$ 与奇数按位与的值为 0，那么奇数二进制表示下中的 1 全部要变成 0。由于结点编号从 $1$ 到 $N$，那么结点不能取 $0$，因此 $x$ 二进制中至少包含一个 1。为了让 $x$ 尽可能的小（输出为字典序最小），可以让奇数二进制表示下的从右到左第一个 0 变成 1，如下表所示。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">奇数</th>
<th style="text-align:center">二进制</th>
<th style="text-align:center">$x$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">00<strong>11</strong></td>
<td style="text-align:center">01<strong>00</strong></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0<strong>1</strong>0<strong>1</strong></td>
<td style="text-align:center">0<strong>0</strong>1<strong>0</strong></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0<strong>111</strong></td>
<td style="text-align:center">1<strong>000</strong></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><strong>1</strong>00<strong>1</strong></td>
<td style="text-align:center"><strong>0</strong>01<strong>0</strong></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><strong>1</strong>0<strong>11</strong></td>
<td style="text-align:center"><strong>0</strong>1<strong>00</strong></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><strong>11</strong>0<strong>1</strong></td>
<td style="text-align:center"><strong>00</strong>1<strong>0</strong></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><strong>1111</strong></td>
<td style="text-align:center">1<strong>0000</strong></td>
</tr>
</tbody>
</table>
</div>
<p>注意：如果奇数选择的最小结点大于 $N$，那么让该奇数结点与结点 $1$ 相连，边的权值为 1。<br>因此，偶数结点的边权一定为 0，奇数结点如果与偶数结点相连边权为 0，与结点 $1$ 相连权值为 1，保证总的边权最小，满足最小生成树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = i;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(tmp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    s++;</span><br><span class="line">                    tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">                <span class="keyword">if</span>(t &gt; n) &#123;</span><br><span class="line">                    ans[i] = <span class="number">1</span>;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans[i] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, i == n? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1003-Divide-the-Stones-HDU-6616"><a href="#1003-Divide-the-Stones-HDU-6616" class="headerlink" title="1003 Divide the Stones (HDU 6616)"></a>1003 Divide the Stones <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6616" target="_blank" rel="noopener">(HDU 6616)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定两个整数 $n$ 和 $k$，将 $1 \sim n$ 的整数分成 $k$ 组，要求每组中的所有数的和相同且每组的数的个数也相同，求可行解。</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>思维</strong></p>
<p>分类讨论。</p>
<ol>
<li><p>当 $n$ 为偶数时，$n / k$ 也必须是偶数。然后蛇形取法即可。</p>
</li>
<li><p>当 $n$ 为奇数时，$n / k$ 也必须是奇数。$k = 1$ 时特判。其余情况每组先分 $3$ 个，剩下的按照第一步的方法即可。</p>
</li>
</ol>
<h2 id="1007-Just-an-Old-Puzzle-HDU-6620"><a href="#1007-Just-an-Old-Puzzle-HDU-6620" class="headerlink" title="1007 Just an Old Puzzle (HDU 6620)"></a>1007 Just an Old Puzzle <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6620" target="_blank" rel="noopener">(HDU 6620)</a></h2><p>$solved by ch$</p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定 $4 * 4$ 的方格，包含 $1$ 到 $15$ 的数和一个空格。空格可以和上下左右的数字块交换。试求是否能够在 $120$ 步移动空格使得方格变成图中的目标状态。<br><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/07/31/1564575558344-1564575558369.png" alt=""></p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>逆序数</strong></p>
<p>题目只需考虑是否有解，不需求出移动步数。即判断十五数码问题是否有解。<br>满足下列条件一定有解。</p>
<ol>
<li>若格子列数为奇数，则逆序数必须为偶数；</li>
<li>若格子列数为偶数，且逆序数为偶数，则当前空格所在行数与初始空格所在行数的差为偶数；</li>
<li>若格子列数为偶数，且逆序数为奇数，则当前空格所在行数与初始空格所在行数的差为奇数。</li>
</ol>
<p>参考</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/1c1849d876b2" target="_blank" rel="noopener">数字华容道怎样才能有解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>,it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>) it=i/<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">else</span> it=<span class="number">1</span>+i/<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">16</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[i])</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;it&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="number">4</span>-it)%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="number">4</span>-it)%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1008-K-th-Closest-Distance-HDU-6621"><a href="#1008-K-th-Closest-Distance-HDU-6621" class="headerlink" title="1008 K-th Closest Distance (HDU 6621)"></a>1008 K-th Closest Distance <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6621" target="_blank" rel="noopener">(HDU 6621)</a></h2><p>$solved by ch$</p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一个 $a_1 … a_n$ 的数组。给定 $m$ 个询问，每个询问包含四个整数 $L$， $R$， $p$， $K$，求 $\{|a_L - p|, |a_{L+1} - p|, … ,|a_R -<br> p|\}$ 中第 $K$ 大的数。</p>
</blockquote>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>二分 排序 离散化</strong></p>
<p>记录所有数的下标，对所有数离散化，查找 $p$ 的位置，往左往右分别找 $k$ 个数，使得这些数的下标在区间 $[L, R]$ 内，对所有找到的数排序，第 $k$ 大的数即是答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DATE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, val;</span><br><span class="line">&#125; D;</span><br><span class="line">D date[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(D a, D b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">int</span> n, m, num = <span class="number">0</span>, Xor = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            date[i].id = i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;date[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(date + <span class="number">1</span>, date + n + <span class="number">1</span>, cmp1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[num] != date[i].val)</span><br><span class="line">                a[++num] = date[i].val;</span><br><span class="line">            id[num].push_back(date[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sort(id[i].begin(), id[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, L, R, it, p, k, x[<span class="number">1010</span>], tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l, &amp;r, &amp;p, &amp;k);</span><br><span class="line">            l ^= Xor, r ^= Xor, k ^= Xor, p ^= Xor;</span><br><span class="line">            it = lower_bound(a + <span class="number">1</span>, a + num + <span class="number">1</span>, p) - a;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = <span class="number">0</span>, tmp2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = it - <span class="number">1</span>; j &gt;= <span class="number">1</span> &amp;&amp; tmp1 &lt;= k; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                L = lower_bound(id[j].begin(), id[j].end(), l) - id[j].begin();</span><br><span class="line">                <span class="keyword">while</span> (L &lt; id[j].size() &amp;&amp; id[j][L] &lt;= r)</span><br><span class="line">                &#123;</span><br><span class="line">                    x[tmp++] = <span class="built_in">abs</span>(a[j] - p);</span><br><span class="line">                    L++;</span><br><span class="line">                    tmp1++;</span><br><span class="line">                    <span class="keyword">if</span> (tmp1 &gt; k)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = it; j &lt;= num &amp;&amp; tmp2 &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                L = lower_bound(id[j].begin(), id[j].end(), l) - id[j].begin();</span><br><span class="line">                <span class="keyword">while</span> (L &lt; id[j].size() &amp;&amp; id[j][L] &lt;= r)</span><br><span class="line">                &#123;</span><br><span class="line">                    x[tmp++] = <span class="built_in">abs</span>(a[j] - p);</span><br><span class="line">                    L++;</span><br><span class="line">                    tmp2++;</span><br><span class="line">                    <span class="keyword">if</span> (tmp2 &gt; k)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(x, x + tmp);</span><br><span class="line">            Xor = x[k - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x[k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">            id[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1010-Minimal-Power-of-Prime-HDU-6623"><a href="#1010-Minimal-Power-of-Prime-HDU-6623" class="headerlink" title="1010 Minimal Power of Prime (HDU 6623)"></a>1010 Minimal Power of Prime <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6623" target="_blank" rel="noopener">(HDU 6623)</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定一个整数 $n &gt; 1$，分解质因数后，求最小的指数。</p>
</blockquote>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>素数筛 质因数分解</strong></p>
<p>由于 $3982^4 &gt; 10^{18}$，那么所有大于 $3982$ 的数的指数最多为 $4$。<br>先筛出 $4000$ 以内的所有质数，将 $n$ 暴力分解质因数。如果 $n$ 还没分解完，那么剩下的数分解质因数后的指数只能是 $1$ 到 $4$ 之间，从大到小枚举即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="keyword">int</span> is_prime[<span class="number">4000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">4000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) &#123;</span><br><span class="line">            primes.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes[j] &lt; <span class="number">4000</span>; ++j) &#123;</span><br><span class="line">            is_prime[i * primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; primes.size() &amp;&amp; primes[i] * primes[i] &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % primes[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(n % primes[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                n /= primes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || ans == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">        ll num = <span class="built_in">pow</span>(n, <span class="number">1.0</span> / i);</span><br><span class="line">        <span class="keyword">for</span>(ll j = num - <span class="number">3</span>; j &lt; num + <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            ll res = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k) res *= j;</span><br><span class="line">            <span class="keyword">if</span>(res == n) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            ans = min(ans, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve();</span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 30; ++i) cout &lt;&lt; primes[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ans = <span class="number">65</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        solve();</span><br><span class="line">        <span class="comment">// printf("%d\n", ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>思维</tag>
        <tag>二分</tag>
        <tag>数论</tag>
        <tag>素数</tag>
        <tag>分类讨论</tag>
        <tag>排序</tag>
        <tag>位运算</tag>
        <tag>逆序数</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM 中的对拍程序</title>
    <url>/2019/10/26/ACM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%8B%8D%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>所谓对拍，就是随机生成数据，然后用一个肯定正确的暴力算法的程序，去测试一个要提交的程序。</p>
<p>由于比赛中一般使用 Linux 系统，所以本篇博客的代码都是 Linux 下的程序代码。</p>
<p><del>其实最简单的方式是写脚本。</del></p>
<p>这里介绍的是用选手最熟悉的 C++ 语言写对拍程序。</p>
<a id="more"></a>
<p>假设要提交的程序为 sol.cpp，暴力的程序为 bf.cpp，随机数据生成器 random.cpp。</p>
<p>首先编译这三个程序，得到 sol，bf，random。</p>
<p>一种简单的方法就是先生成数据，然后暴力程序和待测试程序分别运行，比较结果。</p>
<p>生成数据，输出到 data.in</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;random &gt; .&#x2F;data.in</span><br></pre></td></tr></table></figure>
<p>先运行暴力程序，结果输出到 data.out</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bf &lt; .&#x2F;data.in &gt; .&#x2F;data.out</span><br></pre></td></tr></table></figure>
<p>然后运行待测试程序，结果输出到 data.ans</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;sol &lt; .&#x2F;data.in &gt; .&#x2F;data.ans</span><br></pre></td></tr></table></figure>
<p>然后比较两个结果是否相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff .&#x2F;data.out .&#x2F;data.out</span><br></pre></td></tr></table></figure>
<p>上述方法的缺点是无法统计时间。</p>
<p>于是就有了以下的对拍程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> T = <span class="number">0</span>; T &lt; <span class="number">10000</span>; ++T) &#123;</span><br><span class="line">        system(<span class="string">"./random &gt; ./data.in"</span>);</span><br><span class="line">        <span class="keyword">double</span> st = clock();</span><br><span class="line">        system(<span class="string">"./sol &lt; ./data.in &gt; ./data.ans"</span>);</span><br><span class="line">        <span class="keyword">double</span> et = clock();</span><br><span class="line">        system(<span class="string">"./bf &lt; ./data.in &gt; ./data.out"</span>);</span><br><span class="line">        <span class="keyword">if</span>(system(<span class="string">"diff ./data.out ./ data.ans"</span>)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Wrong Answer\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Accepted, 测试点 #%d, 用时 %.0lfms\n"</span>, T, et - st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述所有文件放在同一目录下，编译运行对拍程序就可以对拍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://book.douban.com/subject/30136932/" target="_blank" rel="noopener">《算法竞赛进阶指南》</a> 李煜东 著</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ACM指南</tag>
        <tag>对拍</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM-ICPC 比赛环境的使用</title>
    <url>/2019/10/25/ACM-ICPC-%E6%AF%94%E8%B5%9B%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ACM-ICPC 现场赛不同的赛站可能比赛环境不同，不过一般都是 Ubuntu 系统。附带的软件可能略有不同，可能会有使用习惯的差异导致效率下降或者无法运行代码，但是在终端下编译运行代码都是相同的。本篇博客介绍的是在终端下如何编辑代码、编译代码、运行代码以及调试代码。</p>
<a id="more"></a>
<h2 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h2><p>当然是 vim 神器了。vim 的学习曲线挺大的，不过掌握基本的使用还是没有问题的，可能一开始离开鼠标效率会不高，但是一旦熟悉了以后效率可能会比使用鼠标高。</p>
<p>这里介绍 vim 最基本的用法。</p>
<p>首先新建文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim test.cpp</span><br></pre></td></tr></table></figure>
<p>文件保存在当前目录下。</p>
<p>后缀名是你想要的语言：.c .cpp .java .py</p>
<p>vim 有三种模式：<strong>普通模式 (normal)</strong>、<strong>插入模式 (insert)</strong>、<strong>可视模式 (visual)</strong>。</p>
<p>一开始进入的就是<strong>普通模式</strong>，或者按下 <code>Esc</code> 键进入普通模式。普通模式就是替代其他编辑器日常使用鼠标的部分。</p>
<p>普通模式下一般输入命令，所以不能乱按键盘（基本每个键都是命令）。</p>
<p>普通模式下可以用 <code>hjkl</code> 代替方向键，分别代表左下上右 (当然还是直接用方向键最舒服)。</p>
<p>普通模式下按 <code>u</code> 可以撤销，撤销上一次对文本的更改。按 <code>x</code>  可以删除光标后的一个字符，按 <code>dd</code> 可以删除整行。</p>
<p>普通模式下输入 <code>:</code> 最下方就会输出命令框，可以输入命令。最常用的当然是保存和退出。保存是 <code>:w</code>，退出是 <code>:q</code>，强制退出是 <code>q!</code> (也就是修改后未保存直接退出))。可以叠加命令，也就是保存退出是 <code>:wq</code>。还可以增加一些配置，比如显示行号：<code>:set number</code>。但是这样配置退出 vim 后就没了。配置信息可以写在名为 .vimrc 的文件中保存下来。一般保存在 ~/ 目录下 (用户目录)，只对某个用户有效。全局配置一般在 /etc/vim/vimrc 或者 /etc/vimrc，对所有用户有效。</p>
<p>这里推荐这篇 <a href="https://fancypei.github.io/CodesACM/" target="_blank" rel="noopener">模板</a> 的 vim 配置。</p>
<p>普通模式按下 <code>i</code> 键进入<strong>插入模式</strong>，插入模式下可以正常编辑代码。</p>
<p>普通模式按下 <code>v</code> 键进入<strong>可视模式</strong>，可以批量选择代码，最常用的就是批量选择代码，然后按 <code>d</code> 删除。</p>
<h2 id="编译代码与运行代码"><a href="#编译代码与运行代码" class="headerlink" title="编译代码与运行代码"></a>编译代码与运行代码</h2><p><strong>C</strong></p>
<p>C语言直接使用 gcc 编译就行。</p>
<p>假设要编译的文件名为 test.c</p>
<p>最常用的语句就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>
<p>最后 test 为可执行程序的文件名，如果不加默认生成 a.out。</p>
<p>加个 <code>-g</code> 可以调试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test -g</span><br></pre></td></tr></table></figure>
<p>加 <code>-Wall</code> 输出所有警告信息。</p>
<p>加 <code>-O2</code> 开 O2 优化</p>
<p>gcc 其他参数挺多的，不过比赛中不常用。</p>
<p>运行的话直接 <code>./test</code> 就可以了。</p>
<p>假设同一目录下有 test.in。</p>
<p>可以使用如下命令对输入重定向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;test &lt; .&#x2F;test.in</span><br></pre></td></tr></table></figure>
<p>也可以对输出重定向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;test &gt; .&#x2F;test.out</span><br></pre></td></tr></table></figure>
<p>输出内容存入文件 test.out。</p>
<p>可以一起使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;test &lt; .&#x2F;test.in &gt; .&#x2F;test.out</span><br></pre></td></tr></table></figure>
<p>这样就不用加什么 <code>freopen</code> 之类的文件操作函数了，有时候提交时忘了删除就直接 WA 了。</p>
<p><strong>C++</strong></p>
<p>C++ 使用 g++ 编译。与 gcc 很相似。</p>
<p>假设要编译的文件名为 test.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>
<p><code>-g</code>、<code>-Wall</code>、<code>-O2</code> 参数作用与 gcc 一样。</p>
<p>运行的话与 C语言部分一样。</p>
<p><strong>Java</strong></p>
<p>假设要编译的文件为 test.java (注意主类的名字要和文件名一致)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac test.java</span><br></pre></td></tr></table></figure>
<p>在同一目录下会生成 test.class。</p>
<p>然后用以下命令运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java test</span><br></pre></td></tr></table></figure>
<p>注意不要加 .class</p>
<p><strong>Python</strong></p>
<p>Python 是解释型语言，直接运行就可以了。</p>
<p>假设要运行的文件为 test.py</p>
<p>用 Python2 运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure>
<p>用 Python3 运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 test.py</span><br></pre></td></tr></table></figure>
<p>当然目前很多赛站不支持 <code>Python</code>。</p>
<p>如果想要更方便的编译运行，可以写一些 Shell 脚本。</p>
<h2 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h2><p>这里只讲用 gdb 调试 C++ 程序。</p>
<p>前提是编译时加了 <code>-g</code> 参数。</p>
<p>假设要调试的代码为 test.cpp</p>
<p>先编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test -g</span><br></pre></td></tr></table></figure>
<p>运行一下命令进入调试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure>
<p>输入 <code>l</code> 显示主函数所在的代码部分。</p>
<p><code>l</code> 后面可以加数字，表示显示的行号。</p>
<p>也可以加函数名。</p>
<p>输入 <code>b 10</code> 在第 10 行设置断点。</p>
<p>输入 <code>delete 10</code> 删除第 10 行的断点。</p>
<p>输入 <code>r</code> 运行。</p>
<p>输入 <code>n</code> 单步跟踪。</p>
<p>输入 <code>c</code> 执行到下一个断点处。</p>
<p>输入 <code>print x</code> 输出 x 变量的值。</p>
<p>输入 <code>display x</code> 每次单步执行都输出 x 变量的值。</p>
<p>输入 <code>q</code> 退出 gdb。</p>
<p>还可以用 <code>gdb -tui</code> 进入更好看的 gdb。</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ACM指南</tag>
        <tag>vim</tag>
        <tag>gdb</tag>
        <tag>g++</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ 2460 &amp; 洛谷 P4570 [BJWC2011]元素 (线性基 贪心)</title>
    <url>/2019/09/02/BZOJ-2460-%E6%B4%9B%E8%B0%B7-P4570-BJWC2011-%E5%85%83%E7%B4%A0-%E7%BA%BF%E6%80%A7%E5%9F%BA-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>题目链接：</p>
<p><a href="https://www.luogu.org/problem/P4570" target="_blank" rel="noopener">洛谷</a></p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2460" target="_blank" rel="noopener">BZOJ</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ 个矿石，每个矿石有编号和魔力值两种属性，选择一些矿石，使得魔力值最大且编号的异或和不为 0。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>线性基 贪心</strong></p>
<p>根据矿石的魔力值从大到小排序。</p>
<p>线性基的所有异或和都不为零。因此维护一个线性基，每次插入编号 $i$，如果 $i$ 与之前的线性基都线性无关，也就是能插入，就插入并将魔力值累加到 $ans$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxbit = <span class="number">63</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">M</span> &#123;</span></span><br><span class="line">    ll number, magic;</span><br><span class="line">&#125;m[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(M a, M b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.magic &gt; b.magic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll p[maxbit];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                p[i] = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m[i].number &gt;&gt; m[i].magic;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(m, m + n, cmp);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(judge(m[i].number)) &#123;</span><br><span class="line">            ans += m[i].magic;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM 数学基础知识总结</title>
    <url>/2019/08/08/ACM-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5e4ee99df5c4298fd93c9e53c5dc5ff106c54562be8c216fa65073b7e2906544">09b6eb2ecf0bbebbfa0360fc953d3a822b23e8abed1bbbdc525fe584b050990e30614be709709306c1439d71999717a8adc8c7afa1622a91daa9beb19a8ae9b0f07b0803f005fbf5b4f986d41ce893c7e461bcb7affe83218a4d119cbaf544f12f4bf756dad0201154a4652fea711a114eeec2f4746ad50873bdc95ddc457c2ba591bb8bffac8954b8e4a5afabd242059c3198b72b6912cccde1720ff722df9c5080713ecccaae34b5ee9eb8da87fd9894587868581edce745d7977dd007ebe7a069e091efb3fea8ec3beaaef943e778925d805f5006992d612931ba7665da63dfe7d73f56164a776be3a2147990357000d1985dc40070674addd031ebdc295115883f1131f233b5c255cbdb1c14f5934aceeeb47935a4aba8bb040af2463bb94f98779ead672b5496b4c5ffe525dca447d78957ae560ac7470e05125d0689c39f31710959fa740c2fa5a2d2c052d955e77cf99605e9b87f99d40e7f816f2e22a9477e7591d385d0b7199a71e84a4de0a17b6ba6d78178f00040e7582ba3c0dbdf240e695e017d38cdfdd65c7506763b800239c9def48cbdbd09ee383298c8d1cbef8d9445a38b9f73dd5eb8fff413494ef9c19f0a4fcf72c655cf9ab8f157338ab6cf772fa975f602617126f179c899839b7717e4c12985c366aac5fd12226d1b5c05ebef94b93e3717116afd11b83e93658c900db90ef61343e8028cba1054f2a980256f324743ee2aeb74241d1e26c0bd0b2ba5d51928a6b619914831c567ca466bebd5719ecc23a758e9faf534b8144f48cd65edd2ccc8d3855c6602d8739875c930a2f280812609391fd6e7203ff8358dfb4b1588482e460f2df126720d5344e8c60bbe38e3905173d997425516b5a7de563e0ce51faeb0e2cd618edf8af59dc49d8119570a7a4ea8dab7894c6e2ba81e1055920551eb9f1185cddc1d9a55426cdc9c9f3620b8ba1afe9cbfd8cef1d8516024d01497f27ff6916dd9f8c7a1b0271cd71777073580f4fd519b7f3a75e4d94f901811e02cbab8cb5f74a3a785576e630d8431a5b38f79f3848f996df31971238b9de41ad43ec0a6650b40081a3e5a495a0e5b0e670ce94631aafa364f1cda34daa9665e49d5b5f0bc5a7803c5e3374f6cffb0a7f68a0369b354e8069384480369c8b21487d5c6cb490abaf75f31010b75e2d06dbbfeb780a40d6318f28658ccc32e5c1ea408f84d7b80137dac876785f7308928c9d97c9180cbaa0df2fd410d78ac110c15042688ee488bd1212a00d10824e21e19aeab636a0c152690e5cb40d80f15f0840c0551b8be8c452f79b9e0af883e5c580bf82a3df0507cfc9b5f73e0b3597cb2395db8564d06e82ad66138fa9117c8c80b80bdb5f6123e5e222db9adc1275bda381a6f1a227599ab00082644c61bc26a6fb243cd4b816a5da029142a59aa197adc10568f33f09abc5fef60f2727cdee9bf0b4000c2d498faf17c5228916c913b2f5e06fca124a45483f6ae4d6afae78bcfc6c7350921ef599c94da68d502a03de9541ef32636221e64101da2a79623f3c6e4e3a074d0aec7922a614fb378447c9a073209bcc04ad1fd6808698c522e3fb1eddfad99657800a060fea1d557dc11c9dc5c0f0881a3e4b910d9458d0e06b471a234f3d8046651b38ba5eb06a89b6aa0863b5fd249457fb3229c0e5881ca47d7afd122480098aeb274d3dba6550cd37947170ea4fb1e884cde637d8c298d001cd225321bd7f9ce9dd60bc1ef8cd9643c48f2f1d39dbcb41653f5ef062ec3fde842ad31a8ebc84ef5d5378ab079b7787301d82668574346a21b8aa203195f8da7c018646abb175f5d76f5eb0b72c0bd0f58a2379cd98d7c1ef5549282e8eb4a61057ee052f3e9b47d2c59e0f98992e2ccbc1c00d2f42b7b72363a027b28586591787c12591ca0ad080273204efa80aedbc795441f96c605b046e41ed54037053c9d29c8fcfd586356a706f8c4fba16db4315499494fee5f0aa4222f1a79356b4d5fa59614154afe9d9951074ed9f82addcbadc32b1f218094887879f79389537e8e7f31f917b4033300e9b06e81d2fd24c4770e3c39a28b8a942bad87ba48303a117c6ab5f10416070cbcb7efc3cf76746ba548361e2a0dbb074d87520525060f01f7daa8abce2bf964a30a37f047294c921453aaad7ae6550b20d9337b40a20a6fa672e7ef42cdddfb5d05f37fc728b8106cae074010a3176bc87896877be937456d030223679362e4792958b121e5017edf567bc24de16d6057917a123f30a2f0468eb685b7ef6e43a5faf99ae5287e046ee7aa7c5a408a327c9eaddedd3ccdf602ce872fdbff96aaca4a69fce0fa1c5ac7df5dee33599a741894162b253c224194a8478fa901086757beea534228bd3196ba301d6a504f1150393ba6047a25ab582dd5e348c4169095a51c6319d904ca56d24861b369e81f2924d015a56c6c170977f8d1b44a6f1d3489bd78ca1156de0ef03e0a516e63c326787d25150926d01b9475e08e96d1b57b4a5f091886c74ec6abcf5ffd9ff9cf5747997dcb884af63ca4fd5ecb010472aadcf424bfddca8c1399a7bddbb1662878848503c75d48eec40c27223e38048e61ec04e043efd7db65e67139c46e9dede2581fc74da5ba23ef0f45215b933a59be85a7c7e45f0184fb83236396f325ba93eb4a077d9f2eea294c400d39aa58c5644122310a7f37a2873d4688e574c4bcbe677cd3438bc6eae859c7460d7d36b0485ce738dd73798f18842599ff1d24428cf7a44414c80a2268a89932e365c1926e206a8e8d126e254c9315b231a1272ebabccdc95bfb776853cdd24251cf462e4469ea8d0117fd4b9de360ed0b07e8d5b28522cbd83c6a521d1005add9c2772acf99192dd1f482975b460d91069fbe8fd9a3709abf46d687e1066380148e4f384ff8f6d8a5bab4eeaf108844fa1305bf90ecf941340e989bee3b22d8db10b5d5f78f312ce4d6458dde5cd941f5631386c918472e04605ee462d6fcc15d84490f6c7c9837f5e43fdbb3d020df937ef78aeed199de823f820a303b5bdc4020be1cbd1809976e21d031df12617a9af90686f5b863f11d573c0e8bd0d6e2f401e7ce6c2b7be286449b1a7fef33a0c7d52b1cd77606b9b57c4b13c464f920d35a3a047bcedb7843f1733756e15a5594a5801bff4cfd984c30b38a7ac82f303ddb44fbffa82d1f890fd050ad4a326fa9011a48c08d1852cedb7ec25a411be2cba0305a91cdba730d8972379805df261d0f9db9c167c9cb802d04803a2f0ed3a0266aa3016469422a704852549a97bd5be600935e092072476a8e5392611bf8598bd1d30014b4fbd14603567e39ecdec67d2d7fccb12d74e6e53f432564b0225ead1f4e99b0bbca7850f59a2b985495082902cf6d05e6f7b0dadd9f10bce3f774c7b66f924b3e6577fd5bd8bf13bc82b7fffb2092887fb5e7f74cfc4dae4694fd8c47c6e9aff3adbed830d553b50f8291c20583dc7105a5a0fec66a1926442950d84876e82555b7b540b296f11082d96d94a6a36f066bbecf33ceb46041abe2cbc4f83dd35021275c17ab5d1287d72f7b39fc0a47d39fcba6913077613bd73bb88f4bd1d8b462e8b249d3ce9588c43f2aed18069ba4db0f4518ddd84911235e22fa1867daee7e3fd85922f2764ccdb2214d2ad6412deeab8294a293e4992225ade8e79885139eed159ba22af2c22fbe593d7e2a92ef523f9bcb653a1b59ce2895c53b4c7a888a64a3e2965e39248118df98dec03dd2b0aaf2a8b31bb3c011eea340ac3b6d289c1036bb0f1faf4f0a8184ed1e2cd6e26abf0c5ed7a4b79ac3db0095dc3d336ed875463ce246df73b136c1ff360c75545724ff751dab3f000aa90a8da9be1b7e690ab0b83d71583723cf444186ab9e1376ec59bddcbf8c7dc75cf652c0f0c24f70aac1ece348f768669bc72de10308fa6e51d1ea00715785c3bd9345e8a4d13fca3fed9739d3a987b1cf106e8018c5aac32665b4edc7541e8e91d2f666c9d2e127e8dd4831b586940a8a78d157af09b8c256b7684b63b3569b5808d9520036bfc46666cbdbab5d4ed14c0901891111c0a2e5da90cb835dddf896adeb06666bbc08b1016988c393eadabe65de1d6b8c209152ac162f9d5a197e80878c7200fe3f2fa76b275d6015410397de5ae9ed3e74aaa03e60477d882547da748ceee6fd2ca3dc67896710ac159c1405edf6c7e8dd64f94808e3174df98a39d0ae887ed0713ccd15b2c5c4194e84c115eb17faecd1ac24d02842083b543e3a688d5b8c9e6b0ab7c283167d15c743614b16b2a1c1ffe4521d36532f8be0672315595086efeb72d9ac17abe0921d10b264f270a5baab405efd2f0c80ac1bf2930d5a426cc5a72b7789d28337f9264df0e8486a712899c3414deaeadabec7d30954221a04a9385a96b958f6497dea99a05aa147e56a6650ff43c409e0d1eb402e16e8b537ef136abbb33600ba409585c5496e582fcac2dd0fa51f592ffb1f188ade4c977ee49f0fbf9ef8a6752c00889d987c311ae7500845258dc9b545afbde0ba445651d839eb5d4a3fa0e68fc680fe888e7bc6a9fd531f03c0dffd9c36cfd5a9ab027290246ff3ab69fccda588c0aeb2d2fa864e00813b5304ffec74c4859ab6d4689d3b5aaaa6cff5d2034612f622169f1352b3ad380395ec241aca05b49967ad0b1ed192d81ba946820e97b5c8ce099ac6981c634f102d5e4e80bd84dc90b7dbc53419c6c181af8e272910cf0a8f1fa449e2b9488afaab8488fb6e3184915610820cb2d4e1f77be9381b724ad0a4064018e02a71205ce7068cb9a8df91b68bd885687f7d0374f4e287af1505432dd71a6a18d9e0adc222325c300c085d4f54cab0e40391cbe74c1ec35524ca9b685e1c987d14488378c74f8b22803f34203057608146cecd2dd328c26067461e7ff60f4153152c5a2a56c2365ac241e995c8adb05d79be038dae874b13b7c9e17085a835b60771592122775b4a7dd9c7c89f3fdf595a76ffbc277bc5ec768a83090c73e7fbbe43f6424cf786096d0d4ec69eb9fca0069b1f00d18da9b3e09b01deb4b16de670e39416610d0fb278ad12bfe45b5b25dc85313a7ea42d15eb767ee2b75feb9dfe7822297c6238dfee16ca2374579623b620efe7153496f3f9b3f4e4d5c715a94a514abc601a675c2c7a93f2b8bc2e4d5c6b6279100f04104dc242b8d89b137d5d6e7aaa4e7627aea9dab2ff2abec6478b769318fb0b16eac65245082947e767beb5d4c8202fe474e8ba477f2dc98e93fd02e1360853c1593e4e8ec127b5ad876a16d75fe450c41e104d60a76802b5531834e0174b459bdb79abc2c5fb0327eca0a83bd80b8e6c00e4bfc9aaafdda135f566e4604cf4d5cebd98e97735a3e2a504ed4f02d7af75b59bdf47eb1044993326472cd72ac09b7ab805d561f064dc4b01e86faf630e32c4b059112b5923a287c4c6105b3dd7856b0a64ff13c3de6d373d6099f7c7e09b2b52a14e9877261101debeda9d7b93716b559532151d695faa8dce6f953086166e75ef97947ee84054393de3a15dcc01d52478a91f524581a100fec9ddd573141111fc65f63436de6747163cd4aeea07f86d08b6d938199faea5c9b97c0dae58c19ae58033c7cc29f8f199733572dbf73b6674ba94c8d479f74d6395344e33c508157f39936da4d1183c53b8378b9543cb28418af747e2218d55efcaf4eaa97e958fd5f6b183d58c3c95cae3a0a0c302ca7375a9f3117ae7e6d617b7719b5af6ccba1c235da32b1296beb172cb6ff10d4d77cb6edf160a2b145a88075cbae518ec26d4b0a71270b98ed06a2b01727cb45e675b89b09dbb53e4ee4e3ddfe713a19d6d9ae4c77799fc79b828ca8be8fbf690b48ef6fb58715d2450ed54b00abdfed95c47c07807b499bb7b9d0bc843b16f141637f5cca28fcd8ac7520063c6370d9f6695db9e649aa769bb8a62347fa926d82ae17738cbc46592c56d8f3cce288835a7eab2a6cf552009ddf527a5bcc4eaf34f2e2d4a6fc1fb71070401b663ea422b8bf501fff454969aed835ebf01e406389e718c94de4e7da75e8eda4d8d647b3e567fd8fbd5a99431a58ac3fd718ec9872ad1e83658e8fc0bfaeec48916609d00c76bd2507f487c952da84e13fcee53fcabc45642c34ccb2008b62e1aae82653d4a7ab4a3d79b49465c6cdb51ae5c12e44f789c06c747f71a972a6d34dbda38df905ca91a72d9110933cf7b4177ebc2049cc3812a2db4f0f96fe8f3c1d630d983a8b7b7b6045e614b91f39750bded1b749491bbb4ab055d9a38bfee3290370fe8153d84ba39f41ab4505849d1c84c0891d010f3259bfe1a70fb522dee5bb06e4affd2874b7b19c7820fdd140616a57143dc9ee293c6458f798c4806ae229a619d7a988bbfff83dea06d2043f3943d84f350d29a45ed6ba803baf3cb3868720740de813f2e4b358e09980849fc326286a5718c52b4937bbacd204fd851af1b20b06e031e4c24146ea2df4f17370349bc5589af4a1921bc17701c10757cd6210928b627d25e6048368725afa6833167bc40eec7d7d5d5ab17aba6d15fbc0353299ae17e246b4c9e395dfe6321b35b86a90b26a89167d707066fd578931c7b35f14f5b3be42ca58de7cd9151cbfe088ddd77dfc4ecb494465c8493009b73d4e3f6706b125a1fefa95c5919c50e6df0d0ee8c677f10bbeef72f8a957f603a6fc220ade7ddf32e3a7c8dc36c92917c31a4cb6e64cc25e7d8dee757d0bce152c5afa5c368e79896c13fc7be63259a5527312484dce3026eb4b0992d296faf2176aec455393620d2806b52bb7bfc87fdea8784af45e954bdabfdcdfe8f89d3e070e3c5a4cd0d86cfd64434b2839a0171b7883be2e3d620ca4ad0d1f82d9b9004596691eb4665ce5ea6ec48795b45de79cb802955e1917b736c07267028d6293622ab76092d4b64949e2da4332eb767eadcfedfb4ccb32f862229e247311578ce700b547586f1d17c0b5559841b3d1141d76522d32a9ffe3ddcd7bf8bae8db1ff2c0c21574712e6ce7436e1f1650183f0d720132e157b16b9ea53d2a16f9c5a6fb95103caac1ead5bd60697a5d1e2f65a0d88f1e18bf2a9c5bae1b239546a664faea64ea7d96a28e95551d3aec294790668d8f4eb17b333dacdc1b3af6986a53519422ec92958800e7cc9cfe9f9f82ee606a4df4a570947bcb31dea225948913984c3ccb247e7bcb3ee3265b5240e048d7e98b3b9e66a6e6dcb38308fc9438a93ca9a2ca2764e3e7f233addfefac5e269e346fd9926ce83b33eb2aa13868c43f27b71107366dc284d1cbda57d2c2d20cddd23e5b868c4bfa99bf2ba3f044459c5615c59ec21b64a1873dcaf0d41440d6729cded39847c8faddaf272192e35a6918e647114299dfc04dfeba43dc684b4085cb0a64d606e5bed007506ce77d865d8bcb37dbc61527707eda9fa1bf4ea96df3ed727b721caef7c85122b0c81cf679a6a1144d997dcf98018fb4a4fb816c235231b22e7c3e1271ef8ff6c55e3bc80b11147e6825f110359bbc0e21fd76e7f8221702c370200e54ac0b90f6844dd68e0b286defb5fd6d52a8a911a0003c3cb03f6119ad6f0e1070b71f2f44a26feaca660fd7b86d27328db886eb9539020254f060e4f5f2fad188f66026d493ead6d8e2ca1eab32d68af5c763ca89c73e73a9391ee397db9e67332417872b53fb74d1ed84af76f12e0a4c86c12ef511e97465e37c85c5ede79df1e26fc8893cc6d61cfb759d9dd7c60a0e04d6da93bb319dd7b6ecc9d92e533ecfc1f46be0630d132f1700d52f8d0328bd7a08ac1643e79f0dbbf9388808d7ba52c427d073cc8c9f1abefa5dd49c861648ed2b05373b9cd918d4a0ccb207b9a337df62efa2c69ce0ed296db8491d2ddcc01618e4915b952893c24b8f1d573ce72066ee97fb8608ce1aacb5614bc99ac528d826b0364d4d7a22397833cdb8bf83e2f20213c11cc7f017c16dd002e6632c8954e16f67b41761b7652507545604b4a2345ece9ad18c7f740e32cbcc4c11a23f38881ef147dd543a300f39f5a38ec4d3165da08886b9ef28bee6fa32e5a3e43d448f35fce436ce5802cbe2830c1d6b29dbcbfc22473d5fe77afaa77cd6d7652b5709165cb14b2cf866822a1f1fd1f4422b373603910a2b7ab9fa3fa8fdd9a2fd005acc8ef9a4b061b159e5e49effe3ce5a7e35b60688caf73c45b1a38b3ebb7dda6cbd3e7a24c9cc5779545b0515afd291ac5c62c12171bccc3498e137f6706fc434d55f889b7d39071eaa76b1286d3b632ae05fa5d863b5d1d0d0a0319cc49147671fbeaee97dedfc7159461d592026adf80fe0057b9f8a12a967311d2fe303bdf5d1a5ab7b241dcaaa04369f7b0cfce06bfa045ddd4ddd12275e46eb6ec77ac6ff12ea015e1f975e95a9e8cf082e4fda8138243fe458579c78dac8ace1090e78bcf0ca6a82212bf470a50b16ac5fa45a872f625ed3b3e9005235d36f307b706efc9e023f5b17175a9577913a98ddd49f1c4a95993438fadd859aae2ef2f1b1ee923eb53520261d5d227bc80cff971ac4fc8decb8de7c952dbf4a87e777a7e293b5ccfaf575f91a39aff8bd507a523e3b6c616b9b10a6c3ad17b27c1f9e4bf2de27ca78956ecf501fd241463dabc6514913ef9307e352f1450351793f3679106e104a08b07e6cad6663f36184d98dcdd7cbc24e2a589c0d4afef7dfba5412941bfa3b823b36c173ae47915f12a7aedd06a46a73122e8732082e82da4bf988f35af1d5fc523a9c788adc67abbd5d68a0ae632ad03f7cff69169b92975a99f446642712f647d7170c726e388dc98f9606391e69d4f6450886a59cf48026104d5bd87f929a1c5a3bdd498b15f404bcaa7b8a61afa658c49153e8eec2888cc2612c4666005e921dcefaa2815b8a607c5bfa7759df6772a7e41892c911d1e26e1c37935be7b179aadc77695ea137f59d35a815802931a785c738336c65d9b140d8cb6eac4606ae3c3e1136e588b1e4b87ef4db87e161d4b939d5c618356fc0d0455d3b9d6b1416cdc61ff1060728869225a0ef13c8a3dd1cd270c7529f2fb5fbe7411a6f6f016f483c4aac9a46cf27b0990b0506584d9ab2c22bf38242e8273f4fbf828ede37abc69b70f015049f40fc974f66fa918c143afb2c5e72b99549c14ac2f3be8811740f38a9d40d803235a0e319d46efb6f9d1c2679bbdc4536793f91c01eadc1376f34b64420e28915b0044225ddb1d4a582a1a7e573f64123ff8fade65eea9401822e48a3361c0847a90dc10ac6a48891afb29a6374146358b2ae7c7b0109ed2b832e90a9661ce7f17ebf077d4fe4083bfe51994d22b692a783bad57eac5ddf0e5ec8f52126216279a47c30b380df3131d680f3194c36fa7596c1c726e1f74f038d4451e976a73e6b75596db4d4b0e0f244f9c4da1a0f380d25bbef82f4d316c96aa31250591800d953296a409e697f3fc744973727152692fd53879445826a3d176fcb58b51ed89362ec9be8e1dde4f13f6af862f3293e3c6bb45f393933dbbb43b5a6bba4468f11818562dda046077648f8027e03ae91b192620d030e36459016ef828e57f9735175457d22c5e9f379c541fb757dc3f1a9ac722b2cf1b760007e1529fe3597bd5279c06057edc5d2f39e1b7b6e31dc8ecf32486237e2b47d09b34abcafb0e2cfb5bc28e57130b4cab90566d0c5ae1e2b495bfa448d937d14ac9fcae3eb6b20491fdfb795569a36e00d000641e0bd3f6b324618e874f3f1a0c12566ca2e887270b447d22f1577f9bfebb73b59f5225f5d92dd52d7776b13b99308717961873e6189311461c0888013c3252939bc0a1cbbcb462dc54ef20cadc5073603fcdf6abaf81127f00e04a65f70145f99ac615bcf15a3cd5c1af1439fa1b286c18f0103c2836f83aefea4e692b6e6bcdd3f90634c073a2958c5fb4b9baa1862361069f3cb0c3059dd1cf0078a86f8edfaa5437836034cfc81e901ec724b12e8f5182746ed220763cdfa423688ce1e7df5c3d4ff2c87bf00e5b53a0a2cfa1a71f07f3e11823a2ccbb5c63062bf813cf86b1b77e18e890ab59a752508e435c98852edaaa5290fc8b240759c329432e23e95bda0761387328b52174cf5f694130b5ca5ab56242e100311967af86ef114001262598c14be230e23c275aa946099081b092931d7159a75ec58cfbbca559081d73adf3ae22cfdab04c9d85cdd72f20f3f184e4b6d504c023989a2c6dffacb9eca2d9f5ea32248ae10ba0e1180ec4fa9e8cb1d5ae9194fac32f5d151846383ded2695016ac63a083a0fe3d440f095c88e406b7af0eff138e7db059d294f064ce8e83c01ada7b52a935b854ca5350b4cc299e61c7626401684d7ed1a3a5a67e886c4dee40f494bd33e4af7cb37b32c260fb4e11655f6875aadf7e80a18a4b8f74d0a98045914aad15b009c7333ccc73e4d225b00c62c40d94ff85aace85d4835cebbf209e80c0782d2f570e5831dc2f9f59fda1d1cbe9f7b0a734226cb9d8bbd44a6aa67043a4a71c7816909ebc7071cb6e4e49e4c25ba54e67f91546e0579590758cc87d93bb668bed7c115ac04d84fde7bc7a231834ca1826d1c9668be288169c45afa86b38ead3dab527485b006eb4675ec7324d8ca9be6d22ce70a70777a5027e6bb02c9d040c4ec5b4c3de0c17b4a25d2cbac39e95ec89741fef11fcad416027d7ff5467508d0ef923f4f88365500a8fe154a3fc5d7c16df9ca451d94823afe494ef4b632e7d690115466daeaa624dd7b26e0e4018bb4bdb93033c4592689e4224c6586ef5658cd297a29e05308e7b1aeb3ee95ca374f151b10631191a77b219bb67c62410b4513ea641c88e73b0d7144e98d69c6bd34c052790174354d965c3cd9c4966ffcde52c67c3bc9a018fb9c53d19aaab36ac6bad248102fb37f6a9ccb623170f0bed362f26c2c68977bb58d2cbf32d695a7dd39d8cedae634ae7daf51c3f2553cc64acab1ce55d59652052eb7a1b547edf51932bbeb6fa9e76e0c911af8d6403d4a469610bf1fb3d45b1ad7d5fa2e52904ba5481aaaa6a328397ae14a123d822c76940a3c7b7721106270ceed7478ff4c9e6e50b45e0f589e226797f3807fe8e562a075ee8b52ff93eefa95175355d1539f8426e12f2ca1e4d9bcd5d4db31ab4d22fa792d44ad4560dd751c3b7ecd5585c32390c9b68e40b8e60a2a5d5a08aeb68a3002ff4d6e4351fb5715f05e26b22902b1803793d916b8a3342cf22d675c2b7d4b0447b3326586c6bd7e55b67247424ae4471b9ecd5ac4717503e6aff1b6d1f53ae04fa675f32434e4fe83628442d0f04a9f47b7de85c5fea1719a4cd5b2c04b623784c4f62299412e34b6d7235686c025dd8108f65b8217d4603fb623fb540cdb3f37c3b4c83ee630ae229fd890aca32ce1bf01774998b016f014587b0b3ceaa8d8211e0e7018be78d8bd3482778350187d0b76442af3b0a70310689abfc108e9b804783ceb4dd25fdb3c3044b517e10fe2f90a287b5a2e592ac9ecd282cd125f38b112cf62882b73b2f4c81161e4a0bb9aa7c603545406a9870daf1ee6c29a81fc69500215454d7c5f82b692f1b4f23d4d7669ecc57803d8f2de4adadfcb4fd20d77e2875ad39323e74d5d65c21f2cee405732502cbdcdcdcb59279f863d8eb2d4a48fae3f0abe31bb916726c8e30a77531cd52adcd520c8aed00314ad50e3c268ebe540384d1572bf999d49e669703c2c0df54537761474017f0613f9aea00b2425c0d26c9adbec86ffcd5a26155dd7c4deb73dfdb15c7ba276b4f45678965fd6bf1e0f135ba75265c2bd40fc3b7518da50f13087ac1bc0508a103ab1b292698bbe7d354073e8048ad67503449c8cf3a17764dac38aef124854acfeb1bd2e186eda6ad952c1054950058ddf40bac07271098d8260eb903dff257718a4ad7e99da7c0d4d1536dfc8e674f91692bfd4ac1ccf2f880801b1ade8ef8aa26868d81ca2ddfe9aad4064cf534f1074250cde3cd01b30e7c358179983f2477d28aab4366c78aac41cbcfca8af96cbd918500709c34f4a57188a7fc191dca021732dc4e4e512f1cbbacac657746f390d6a757e13b549e8f288e558b70b227ed4fdd7a96c2abed01c8bb687559be32dd72b8561055c6e3e556dea699b48794b42bfeb30600fefbd5074d08ba8b4f2d93b2500f2b13f2520df4f7aab5e501ea9ad6de42aeb460dc9e3e80013fa704c706f81ceee6736121d7ba577e6bc69e1b7002dae8b715d0d53daedfdafaadb9bf0d755510b34cc0c922c85ccfc705b3ff587e0fcf26e98d3731838206b3d073b9be720f885e6a10ad040426857ec58251be15733d6f22cb7932f1ad58082123070545fe21094bf4afb8261f8a673c2a1aa3f9410fd7b6ee71e1fbac7f56c6b0321480b3cebcb1eecec69eaaf4f4e9326ae513d3b345a9b524a941cf611610c1799d47aea09af1b001e8795e864509e6afa0d6f6d9a22ac77486a76a4326bab7c36d0441ecef0121abdeb49f976ad263b2a6c21ad71e2a187d9e24de018a9aec3531d6ac4e6100dbc9ac2b68861198a2989d9a7f70f9ab6968d63a4d9bc087e80d4e3a570055e09b753b1390e2564d72937f7be82a60b163e1f1ef0d538b32038e9232cc429b04df11fa07a610c8ac84f2291f4255c530d58bbd94368182cef8e54a929d3545f0f2488fee10f40715c9bed4b4f21b3e1515acdf133d3260106025f108410cc0710a3f12294a8c65b5c7d740f59fc5226bca69a165cdc2ad26740bc5656752c8d86a85e441ec84f46517536c93d52f91c0ada7720abfc6bf01a7795ccaca80984cce8c7011334c3eb86ba47b8908ff2159d7bc2c8dad3fb60b5ddae15b4ea47d3a6a6944beba2bce2cc4879af704a43e63279b9b830c321c5f97eae08c5b5e784f9406aa5d67d7266c8b5f5814ec60968723cfe92e85b2e20e3aedf97b7aa2f5eccaeaf84d239d8798890c79b866acaaa61d7ca04af080609f2cddc39d7d5a222d3c7ae1257a10166f9092d6119c3982983c7af0aaa7744024e1882d5290f9705ab3923b71cf50ab8cbf93dbe03a50ce103d37b3279a0eca46ca3cc2b3d310b236b87dbd027a21a3beda18d2785364d633128afab3778c07852a556dc0da8b30d6499565c9b94b255a6281ed8a4d762e77dce3c7d4cf20781524813c9ad6677b60cd81aff54ee76628201192c9157060a5155f44c6c62edbd7b3e9b818c3eea55f80e3bb174be43e9807ab05e8d5080e45ac253f89affabc654e049e5dd3d8776b8d27dd9e7e67bda941ac2578b766bef847f762767b4707a466452d422d2c56e7f8484ff8cd90bf68dc27671aa6ad8855ff43b4502d06ca603eb1d09ec1dbbe38b9129efa8768484235c234801d63413ee30ffbb35900866b25237cdfdd7efe3deb5fa98f1a440743052085fdaaec777588cf8e6a30f930db878698b0d161869851f1d8b2d8dcf6d425ab50a296e7550fbda9db4c33c773dbe9223ea055b89850eb5b2b2129882a5b80dee3c9731805f8a70a844d4ad75824bf215965100e4090516b1b517ff4f1bbeac717f75669f63dd22e3d3fa1aedbe2ea9840aaa2785fa1d0294d527547a76775ba9b13332c9a4f9eba1b87b83930248e37ae8d7e9f786984c977c4e77f40e3f49b97c15812bac228a6149c7d5609751ab55c5ac415f0d09ff12c73ed01b7ebb4f2a22546ecd27bed2db76dcf3e8a1b4fed1715a053d6344784591f5066ca7c5325252fd7224e2adef5f9b985964ad2fbb460513567b7a527cd13ab7a9395f89b7b20e3bb8db426f0b1be91b77702be2d6d55797a61058b53e5730d489892e57c5bac48ff60c654b33df77de5e8218454b19eabd9352f955df184137f930cf3d2262f8658110773a9c18ba2fd78d004ef1fe41f8b732817a9e44d12f1a20a24a49d936e7cc4578ac75a3a2d1d71e8136e22c53f85dbd076973142eb838e84909bdbed746b6ee1d8dbde851907c4d4d1da310fd9c95a0069087a983bccdd9fb13d9801ba9961dc5c2e51c79a64fbf21e47ede7ef3c48c2260b1377ddd48a85bd2f89af44e2c70908e5f83d8d9347620334ff09e0c98d35fb7c81940d218a15995f9f219d975501778d9eba06209c36c55fa2c42abc42bdcfe19b5725fdcd4e72667bc6393de0dd5d47d67e54b7ecdebd7d990edd30d738814817958df5224a521bef57643d9144119510bd898ae58ffdeb23f52cf6def3fdf6dc2a596c6bd4276b045231b9c72899663a220e97d8ff8147fb0c28663f81587f7e4b3e2f5eb9b86ef6c4b75a1d46f0fc5d2299e0cf9dbb5c7dd017bbc3784307ce6a0d951ef638114172ada02712d4a4f77fab70b01fc8051534318964ef447e3fb3bc1c2412caba1d79b248031fa2251adc77f99fb26f2e7045e0a6f10394a367f88530c205bd0c4be0a91dba72d71b654efc02c795e4645eceeda8917b21ad0d05ebffe53d7b2badd8fd122398989db9e8ee5a0fcd16715b0e10165fc37fc7d7822b90f283b1b9bed69c4d7d899b9ca4aec314992a4f3a3461e626707605073b2e24cc27ae2e917a1879b971377b85740899c8a876771b70d27d5319746ab6313aa1b4367e251d7bfefc3aad2c6ca795ad0fbc05399a018363bc53dd631ec180d51edbd13857d1e3931a83a0b90887083858275a94fdcf03cd80a1985f3ac796a9826b40a2f6e34f2eb2d850e771f793bb7b10f14e6bb02eca101e01bb0d7b898a075c92eb512f3522fb169123ec39d0aaebae0079f4efa61c89ca6b72c8333b9a7578af1f6de2cfc088252f34efe8f8ad8f77149668ffb35468ead9e5e4ae49b4762ff775c0ebd8a993ce68636048ac352fbf5a342f9ae0e49f1c8ffd5bbee91975b75b6f9d470d47ae4124df4b1d95709ae06ded60fb33d191501eef74c1ed9f37f1afb36d3fb941b928280e625dc8d0f211c546f167c3f951eb330027744ef9b91fe7003719ad8d784df3c856b476de88194a6197adac9185a1640ca2806ea920285d934a28eaa94fc0c318fdb989713d69be90c608094dc7f86e866e283294cdb47c7999b4d622e14a1eec560f72977b12ada9fd33eacdd91489d93cf24db9b3f12fa81fa6ca9b676e1d90017c522833428caf0799a35d1b218548cf1ae454a1c203323b6e98e19e29c0ad1a93157819d4eea5d7ece932b06fd1de543c469434cbbc90034ab38283b9df69ae23e988ea391f3a92bd6ff9c8033fa00eed771c368dd4e35a250828b1010054e6aa8bfdf1b60cf952506ccdabae886bf5d72962fc86f14c82fa2969ff2c6aa2b3477cbd5b62b9cec2326d1fa808def9790e63f870b3dc285a044447c102d441b828c6986eb8524c8918d3cae5cd1b36e6dc2ce4f03fb08ad430a3925e799442fa43bd94014a4f17bf117e2cde70793f3bb63f75a942ab5d6c09016ea98903ef50f447edcf829c6ed2d103d159296e16ee49dbaa7fe0ed4687949a700d423c75563505b6e303f15715117adbb1fd9738f26aeee21832300c7fd659a91011a6d12e9951042c3ee1fec714ebde47c49b36a2c18d84fc0efc24525d8b567583e9176f7c8a0e262d9838455111377d3f440f3bf379d378e5050b81a79ca34072d565e10e5c38c901590c99c3b153db02fb2030505e83675c39185d0e376b611fec62bc8189a0f9e54fb40762df767acfec2b050819f070f79a0ec801c8b9dd01fd6fc3a350915c251268d513a8c8030c29e0dada4fdb06970abec0b7eb1e35049673a00f892bd132cfc8d40edb1285d98c8c9d192bba79256f6ef7b051c63d72c3cca6c259b074e1a891fdf482af52d800b211fd494a77c6079265c54ecec863d3b7cb033ae031e92fdd6c1dea6a8e23d81d4fae5d100a51906b3ad1b94486bea761472f1e00f66ceeeb8885ea5c69a14c7d352e2ed939eeb1e2eaaab3df6596381f650c035840c0cd6c4ec07fcaa2377c5340d647cf4d4ebc67de64b50087ab9e4029253a27c3c898c22119fc3f068c1639e84b6732904ebd38cd14b5a8290a9043a3880eef9a8a80db347218d53ab7ded0c0a8c1702d860aee69f544b999e5d28251c1fa5f4de354c3cadd4cded124df4d2b514783b3fdeb4dfc0bc26bdf9418425d4d9c9b34c468f3b5929a16e9700047094c9a37c092579e5ade695608e219047b1bd136b49241310bf5763d4cafe974944295bf6c83b16e848757c38a82cd4262e965ef99cd7cc970e464d5505b1e399b28e6b05b35b18c63c2f8c6a3824c61391e0f937b6e845b76980241e65fd2e871c380efbe5fb26a35dbce2f4f7185953ceaa61c248945756ccf483e8a0d83c25db8603455ad3bc77111acdb4f2259a266ad4f9cb106c38336d7ec74e35e66c2b51cb41892a77565943f40a61f4a353dc8737ab36f0b2bad4d037de9012072836d33145f79fce73facdb93d870bd86b1eea2528c38827dd3f6daa040d2a1b36e73e91d9aae93b8a0d9e2ee7665894bfcf3bc791f34dc1f917161e50d43be4df480a05e8b686fedaea5d4d5b6cd0e2ca0649afde35e57d626a1208353b80a94a4af9aa4cf0933e12c3465c6d915dddf7b561c9bfdc72d0a43e2668a9b17ae1719a2dbf0eb4700b72ffeeae63b53dc06bd8751b0cf64854c7d3eedacb0a55f4dd55be289d394d80b7f8695219dd50ad215d5e2a2477e8d3c557d10c2c4435a4e603fcc5b7d38bbcba984f00df0a56f6f300c815baf3c172aa57c4cc747f719edad1252feeb53416de93de0ab06c181d791bb52085b28d7e799e269c97398e248c85ef6d1338a58d89628791c2b0e4451113c1697dae5e1d1c6a58de1210e3a17a61dd6780bbc421c65c6fcd1770c54885437da1482e30c9ef42b434c1cbe7a68080ffe4506cc1307d87fcd440a3848b0c869a31a16271e347c85c11bf8ee23e91d6b8a9595b92bbee403032dead91e4de278cbc8162c3ae1e26a1908af3ba6b9e61c881e9f50d2ed815559fb97eb082660b69276bceb77c0384d78cbf8b1a0ee55541c29b74eff850c6f6a912ed3b44c2ceed11f700b07793ddc2adce693cb26758d6d2f66faccbc4ff8dfb7e412b826e12596b9df63d07aef62e4743fa90a39418e85e4c7c5e776bce0c872cc9e095d1408b3524d91f1e0c7a653710e6c0e46b782cbac1108a1546b7d94e9f64c0f7900a61ba3a69af40b939e18847d0e37fcf4d2cc3839084a76a540baa5ae0c5ef02ce4d17b9381718ddf5cd7c050ad188e6b55ecd6ae8b523760ad8970952cc544f48477935ae5adb69e68544f259dd86c5e17662d5f415430248be1f42e725641ecf19c071dbd711a23e0ead2570f589999a4fccfb1d7f955b776199defc4bebfef69cdf554d1ffbf84c46e67a33d6b12228936e36d43baa2769823e60b3fc11a32b88477461cf13cb2470fa31c3a86f0ad7b78a85fb7e792c1af69b3c13e3b28ca56d7a1019941200811e50a8ba962eb311757378f06faedfb5bae647aaf65107b6ec7e3634b7a23c791dfb431abf9ae0f090a7103a4422379b41c31569422353e7760ed76e617a5c43549b148be431423809d7f89077cf2586d8e76e193fa4b5609c6237cc145fb09fd006ba14ccc045eb5ff9e895a147af537968c63b5e4f0d421041d7e9a5ae03656d7597939b5b0c4f6398a6888ac3ab82f7bb527803528b9fbffc0efece7073cb1b9d8ddd4b35aae75e628dc23a16ae4fcdd033b73c7f0042c3f4dba2b62114533a48658f1676e452cccab01c9fdae4cf08552e8a91b84b51281bdac8c7bd55ff98928ac1295e8289e6ea99593a4fb1f79a284fe751536704959399a2abffba99f406e1ceefafb3b10274abea5ef512c58d7d603495cb81deb09f7d10b9933756a79bc7c2bc7787edbc256c5cdd74ef4d9a289427a654a3ab1e2c601a1303714d96f7f17d8263c55adb7d67d6d2b57df8ffdb6b935c3fbaa5115cd1610cb440cabf55e59a8557c1af9609e733711dfe7483068850244049ebef7cbc9976cb6235150bd967ef4b53a4d3504d2993b1543f3b93b0fc48ea10d89a755abee8e7e7fa8e725bbe9f059a35422133b6d57e76a009795f5a7af90c43cde05cc7765ab61c3e2560c9c7e269d4f6bf9bfe9c7be0fd54dced65a5742942c2fff2e049706e54ab0672cfd2b81d2105a69012b79e0fcf40644f396a8b3b70c9abe4fc2ffce7380d48b1219c1a5f0a981faadd4894a556bf3162ccdc145b86c48800444812645f1ab8e95eb9c9d8cad86308305270604f5e4bb72c118644cf84147d5ffe887689fb7137d37fc714e3ce8a0636dc31cce0fab2ad7256be669cf4f162d61f7d7b3f35df00802a18824dffbab9098495cd0e554a11109a660e638d8a405d645e312f19dcadf5cb130607e7173c27fa5ecd034de72675e4f01288fcf0ef1b1d61cc5809ccbf12f09caf7611a604596d7f6b6be25d07d5d2446541fce575f897ac2a61183cae3e7e95760729de6419bf17933e0a6722beefc5b0b7f6ce5a7e16c5cdfa5c421f21ff110b03fd3f8d94b64258a239a3d01624e81e13449000a33f1dc2db94ea87ede0f502754bb5f03a18dd484b2eaa2801a9f4eb988112e811e5948f5eba6684e266d541bbcf708586f65c1e4e6fcb419daea952b2c195865de74de2bbc162303fc51143be127cb97edf7ffb758864e03c1ccc4b0f02cac570aa8f2b80e2c6dac8a68ca4de28117465eb5ce93d16234113eb7bf26ee7b39015a6e546aa8f416f151d08223a0597149a3a2fb772d16fbec0ddccd1eafc29e2ace2d2cf4bd15d2fe00e9f38cee85b043e002e8976adb65c783a189353fca6707787ef03a7afb79fc3d1b7d42465f104df909b8c27f5cf94ee9b67b50f8af1e0683337626bcfb8f3a7e063a7ac11ab0a60f11fcbcf5bfd82e9fb8c80cadca2a4ffa7ae367e743e769cc9f2556f4368fde9ce1e53bea16782856cc8a3dac6366cb3da9f002212a1d805e72b3a90070e2ad522703122f561031fa93179f9f270405a57abf800b34c3d598acb479f987b7bf8f70fd7f1b49aa670929ac9633165da1444d37236479e9641443fa808cdb95731ab8e9805ace67869af1275020b89c96d1179ed19c6da413e157c1d304105ccf3f9adaa51c1fcf1d39971c991945131d71ccd2409c82538698767d06606cb9bb596a60c1c725ea5a5c4ff07484b1ff008b2014e733b0079526680ca616845d9cbf1f94922f81c05a33ab743bb9e23486fcd354c85423f78dc3fef47957bbae49cfc35c16d776029ce3cc60281dca6690412de3b3b576c517ed1580378ce13e1627f55cb2433103eb7447c64486e9a654565bc66b4775c9cf302bd79501955bc4b87af2581f64f3bc7ae716533e145700436b50ea93b7ab153fb3e79da80a6ab89bdfa0d82f40e30c808147941344a906d90556588d08b22d3f9bc0fc808dc0b5df10c33304e12000fddc59a98d6b85d3f2f54bfbbad6833c332426c3ecc3303dd910e0864f6106dc4ba172bf8e57fb5a9bfe4cbc853fabe39ff1a685140c4e252797ca08207f2be36fa4060f5de5bf28f5dd77a1775a3a362c3a98d4eb8b295488928dbc109f8cb69f774aa041a4d3a05169b4642fe66e0c94f60396c956588621de2f24a05df752e98411f459ec545873ae30dcb083324879ae09a283e7803761d5ed9ecdc4abde72cfcbffa5db67ad7882b70f5e7d3efded0d2659b36b95188b13f2ea7a4294b670737dda3afcdaa667e3125053e7c34d49ad609f53a67008917776c495b0643c7d05e081df5ab3774d446986984b1dd0573566945d13b2a8ed386ddc433c4fbbfd95555556b59bb7c4191e118352145f906784b11f1def4801d3d873ef2dc3e243c7821860129b4d46fca19219c5469a7e668d037243b6ebfb850d5c980d3e7ae685d0fa60220c795c4fa18c873976718bfa0297e8c43960541f29534bbf06add0df1834b7c19884bae42f25aeda69fe6b3d06a8771dc7577f32267b7fe82e4fea66936bb6105ec9808fa1a844f5b84d2149cc3d211dbe486e0823fe20b6e0332e9ac1d94a9deedf07f9171b49529788e5b35306188ea0fd9114d746bf86e6aa6b1034ea1a9284e27935d9d4c2361ff71f557b4ed45300bde04ea7a5579f1e7169d0340d4b62ed7903413d7156c867394d3ce343ece3b194226db1ca0a156390827eabe68ee2aa8625d91a751c47804c3a7fad6c6239c155af71b16148ea6de9639edd0fdbfd8046888ea1ea3a2bcfb5de89edf4bf2804461e71aa5010f73bdf18ea7ce9c541f817247b9d024abd0ad54e4888df7a42d73f143dac74d57455c9b8bdfa0e164e3e93d8ae2ef7c0d95731f74196391b586bc8cc39acb0c04458e7835fbd58fbda854fabfb3fed66cab1d870e3a1ef4bef9dde0f8f2efa02180f05cd3699f03c96ab2843d46032152e606a0962505ad90582bcedd4e35bf6b296d2f65db14fa8ac8346868ec2ee90e9702464f0be46257109470d998b2bca39dce28633169d54944cff78c3e1524f0ca091161d098dc1c5c4717e5c021002b0f857c955e32fbde43d65bdda06b479c5993f23149d92cc2d726bd20e7d4d1119b4c6e53e998e803222bd2fd5d71e7a5ff1147bfc45c5b3af21ef38039a4f8d0bdf7ff593bb2bd76b30a77de75484ef7a1a6e3d20f20a9fb06424e39e4f0e4fef9270387eaf8b180a28ba9f36507001353c7c28633690ee2da64eadd435a55e386f73736147d0161280dfa8cf5999f338fc8bddf78204c9cc783e1461fb106ebdb8352f1c0314363c38917f4f6fef1a369816cb92adc5c22c97cb76122901f23d75537700aee72f5a363d3201855ed16979e9d85d69b62d2ef3744bb98d23c60a4c231196f4f83d6b67f038921296f6030dc5fe9306f62ee6f5b7a88ee48e71fa9abc4bac9a61c27e400561b2a4dbc66831bc7bd2c0f2c7cedb7a9851bfa965121fba2898bf3abdf4d9990a9ceb0178cac60da781c38bb9092fcb207cf8da799b46740d77c80a9bebc818652206d0d3abb206d022a8272574091c86dbd783d3cfcaa884abbf7bfcc0f848a731913fb1247863dabc2119817312830a1415e845b1ec9404224becdd627ee203806cddac6916955cdef540df03737798c5dcd197de6e7c743d3250340d9e28e6de6350e20dc109d30bd40ccc2d6a8646b681cced8cf61ff835f6f4526a91a40049badb5fe15ff54e9652ce78a8322a052a90c683bd77c6daca2555b0a1951a861f643c4f5d17717461bcc68a28d197b30efd64c64bcee29b4989d6c7b42c9e56da2ae98dd6c7023d2901b19e08d5e85bec5714c9e6481c2b69799f294770f54fe5eabb705ea34ff894fe9a2763a0897c1a9d59a4867e0ee5568c8f488756f06e6fdc2856a0b9f856132a39b8eeedb05cf4e9b912e2c5013fa30ae5d98c427a0413508f8a8aeb1636eb099357cac6ac71d510dc276df398a6b8032176557db4f3efa8c4cddfd61b760634b7e7baa0944cc658c5c084146dc41ab42fcc73e160d03f823de172c7e92e2eab70fd868d68c696ef2607d5c5fa8abb06ba19d60a419d151da962b5afade7a20a12ec5ac2cafbe5713cd2c80989a2fc08c672cb3cbcf8009fd681a7257941811ecb21886f338ba36dc627478bb07f57f7c88f49088127c2acb44c157fa6d73dbd5d32f556f2a4a735d331ba11e4e38a33a144b11cd66bf2a0489e02366caa1892d9d05a61e57e4702d6b0c0634114b74d2a211ca2b1fb2e82fdb43dc5c9c4e3598067946d5df62f1e0643d2efee9898af809f99360fcf538eae0c56aea15dea2c123750dc457b116ba4f8a2a6f53018daa1e81613d63fd67011843a46d4ac647428d3005b867175fc752075a9bcea457ccbebf5b807d0b126d19cf45b32223c07cd76a6167a34a28f29a24ecec574fb1aa5cf814c19333174b38e7091148853afe8c5ef220bcddb1423caa2c520d60b28baa5ab5d242fa001cdd3457e9fd6cd81a7b0d7db0000253fb71275170469fddaf95377600bdd9afb1464bd49a88ee06b6523f20872d6bd7f16c2c66206729ec9f47cf4138c35677e0c687747313b5ce763a20b733bdba14e07779f97ca56a0461613b4acc81ab2f64dda7db3544ccc26a2b638456314bc840184be84e6ab72fd9c640fe00f37bc14fd79912b311579eea883d9d3059e39451c07146b65ba0c7e1b0b9635321eaf2309e0d599324884586326e535f2d1ecf6c6fd240cd753cc8caf1079ea8ff89ae20e629011e3be80b01b3499600a193503f8cf27d4b339be3f561aa26c858dd0c9ac71bb03dca250d214ab267889748b48c4360eca5f920df3bb6cd86496ad035bf73357883363b46eedf7a7ce315a8dbd17b0f959921fcdfc50b17ae8e36cddfe08d4986b94f218a2045f25fd1b12db0d64954fb585a66fc483f7c1b9de967f1ba2559c8e353a600088234b5b9f499eeb12fc57008ef8882bf71156be2bbddc1dfb70e40ca44b95d3181bb084d9254eb6e3103625b93922a3b93f92a1addbf01ec211080e3c0afe43b78426e08a8c1b0cf731526dec5185c6b08f4a1faee05c7852d82f457fd64395469b097968e59794ea3f93d7f3d26226bf20d3a907b592dc71960f9c1967e9b2a6f23d0cb06260d6a988b2a872292e8975e9767129a08bcf94b16e58cc3e293fbdde2389e0d215696b01f9d7737ce941bac6536aa7c940edcbf1e0d038a701cdbd4d936073b14b9f371d3e7d3720f6529c4e8ed4aabd7c30713765fc4c7b9749316917f44e26fe397dbee2f2ef6cef490b45dfa2dac5b1b7a43cb27e074532978924b51f0beb18048993345c78b215baef020fc5edb4e9648e04f696dcc989b89637d66b833f92793c6097bc222e782120eda0c90223f3842fc784cf05105d9b3a64ed03acd75d42099166f3e8f068fa427bdf9bb12b228a47c982232fb4343602c8dddbc4e81f9428a1048f425aa2bf066140d5a2764e02494a008b8fbea008c0ae132e050fcf4b2ec8f2e5009bdae99728ea8bbce7f21b29568490f217576909e167714748b7b50903c7a6c147d293a8eeacc678c04ec34f7ab6c734a42e9345357a0d7f9acd0905a438c59e6f10b651f4aafea0aee0c89f287cfc66f35cd2833de469d50e5a1782c21b24a7a569adaa454ede769cdda80e73ef01aae870e39fe795c837306fe8bab9ed1cf77fc8abe4d584815c9fc690396a0fa8984d3d0725d2cbfc8a1ce3361451054abf060b59a1960f09b9a4e395b8991b69703629e392b1c413ab2d2444904604f6e4dfec50d0fbe454ad759ba010bc3550b18cdce511a4390c2f38027210430cf3972366563ce5e3b1820fed180d980c8487a10e83f9c5acd5e08c8cd2bb463c1d721a35af33425ebc25ed1e3e0d9310edf76f1137cfdbd12056e7e9630b2f487a2fc92b7738dddd1b0f2f41a9c4de90ce0571e4c34bf53030ea8e389e3cfa51f1056e684a4187b125fcd84a557e06b1d1bcb96c4effdabbd5935e51d76432cb96a8e41ddf17947ca316980e4bd74afa55bb0003e1dd42da8b3e45fb4ba1af5918bbc825b92f98555645a4153a9b5b260a32acbb6f5bb952b9e48eb56f37ef77c6f7dbd7d5db604932380c703aa9f905edd650b38bf17b013f4d4bb34f06881a77d720261decaec4902e9824e51c9b49a2d302b206789f64c0d1209e8c9ecd71b68943a86a9f529a96403641c6f1bb4f9f964ce21a59fdd8b1d16a50b8230520d078f4f187d125fc65c79593a0d837471ae1afdcbb6fa9e17c6ea5c017860b2e1fef9ea5523a83067b9a11aa7649780021fe22e60a0f1e139b8a70d594461190e95d24dc3343ef94dfe41f0851481b721480e261fcef996e3ee9cde6d7d962e7cd4d682a3577021f05cd6a5d0adc65eec95ef8d7f88ba3a5c41ac49841f20dba26a69e2d556df3fa26761c39d3242c4caf5cc9f024754235955bde7998adb6ef20f62fd5fd53da0c690313c274bb0ace1d839433615768f1ce3610fccaff5987a7d023202cb2c548f0f6aec4105d47b35715757a6a7983da4d180106c0c37befb60a56e7757e0ba9cc3820be34275f6672b503819e4006cbed690e8f51678384fa869a01065a708e4ae93731b41a80e133d592f2a667ffa3d8e3bc2f95119fcd994ffa7df82cb50c72cd8cb09a75a15cb625f291e633100fd8e68e1f5e933da7de3df67a5e15d38853df0ca1bdc951408096007fc4f067aba84b66434dcb04cb699b33bfaded20f796459cc19649ce21d81f759e36320e063540bc47706e3e43b9740ac8d792b4ba0613809f2059fc85f11504055cb02a3547a42a071a51fc979c6363039e7b34ec9f4b83b7275bdd9da65edd014bd846ff765004850bd9b8b33fcd7a5fad4b22166541af2e7c41f18aeeb5819bb2ce21a7bacb2226d93a993f5b03baae0a220d856960350b9a946ca83fcfba5e08c229fb2edca56fda67e8e998034ee2fc02335f9bce8c388d4bd625496833c1b6caaf6b3bdd06006225889e0442fb35b9d1631bdaca2b748fb53033a7ff836f5b8ef88230f463dd9f99b64ee7d5a0b0f640fc35c503ca185df8dafb06b0f369fb32e315452e8b37863e7289b9828df353ffedaf6df48c28e4cd8d7090fc714d400aaefe9b66c907ae821a6aae8bacf708eb7886ead173081ff15bcc8c39ce81f43c6469d2cff1c2f49cb090879a978acf562e539b19011eb27a0b810443e729e771285ec45e8a76a351a5ff458a17798cdb6a10bee39df5ff56e3cd2d392fcbecfb804e2a7a0b80214bdb2c8344578f19926806f9c0c6712bad6c519eac66b4133ae690136a50cf8cefadb0251d30c9bbb10493826ee38be13e573cb67317a490434f895d2aae1cff8e82b8308a239a235c142186d96f81fa6f61962b2fd1f64d2638ceb35d7fae1230a95879452136330d8fe18f81c559696f5efb00cd6af5e6a4784bcad0e2743eae7cc7d4b1a40a7ee6487a5f41e7d331c55050484950c54910c18e9c32fe526700de2ebded8d0c063d74f7f45522f4a0ab805a195d3b93837c0e07d8eb2a0c1bad46ef0538a07bb0e73f29bd75f291043acaff35a28954b8cc8ec08416047eb402c6602fa12d768dbe113e2afb264d805cccbb75ec921cd2043db8b3477f8d1c51be33e75e0bb5cfaf54d12dee53549b5afe495298fbbcc847a9b1a3fa90dc8a3b3699d4e030f09cf9e581c455bf6addf846ade4ed187e893f9dc334dd3e29a5cc7c5abf45e319e285ac5a6b006d04771222e1c16e54a5deb485f7a98c066b5b5736694f5362e7a9134272f11cfbd7246e90c60ff8ce33ccadb356f894b1f976c7c48daa84053ad450357ffb1e2d9a132435bb3413057d3234ae43e5f662c1ffc5a288921abae01d924ccb027b09c90afcdadbfec44ca0a935a53042dac76848617dc2835605bd6e2cb0871bb6b68feed68d29538d612f9274243591a48a379763a6e5cae4149b2f0d14c58249d04194b59318fafd8f32e8d2471623000c5bafd5f217b193879167ba63ea4ce0f7470d2688f9643cc4059e138d63856ffe9219e0f7373b8b81bbc9b37f9b84ade137fb8c5fd5227db99976f720b0dd022c90531faf5e97aefc04ff64db09debb00ab562581a577835c513e157e35ffa01b0e5ac8de25b807cb473dcdad31f8118b6b7eec1ccc9b40a5fc14fb301d4692b95f3404ad10651804252626598fab8f1ec0d0299b3f3ddc9bff6b8316db4e0e1a6ba28502b690e490d3965949329dcddb9e4c2513bc3db169e5d6229e235d280eef69a860c071844f2d15fe366d2c683c812b0e2d845a7ea645243c936c89c35bf89e41ab0bdb47b05521c6d2388a290b94b21efde7c8cdb8a237cfbb3c0ae1d2025dbddd2cbcb9cffef7590b8574871a930a898555846a8cdd658c083759a7a708fee4f9732361618c441157409ebcfb58180a68ed012b15c14103ead80ad3c386f5f674a7f2d744d23975af8299ea7edbef4520b6c60e6ab80015b8c6286299ace75b6934b16781ecd86b50294c202bc73284daed59bf98dc73c3a9920ee8e8a2778df6f7a7b1da9f7800030d63d6c00c342b8dc1de78a6372239bd50ad349de0cfeb4ee1abf862b806b53cd8b033ec0582749042a86071177448e2bf0017634ce8c1bb958013ccde5446102bc7205d31a58397bfc7b7ce78171b707bd30031a9811fbcec008e57f9d5b4a59963565bb84793c71cffc1bccc7d5412acb17cff4392bfd82c6c545764ce4838df5a13daec1b9485bbfabb3955609b6f6a21a49589e7b2d67273bc8f01a8d04d33f0cee487f9b64c244d885995f8cb4068f648a6de5b6c599d385e714bbd58785667f502e9034627920e10bd8ce4bfa5aaddc71f387da1f23a7cee92c9fafbaaba579340d2875427d1f8aa1fd5034e049963166ec8f240ec7911e0a3d7f735c2af6b4c960bf137ef4de4040ada4c4af08fb4ccf1b8e6091cabebca3b249e95e381f4ca587cf857dbc1ff81897e93fa3493c3d4f89416b5748ea1072fc5369268d8c252cb8a0127c733c8443c9e25d7c41d8c74e0be70fc1ead2e97561af390e8e2276cac3c91c784cdb6556e5ae79a974f74b06e973bf9eb64c8d95d2083e62d0cec4b3895b149cabbd918b5e40094c7dddba3706d94cedd5468e823e5d1e1742affc0888aedebf399c9d8a60f31bf6634e1114103156d7ae753d9754b9476772519338da7fcc433dca549f609827ab786d1e6dc5d6eb45197e87f4fba86adc5b85b037431d542480da6aeb9d61204558dc5482b5ccda96853842529fe517c748507efc9eae5829a3a7c4c2c12d5f36f8a60b1dda5721295afa12f0218457aef3ea06b8f976f1c36710613364d83c7f5b192936350b7f95713a46e85db2c135ee2ba64889fb16f8f4bba4a0f85494f197bac74148ac879b68044cc9e5305edad5fb3a8ba6917743ad0e91808bd5705832062e7043f02f4e1598fe98a9f767b8d554227c5108c446d79569f5cb30acaa3e90f1ddab75965b9596efe86671d685bd49339e65153e52c6e2abd9b313a50f20c8fc4471fab32ff1f9363cd7fdf6ae419494b66cf388272761323a683a702a7caefb1454c858e1fd078e70c5bc3aad70fa6edaafe0761f2409ba4ec059fab3ebe846fcffa7f1030cec4373e6c8594e1846cf5d452f3e812b31126ef1c2a374c13832fc9f7b478d6ab63691e8811067a79210545cb7dbe070e40c219e5451dee6a091246bb41449bdb569633885db2769737935c047af594392bfac114795fb672894dd2f18ef0147ea8e2510284c0e82cf8df49402f4ece79e8f45069b2e79e94114dc8f215d941a996a5153e645e27bbcdef6839ddfdd9689fcbb337cbb4ee0d660564dd8f15d5d5bbd1a2d0e603ea627d69e3432b3c3d421ea959e177e3c41233928b07c114feb47e9f90157b0e204faae1b24fd22e8c29ab83cdd564fff2178cddb6d7ec020a0f5664058f31b91362b8484fda1b1beb7fefd71e5379e3dcd39604195d8a7ec87fb06201ba5666a1c11098a8f513b229e36fcf465bd6cb0bfa9039df1baca628fc0be3d0c35c3295e5dc88cbb1d990d11096ebf7b023c35b350d3dd2a256c03f358193217fa5fc17876f450b16a04fc716b5399812c0a9d98a31769fa3abfc0861f7013639120058746ba24c03f9e65d08568381b3bd5d55235dec21a6a40c9934d31f68d36924b803448101c6fd6968d30ba39041c01fba3fd60f748dcd2bb1810cd9fd47ce79b53bf65e5d384d41ed7bac579a95f81965d7c72bc728b2235486d36638b372ee255ce2a4f543c73eb50be93f8470b9ce92d88bd456ca2f628fb957d5948b26d4397699cd362debc67ed2ebd75b39836989c63d23073bb12a4dd3eadf00fbf199c7014bae47755e29b95f7011b086b9d36776120198bc63f20cbe4ad84c8405fcd738685bd68fa866f28b041bd9229daa01b76b16843a2cdf6d2f95f43b655190e3e8c746b49f64d8a22b06f18fcc68777285f8cd080a3897654bc34adf8ca7d2dc39fd9850c62218535e9297335babab16e48e8c13d688eeb212c8760731e51b6c67f902accadbf4fe25de398c6d9d446d0883110bb2687a05a91c83c08c61599a120abc9593731dac65551d26b8002386f2c385c442ff1793678ad176c60e8a813c6b76521df1d17d10dda86b29db5600dc78873022c2c3a8ee0c6e84aa3ad911e3f23663b3b97d8540257fa80d789a41be2cb262a07aa669c6872d05825e42e01b03f7960e0ed019d1dc260eaa43f2ac78d72b146e869229338ce64ddd06ca33d629893b90b8bde1596e0c0b1c9077b67b76e178ec42a170bc858ac3c236a19237419113fcc16c31f2f05f13c6042b69286b691a7864d937494ed53ef9d32f407039a6a5ebea0056c5d7ac9153389587ca30c412dc355c35904c6d74b1a252aa1df46bc1a31c42b5f510c475c4654438cdae00d188a7a2fbf258b2d226a490195405216ffc0d07218e361b81a32cc421045ea4153a3edc6e21649fc1848f066531bccc3c5303d711cf76704fb1bb02ba3465d6ff4f59854542ad06503d4c7a7f34ee01c5fa21e646b4bc917b755110f5b8e814973dad15a409a5f5b3d2b86086256f36f379c04a6fed7f435991ccc7ea01aefb10e37461bb5c10bad951acd8eb7dfb7be71dbdf16c6ddcc0524c2f5b2913a845287f326732e13fad6ac78cad835011c2a5d2c842883d47db5dc4887d0fc9d6a5033f206619b72180d4f52973df61ff7c1fb0f6a76cfe2349f11d23730d47934735cd3649e810c46d2ecd3ae05795a251457b01c951405b4c73d7f45a189555072272c29204d3294cdcf4b3f086bca519bb750af128daf8e85247e970e7da66ea8cfcbce4558b4637cfee812dd4a4986945a1ac5bab5b7d503758afdf3f7baba3a7707fc23148ee3161842b61b132dd00a37f0725e977818701ef423502b01c91fb59efb7537e8e73a2d6cc1ced785579669c085801d64edf62997d315c54e395f14ba1c10f237c0abef9ed2784edc40a8cfdc2dc9533a290c713bdc8683bd51efb4fb1ca64f69f214bec52517d59634db9ce9d30c03a1955b72b52663c34b2b9d7c0791d24e045b54e3392f19a058b48034360d216b9c2a0432f593c0d29f5895ee5040deb1043b46df197b2c6b6454a2f8fe3aff0c89699b4c752da021bfc611dfe583d8e9bc56f5bce06b326be903951442d03e10cb2fe59d3d81c12b588bb3a0c843da6f79eea579102bad16a142bfe87399f8f1aca5d3c787d3c0e509af8dd9c8e91a2385fa1060a30d6c75206155fb56e3b5520bb059b111d7183ddb0df5b688b92cc1bf23e38fd65f2ad75c48d15c3b782ecf6cb3ddfa421dc0717761dddcb7dc856be90e489b73d170896412951b2dd67f1d4b559da93973ecaef98a0677798d6712b845d73fc66c25d88d38c9b683e467fb3a0796e27b2564864c09d1b8ec0fce8024e3abbe7423e6f594752c597354d351670fdf25ab3e7bd3d6fa84dbb5a8762cd108177f1ec158752b2ea4ad5143fa02c2603d31289e36b94dbdb1f19446bdbf2d38a074f15ea655d1c91a49750b80bff38d7760d6f11b0200202dd0df41e198292dd47f2ed1705261c053e9073994db9c0d0a176ac87e9203249dd93354e0dec9df21de741b6e2b48f4e240141379b17f48b6cf067d65f827b1d4a37b5a518ec3b44dbba73c49c89884e7544fb629035667d9be2bf9644bd14b1f845e9383147a5ca2f845b5eaabda2a9c53d9059e0557ce0e12231f2390de4ca8280411125164e5b4c406826406dd15822834ac2a4558aae812cb591ba9e25813c7ab4753dca4b9aa0d98c7d197c316c95a1a40348a646ef01736212df9dfb68cc8a7bce08e8dc9a8f49d7dc02e3575fe5195341e047e9350096f94ddcee428f83a9643235b403d5904236e01d1d41660521448a808cca9efdf5e6da7b0dc552699fa60486b79337a717725f63dc061f5c4490900637d91f5591e6f3c998d39d64126c7f1f582ffd99b7ffb811332740ce79a5f6cabe9b16214820e76f689e24104ef4f3db1d1ff02716105ab2375457e81cff7c4483eff94f7b90750dfd4475df3ec0a85fbaab447731a57b9f310629a35deb7bab6a4c9b9e6ebb4fe5484b82cf8da32974b41740d66d3359d76b540e8390cd675770c13ec333df683e4d3a920c9e172b3cb832ccd782b57b19e310fdbb6a298c5f412caab021b27f04a6b28b85a0a9c1a1ccd3c65f0f29a8d772ba754a1d82a38efa9331304c8a18c2568f1d5ef5e2d4e2dd8026d86df8487659b90b4f7286ff72446e115712a36168c1e15af214504e82d43baba8f6e8bd5b78acb7943b33ad900dde7c8e512c33bb7d94a342452c001b294ba0f66b9122184932ec049ba24cb999503e98017754aaca0821c2cfd472629b5859e7d83fa2787b7ac734815939b3bdaba29149c984fc448eb92b85d93df29dab7d5299797b92e24bbda7992b2a2277a24d76057cdd919dae57f5612eade8356f12476a24ae286002ab2e616961c36b7e809e543e27db57357683ec8dfd9eee310c0e8873b25e00ea917a1900cc1a599fe44505853b7c6ed959d548d15260e3726352d8986306b103b9a9713110a5d7d57b24c453b47a762e3f123ee7ea4c84f385eda00de0a562b92b3f8eca318c340963ff24836861717de73623b8354e0dfd107591aa55254600abe35cb4fc9aff64c8a9ece00746cee6a887e6177ed7ef6e6e7745f820ac118d9956ac0867d772f6b0e2ab4b971d2534ae6871cae39f3a7317ecb648a2a59045e2434b9a69574ce7b33c7be44b33182345b36a55a6a751f018e8267ed9bb6618f0552a55402cb82689daa2e3c81eda394869e3577cfa3b1e5d9dcfac3c9de9b45c285158e323faf677f02e3f725ea87171902e2deb7ea5148efe8bfd3deb25fc5afe8ed4ed72679f15140fb852a087850cf57a1ab450d1ebd85afb03de6fe3b8b92e80a839f553aec2053d5ced2a267b015286e5f51f8910d850778b988128970a16c7d43776f17cd52d11e8cccd29472a47f4838bd7c11ac04b928d58684fa356a38a27dae411954ff71b3f0287eb4345dfe896a7b0d25bddd0036bd8a54059f2cf18e92c7a20cae81b6c4553278a61dae344aabeae3ba66ac896e3a0f5f04b8154030133190456261fa74658997785d4bc9cb55b21c779a2a81783229290a506626a2f284876c93be77f04acc6c30216923e0af53739d29b7398f6c804a05a4d1e14b39cda01b475da54bbb84b3b580bcb2b9d6f4ef350c9ee733e7d667379337e76e033ebaa9c54303f914f48a3f4a899dbe438de713c4b84c399119dc69c066eecd1e9f0dc8dfb797944e1b493ac1751aa933d57bef4aa0243bfa6d6d7e814e304ff5a9fd41f167f769ab8a0757d71d7e05f57373b129b13fb0c51c43f2e44153d8849457c265db81c90b4c92120b2da23ef15f3ebe0fb668cbcaa2768f60f5e8423a86b800a7067026212245772c62f21fba229796691217a5ca82e5c45405df855041007918f660b55961fbf56de83fb80f21d67a664996224503d86c9ed29e70c6cc92cce27caf34f6fa4f25b7f5284720cd56e5b1a4a4d776e126f24947ab8f4dbccf854d8348055678cda69c6f7c15bb916db5c8ac7e1b25c71bccd3e5136c19686a39612373726d843f7ef51b3d75f2f772d1f7ca5d7b2d8f3e3f2e7d20d68742b4c141a2319a8191743761714e08eabebf5fb47cf080ff1e1fad91ed8d720247a24b8294147eb2a6c7fceed0e3ad27895859e886f280a711a0b4a325408a3ea414dc3d5f5595c053cd66adbea8e84b3ba155f2a6950e44f008989ce0a51f797808c3cfaaae5645f9bc540b59d1cd84787afd6ba41a086d61b754bb134f41a9426a2bfb0cd084675fd21ff9c7f0166095a4e97f24484dbf58b6536df2fbaa270bd07531f3cb5c66316f581eac085d9e9658754c4fec59bfd4f74a77881cc0f194f77f4b21b6edb9b01851a143eeaf73125b3a1e2f48b28bd80462b027e801acd2de4fe40a810ebbdb103056a22bf96df8d025a580e3031f4a954e0c9f4442087c86d32b5130f1a2a4b3513c45926d5e6d7d1827aade014aad1be72ee11304e87f987c0561a5d2168b13b889b8fde16c0c525d03f8c981c105a1edb7f1c067fa3ef97218c9764eb918d3e2213c9c8974b14d3e1063c473daccceb797bb7f2611b03183323dd5b9758b9a137b5974c2d239aa950908c3bd753cccaa05fc581163ca6a607d977d0e025106ac846cff9a67a90c29c42f59ff4f34a63e084162dd2e2670f170321622441e7e14b8b98ab5d1009c95fc4d5833adf9b592a5eb6be063eb5f6ba79aca4641f1f8acbfa1ffc8548d7bc4a806489468285430ff61095d818df95e4db6de5344ba061199e83723fb16afe1a8fcd27ce7cb04e83b8f5c8b25b528b0896c1c9106e5304d42f4cec62686942062291c3a39fa92b07d8d02dd84df7140a7dd0af1363b0e5e8a7d8befe847d2d09724240317a734135dff917e0b7127c0228da782526f289ab516ea16042d6426327ea37693b1531ed6132f136158583dcc53c0377f0505ae8ee50d49ffea8e1815957bf9a282326eabf35b597042133836e6f860266f8dc48d18bd86deaa6d1957c18908cb3dfdacbb55554e3ef47c5a168136897e69bbf0a768919a25d506e0277cc1088ece1bbcdd35aeda49b13a1b00af06a3f0707c3891d4f4991d9c1d27ec29b7ae21bd549b8ec657e784d99c4463a22b814fd35618c3e7a25f862eade832bde6ec84d0745e387a757051b938f1e3381089670a6ca6c02b87f7963ba2a70075c99e421ee79a00deb1febfc3b06a30202a33919a069297b598fd13cf213c4d0bc7cae1b255a8641560fc15c4fd1eb4f7383a7079f0518ccd5c05d5ab9bc1432078b12d48d510b362200945f33ed3ba89b9bea0602053ad47ea3dce07024608c1f8dfe72d3b2de66d2be917d865a8c6d3ee402aa87f9295bf33b40fc8776ec4f1406c0ceca8b49b9d88eb0cd0a7d63e1565eb50b3416a383f86a6411f32bad1571261828dc89d9e78d53e3b4b5d004776cffa5d12dbd38de035c8b8e334ed2a370df883c26ab3be323391fb5caaa2de4d170675acd9004f257d93a2973ddf80125af3fbf553d347ffc7c010ce9967cc21324bbf15cffdcae64fba4d42c34e66595de2c5bb1bfd2ea4bba00d77b44803abf45baac9e03e9de713b4b1461ba8c8cb73cd0edfc141197ded08af97a73c24002e7ffaf36f9a5282c21a4edf606568c0b819db462b5c7411c26911bcf682ccac17f9b536fbe2582cc167effdec2f4b24f7e8e45d0ecc303d69673b7bbf11509ba9ef0a9304f76d922402eca62be9b86fbdcd822ca72ceb9b8838427e835b381e5c22f045db0a843c5ca5bbc2043ffcb4137a8f7ba01fdd11db1e68651bd0f0f2f4f08a2d26f1fd63633e286794ee7d234f8cc5efa867d514a3cb4565ff4b5e2868422950b137731303bc62b76549bade0900ed55696bfbe628b0b8f8a616438bacff74c2bac993250a5d3fabab77dfd13d049d3b740a492471f868de694fcd03e740a55d484bd449e4d0e5b1e9fac96863b2da196bb940232d5f2b9221a7eba7f62934e4502d1d7442cbbbbd9f7f0520aa52ca25cc8c113dc3f5d2e163fcf4c56827ecfd4b14a5a2d86fce579a4ce5d48465b542787ba8acf7879f70eb18aec399004d340e81626962a77aee9528205553ba3aa1543a3ec19a8e40c4d663106f58999b1688f2fb906916e8149b04765bcb9acc7864a7e0d3b553ca4304633485ab166cdc4818f19e35c033a5172bcec270092c9b4596ea606dccb98d9041ca5759a986452edef1277eb5c3f8261f995748bec9728da83a1a0906b96a31117ac0ce4c127b22af5ddf1657d54ed1e8029276714ea8a6b9eaa1f7a76d10f5806ba0ba50e5b443dff16be472de4ddd7ad8458d9169779e6ba96983011e4c2deb06692e74f99230ae49072eb4d39940ddfe46c2261aac1bcb5d8aea3b26720cd78a22ae01a3cd9a7674bc66eda85eb2ed8de7aa405905288c54e1e28ef188ad45e40586b11252dc8ebf1a3e16a21f2111b4a6420d1e81139919d615d48757ba7c99dc82dcc23e6207b5d60a736256bc1e2152fa5ef87b35ed81e06a2d361597bf03074bfc8ebeed8ad382ded4857892a4c115e3b4ce1efb4934e1840a51970e53d3af079413fbee3fc25f03d83a9688b9290124a064c9fc9001f9d9f2065e2105bf7bc4358a894b58f5b5a5b8a56bb3e9ef077ce3f58e5ee5293121b0db11d1e1befa9c6ee371ca3db682b121c2b906bce24a65e88fe7aa9cb83f44e20287d8f1d6db3d24571d97acc40aa6a1748c5e1d8be01ec0aa265e2b20a4577d92dcea58e6478907427b1d5b6bbddb5f2217375a8377dc525d1844fa3436fb1cb8465c3ce05971971dae6407cae8fb3d2f041c19538383547e687f3b6c246d3afc9b8eb8d6db321749a1336cfc44e377ec378f8528ec69a8a8c6b54bd24cb83a099721c2285c296d268ffec521758713706d76cef8ae62860b570cda8c3273724b82fea3cf6e466256069d185c50ffaf6f5ddf40562b0a7fbcc110fc8600bee2f9d2e109b7025008d8030c43a505d8b476250326eeaa30c4fe283424db7404a95ff20d02aada9e67eb0d2c1acbf09ed1ff8645bb6231ff93edd64b83d81e8be21cb87e3ff67663295c0bcc3a47219ef9ee335735b1e31d86248333e74351e55d17dd9444bb26ed14e6cad244b92a906fe8abbdadaa1118044e183a40a158063b2be55457316aade0ee171a897366eb907fa78e16134dfc06d39369f34877c8baafe75e2bbd79be06d30932bef84135bcd80caaf37361ee027a989779b1b682612af21e36ec5bb163c47d9f73449d2f9f0c6b0cdc56f7d557440d004e2307f754104ddb3327f79278e139379ad4d2a34d9565952eed4bca4ebb8486c2ae5d32b904fb6fa1a49c9d9821dbb6ba0495037a863aece5ead79596d349747cd3b240cb91ac96f657b2b2437e3cc0b87f4759d5665b1eaa645227eefd6a539e9bde93f29b07b06bd7526c7b39e439a373d306b0f89bb5e01baae78e006ababdb876bf0e4b9796485cbd46333d55e0c995c49794502244ff9a6352ac5fc30a20d2cd9746dbafc2116775ba765a680a6d2bab4099bf1de9d0e81b2ea9dca81d164f46b1f82624bb81b57bed655234c829bc882d90dde88b667623e1fba161fe426cdc188f351d0654a84edebbf1ee8bba9f638bb0503d2b60a5e80747817068cf453ebd3291dc6acae8e9cad02eef08441bd7bdef7c749ac1e02ef7cdb1b4592ebf10e867d044087e595f897b67a7d36f1e53cf84527852321ce6a1d16c272108980e70676313c5245e21c1f4c08e172e54d5d568f04b8f6bcdfb52413002b4e5f70d919346290a5938653462a9a397b216f8c970b4b35cc7b9b7c5ae2309e83c164aad5ab8cf0db13268cc511160ac5e348dd24db661dc83836374096ec468161f5da3a637ee8248353e4b5d96613566757b6d54efd30f76e01e345ce8289c63ac69567c1366d33a93ae10fe51ea21f642650c01912d581e975f56754fd1037a59052b907194f6fc66edd68cdae3d7be5f1c77c9ecf873a606ae980d6a623f60561d84ec64d124c25ca952b4767dc9726e335a73b77ac59be8645e6eeb26a164b97b5e59466b2a3da1120ac50a158eec3b11317bb88134c7ae2227f6cfb26dff8973424f3648b3df268e14ef38cb59d900a72a4c0423e720883d4a27ee1b46ab808f4b7d685726eef583bed71d2d4e9d755c1a40bfb3d4a296f6005fcda11186f3f97c70f0926855045ee92f2dc3fb7c7db38f67c4ee80fa695f172c76d6bbdda1a4ea86621d660537a68af3f201b9d2de7c0ca8ac1a041aedba8e61b65b88c4430fa2fe0a26fa1a5298fe82b2b74dacf5e2a9ddd0b2ae1e60a99d8a0c1007a440a2dfae7974406853b347312c90e6328d9af8de6fc4328e94c5108c0ab146e667898df7cb26bc814e7124a593ab61af4eb0f929a9f4170b00de0ce58056d185d90241991a0afd32c4ec0e8566ef125eff6e7eb8150ee1a8e8551bdce2c9f14dfe853300f20d9025daf5eeef859180d8e42ceebc2dddf9103c444216884339a6b88d29ba3d08caef1589c1346ac4f52eabd48ef1ddc34acd4e5d5efa4f01711f37ea0e9ee018d8255bb6bc35b3258775aad82a13eddfdc7feebf0354920eba5ac8dc2d67c58eef439fafde36ab5ffd10121b0b2081a7939bb1dc317e3ad4a602652c5b2557496beb3cf7052a2b98d84a7da111f01739ceae500cb92a757ba615186a57d442b59092b25d8d4396e32ac6d23c7ed79ca6936867024fc640d3c73e06d7077ee406528a17b1d37e9212952beb3d904e2f37aaa317dbec656592db07597a9241b8ccaa77b08de71354f68fe5d05556cf0688ceb066a2bc7e5a09a23cd97d137ef60f2da5b0f064d8a7aa912235c2858b0a40a7996caca7868df3460ba497b2cd24fee68cd6930a4bc536dd8a0092b7da3bc29b44d5b080cc50e48ded40dc4f323455a2e27eb50a5c14ae54a5713beb83372d9413327f41765eae5465a3871976725eaa4ed419e25e1fd2deafbf814fb4008d61fa3cf635507b73c49fb93e12ad2a132e734d7b9aae7ce2d7433616e71aefb8b49d8c5255106c4f9ab9d31f4f79389c3e71d42d8845ea2b543c20cca065d51f83fcb8b13490cb98798011087115bfebdb134c13ae46c8ab3adbc2527888955e743ef0df9e01520ea78763a7bc098a796d992a178a522e7bf34855487cfae6c5039dda2be50708591680a34ac1d2ffba87a76aef6ebefbc0b80f1a29b10d61549868c3ea6036ce632b5aa3fc3b64fec6bbb7eed897b6acf6cac1d57c4fd432792a9152f9351fdcc4f882c272720c8176547400ed56cf235e2a07bd1a524020c7a2acb69dee7b18440fa25082c258aa53044daee91cf0156868b62752312e5136f7b07110fa6e925ee0a32197f80f37dffc0b0755ca00f9d5e6c9564411da59903c5219b3941e6f097f5c12b2cee1b5394a80dd9c5d2c327b500e41c6047219afa5809c017c1a989d0eb780b043349bb2dca3648cf6408874d0f9a9a9a9796e6ea127ef1405f3bf65f3499862ec0433bede77a570285947fbef8157bdb26296fd85fcf55f0e7b97dbf72c20e7301647bc4361d3c38e1f10d596b472cb36c5a7ca159941fb229779e6ea959777c4b241a50d987cf62ef275415c2a3aaaa274b05b2fa9665d258cedfd7e89ec9d3fd60df4e69954b0224724f52a961fc6c8407d8c296ba3c7388d26420bfb9eb9105176e18a93a0cf7d5e4d81bd2fb7a5a88f3f87aafb2758d18e41fafa2b6ea9406a73ad56782e943c828313fc327c0504bcc047875c87378b0ce2007dc4aa8a344aa47762b9c52312fa794a4d7bd9f6714950b4a13416fbf10f46769eca49ac19ce375fa164786cd786990ae827657a6999c7e7d57b5ba0f6e0a0003080e21c376ba42fa1911aeed1ce086b5a7ef6e748fb84b1d804efcd12f27b4c77539cba85ece7c929daff1be040a7ecbba79238e9f7557bd6c821d86316d8f55a123a758a5796f544bd1ebb21ebd9f75395b7c8f5e3e2ab4659d868bf95622ec57d4a36782d8c1805b613703169b37d84db50958fc3429e0f950b04125cf89e76e6d6d1674b169d1d0f3f2273ae722a45610964dd31e1325a336e3d4a06a0c0d589697d3959e8dadf605380607696a085fd34a388aa7a7c83833f807c999bdb2414a440f8ef88b054f5c7d1a5b14c9db4d98b3e2b089846940be782d764fee0e1ce2b63db4b4ba5d2b024cf46ed83eaaffc8ae440253752c2eb889c609a1b266e1dfa3322410b8a5467fddf1ebe53ea409d7c2b7a12517e948454ec262719bad870e7393372d75a749c0d0c52ff7368efb261046ecf73816b71bf661022eddc2d613a14e21d23d0d6bdaa795b2f801e904cd1cc86054f0be00174565d43136dca6749b8b38afeaae9a42abce8cec719f0565157cc1ba93a3a45e885de95ef7493dfde3a5e4d5dadd67c9292f46e020c131673d02100252192f49319dbc8b9fcc6cbaedc0d3f18dbad2e69bd078390c8addd225f81f56a3b240ba1104b0675f8acc1d67d9306f7e17f9488731247120bd1e2f17e9bf2384d86540dcf6a983bb28ea15dae6fbe853f548d1138aac1a6eb61bf39775a0f960d5e70a81dd21aa78d9c98d59f735ebb0b4745a114f1462491d6fc27e9529132d48203ff73b3d43c3f4f6f4de2bb05bb623fe542f58ab462f106eacb80c3c92228869ba83b667d5c42516124006cdfe49216fa7c2edefd63ab989b342e4992d32af523d84900286ce1e26e16fa367b0e9409e7ac0942919c9e95c97158a72a123acb5a6fa078736962fa10edfd53bd7b5da0561975b860557b01614ccc3a1641e57a42e6840ea7b2542ada32fca2ed09a3a4553d564c2db9d2dbd7a92fd35f9c8b1724a961395169f7cc343f4d3ef13217f8f316e90e30cefd1eeb285668c5a9faebc59198b9cf0ef3c1aea8c8909e887c90f814fcf43da083f8323b1fe473de2dfc13d19e885e1036e1b5c2b04f7d29384bd6c828a7093fe938fd934df3541c71467e2a654fd47890f436270002a742a17f18fb79ecc94fbf2c2a29351b80c853bfc19043756563b86b7eb85e08ab3058ce3d1f64cff0fd1ea2bc38e1bc8517deb3f3f459e875cf26e00b2c35686d48d17e71e5d6c899c7ff09beb7b76fe7ff659ca5fd001b76d7829b1656b10ee6d3ab345d5664dc239eafd16262e97d1c4d02f00edd792cf7df98fb17dbcf76ab85026824c981c133524a62bb234c9e080cd2bff49c921b691878976a3d5b4505f298f357367fc13cdf8aa05564cbfff79dd7ab8fef707981f6431c98fd80368c045a498056773afaa89d91631dbe2db11c577f460c9b6941ff69c93cb6fd78eac6c9c0c8a7b63a717cdb112070b05a0c261ecf65ff1a9bbf78d305eef52b627bcae8238f52dbe0a78b95cf3c85610ec0e309bb4893705fa505cbd28d0ad61337fb13f7530834e0c3612f204b033aeaf2a1a97b37c843c0ad448dadf49be10f3c800c42e5948e671f243e24212c97a5893309a35def10c3ce6fa0604d80e93dc5b894cf8e8ad54937a05082dbae6d6258d48fc8c87466d3bb4052b5013019ec59e6a4c2673619e9d98ff97afd71cf81f40cf78c7697605b65083befe8c91a4ad85456bacc614424691b0cd67054400df2c63d4389c0a919d2957c994ce2f42d38a0b8cd63a44b77147a88891ee7d85a8fff69767d5479c50c1189f319fdde84249125724d3e0b88ac012785f01448ffaeace3f96a8410a1b56ade5a8888d5ce011c9ab9ea3db95bdf7e0adbd0f45ef945a3b2bb7c849a601fddf7ed587803ee6c8508c4af9aba4fad3c30578a5ca4b46adf1fb400dd04c5aa759e2f9c17b310519306cfdeb579106a70666c117c3cc746d31e55a1466aed9084cf944f9be14a08ae56a860289ae08714e660d79db20caafe77b3b8f2234b154cbf5d6e2b8ee7a394f9ce242f093ff90c12fca7759cd316becc681727da55739223a5be7ec2890f6f6a66a39ab730ccd98a3427a98269f2300f9511a8892b3d61e8c753c661a5b90aea41a9d59a11b06749612b49e772acba0cb09efbff4e0c10ab00a0171fa9f002dd171c6a521f0a7355c5e6bd506cec0fd905d0d0886fbacbe2b111f54785a21acd31e10dbcd861d8c46e2cce9cd41552ac6ef551f337691888b7304c9f54e2e75ca12849f10012db7bf6d934bb27ddede55d088050c1a025ffa6686a3cb41a96bb8af236a05ffe7b32a59c137ddd589e08c4bec353bc1ce015aa025a627de0b5410f7fa010dc1855da7f670d4fc51f7857354c3373bad23e3d6be85715d45d84c0d3b3b015b8ebddcf5d3918bb317ba09fe9aa051fcb47cfc5c58ab3d86461d80850a08c91d3003ef5e0a802f1cfdf453a4dd77c7e3011461e66882dd26ecd956f9107ee90148760b165060fbf18a609faa9fb044f94c625a1dda1cbe2bba9047dafa58d85b07a190bccd904dc70b89039729f9a34a19e89646f74f072b07549a7e2cc9b8023102e75731438164eec6c07a703dfead697420eb1364590061f550ea3b1a735b89207a345efbca18fc6f768c473a5588b72af6ca5850145b04354b2e651bd85659c00cc6cb3dfe96a06f333d0588b0121f8f03d61f913bad6680ebade24347f91d605cea62a1c722f1c1ed2e9b013b693c3c41c425aaf5b7cecd414e697ea4faf592e74d73813ac933714a19bcef0499d6dd03b70ddbeca8883e9b741ee1c042e84d4dd4f5dc62559095e211e40d66b8e9fff3aa268d3e576cb5c34b42a403bfcbd8a502b547fcb62bbe528f29290c6167349dac81f0c12f2aceaa935af7ed864eaba74bf3f1837d85910d761e27dc614076216f34fc2b93495802f43043646ca3d227524d1654b4c4e4a7d16d03fde9949ba3e4781f401273a3e6f962dab1cbbcf4b73acaffba620ce74bea8318c324cb9f6ccd46695198809d98d07ed70270928e0bfcd1a8fe424f2e4169a93cd501cb109c6d8f80c581aefdbc2c42b3bc7c0a7685cd1dada64ecad259d11f6bc41d0036b7cf6c37e50f5a821724d9e06cdf27a4a6be603bf88e6f7bed7cc4f2739c0db6c5552002e5ca9b567e2de3fb914629d03d5a6907480a34cd7deac881fc92889830b9155b64b72b02863e2f5abf3aedf38ca62f73e9cdc36d0a9830b8c72bf450fd235c78dc3f00cf321f09f3517d580fc4e1e2e26fb6ee30f85eabdf00696d879d052ce3b5077e086e7b105ccc5dc7c55374ee375c1efec2d9ad1dd5887eb429e755813b41b96d53a5fa1cf0081b63efe4156e7fbd29af92141cdf004924792b8af2f52a6da44bc4020c141025e155fed1e534a2903954a48b429597a2e011a6307d3d3d6ab338ded4018ee17c9cf10b6e688d394f774ee17077c0dd4c8c3a7f43997629895233f113119d648fb6394b1efd106f3186562680b94317dc070636cd8d4b6b82f4c9cd04477b9ba39f06b3ea0a3f8a569fd9c498c49a5c963d4d804973c00defde8cd93c5c478c277fbf235385ce3c42837ba838e3372330f35a659b8784c3b3dcf860cc8da23ba46f980ad8487fd2459e00bf66be6f2aa99cd6dd6aff98f1fd3ee3d3851e8faf00afbbc99084981d932a1f95c7c667b26f281ff8b28e144fe086b86db3303acf3b6ed02d52aec44ef72449e90dcf055bd05a21ff2eff7ed352bcb462b5fb8373cd09932d44094733c5cf2e71782fab917008bd33f37fe3b08eae66c1f430686bf58dd238714bc4354e9d6e3805fa9008ee15ae4ee8280ab18b3b42c8d6d2625314232f88bf1ba8ae0d7f6337398e3fb71de550f49897b53a3bbd1f469aa2b488a1e6ea382dbe829da06799c13780690714a3574d4ed88c0d67cef92d88dbd141dbea4f419421ed9622fc928bdf6a4fa4450b083914f41002b2117bc86f2590bd274fe0ae2b7ba7ff624998c079e1dad1ca95480859f94283556dfff2af74d3c10f6890b40babbbcb9da48e03095ba213629324a5c33b91463391a48f23b831e72dfa060aad9ca068b83270144556a77ff418c4ab2248263ee5c49361e1697f5b2b0611de038c4fbc49491e80fa5bffa8257fc0756c9788ce18c48d359dbf1b1ce3b3e83173a16df0b2c679c54c303c1d08a4a2bd2f27886a264808237650d706d1e586d247081f7650a7753078f9a722c87e3206e24db8809e61d5814e95af835d5e66128e7eeccf081e4b52077973001a2f18b84680de77f036e14f9a47e7b63adedc56e4e6a8860fe90816f74f3eda1ae08528986bf184fc6df4fa9caf8b7e86bea3004ff3b17d05a7d0bad3693161e944ba0a31907b2e0429e5405a430a83eb3c92f3957b5abad5a8f33aab7472cb1133de2539d4c6c9820cbe0d4e8762df6d3bd3a4ba61d51ccc6c26a1eb2b70a0f1fc95fba1d8f09d723f34724c2bc5b28bbb85bfb21a51806bf0eea5477c779abf176e638322a7355ee75e39d2fb205eaceb86de0add59f1bd8fa5ee56a2d7723b780347e91a8c47968279ae6e6250bee5687281bd9e0739129ae1d209ebdc9f7df38bd51ebcd8c4a111ee91f1e4381624fbcaa52db090940baaf78e2764957fbf91ed8b0222d4ed5581da502e633b9b4fea5b374f2ea317f94389ebf73497d8112fe7ada7e87920bdc4e4dfced007e62d8ce501dba0b1eeedbe2c6ffc0cbf20f21661ba6659404c6699dd1102e5395197c6aa0ebf1a4a9fab81191e54107f7b6f40052d4296d09fe471a315d144124e98ce6370f847c2bc4fdcf5fa8058acbb12d5c8d92b1634243ad551db9626b7c72abdeea1c9009caf7dad94b40d297f44fad154d252fbc3bac170ee54e92ef6545107ca0276bf75c8a4bbf2b5a388c22970781469ca12eca7a8d6763d2a947721160c9315b2f878d93251c6ab94808e935fc1a099e45c347f98d2a677138ed94a2827bc48e73116306837b6d315812b598c64c783162f5154aa51894cf37358b352485c28381ce9c38a726011df22e46d948fedc09b82d6886662dde75e38244c41b85f88696210a3bcce3682a9243c9e43eef7752e41a28df575c2b6b875b8224c91a9fb2b2174912d8779c463000ca01680d8cdfd0feb0a3329a4258ef7acb7faea380100228c13925d0301448c64ce8aa2dac1320cafbd1bd52584a70d0ba69792eb0f457b388d501f7ddc2d16364a28eb401d569dd2e7f8f7e14c16dfc494fab89a191d42ca8257c074a0424d5ff3f5c05064543144696eae65ade24da935ff1d6d153e5cffe42ce4c41f5539ea529d3d43f32d9da6dcb7b629adec14ca330bcfc871bba4323ddbd4af665e85fee4ea03000e047a59a9f30597e0b4cebe3bfc38d6e6326b9cf4dc9fe3598bd177bcf9698793a363b502934a8a6989b0559ac28981a7dc37ddc1e51c6d9434d88acb54c4b1801f15d7459be5f14e07d4b402e269aaaf666629e681687c912d1c3d38c8e7383267912df433f64617377ec3b3b664fa9dc56e9c028c63369e67fc6cecb56c5d4e5413c7275995fb1295d1a7ffbe570fa5e74b97f101cd73ca3e5116ef3762fccef345f28564e96b88ce2835f9296f56bcb26cb1396cd9ee7e90870133a3ea61242b9d14b8c94f5d7fe32dec944b95322ae058007a8748b3568e6beec3e32b484d0a255a4ca9de6809ed63355294232f44380dbae11c5a25b6e43556a611502467945c3acbc53efda93147e27e79f2a2c79dfaeae9e05c68566fbc3623809c478c8f80c870e9eed27ddf55c0eca027824f5cdec524f86d37d5c7a629f76e6d3d9d19885c2a6a7809ab924808bce09df6c49bad89eea1584ed494ec9ad447cb473dfd35496625a3ddea2b37ab6691cecfbb276e0d4195d3fd5c2d22912b6f31f7e23d538afc2f1aa2c121fe77b1cc2059435ce08171afe468787976294a89059a760329a2e792c48a61302f62e9a11bd41b4b2907a629c507ace70601b56f898613ef392f415516afd105a23365856825a359cf42c5c9de5a9066ba6469dffac3a409f8af116ced6228b72ea75b1f0c7f65f58199eb7e15605794bda541b1ef805062b203bd3e7539e8eb31761573a92c2bf6456f55995efc5d104eaaeac469aa570db04f355346e2c89d7a0558817fd0938ffd63ce32b34592d9029a662ee641d826e9f0d367be0a100e3b6837c044fa0d97c64b068708194eac7ed01227a4e89fd7fa24a2f59e03291ca432339d36d8feac48ac890bd676902a7349c95e3564cef99ec08541d386e02e456e3f54ff8bccba7f65f3e58310be3dda8b9930e6c0fd5b7f5f71dbe8dc8355945cc03ec82c4be3bafec49ccb9b169f7a98d50c1ac40acb0531a68807d7a4c62919624d1415627e27aa578135929768696fe31a3c85e787ff53f851e9141dc415e8be99efdc15fd7a0ad71e6224b75517dba4c7bd93eb2560bc757acde89c1c7f9d5b632df23e6656e389c51223f67b8e6167b63ccf52aadb503bca86c1ac1b0be6e78046b5e795266b3f9b3475a1fb835018f34e6093f1356b450f79392f75995b21442fa0cb2b86ae2214c631b6819c3aec452bb3be26629ff9ad791730faea2ad35afe6446b4cf70a430bbc75a3ba43e9050d6cea8de3d652007475358e470f42c14be4ce0a8c9c73a646a81e815a602e8cc65150a430066977653ef6e073ccc509eaec74cd0a2ae3a0a2ce24576b236c5ff926b881f73a76d419b98791c335463f32c193a823c7f9e15a679d4c0809714e22987e7a18c2a66e6ca727263334334eb49cc55db0d772923f4f6b244c44a0543b5af5880642c3fa9f935f1c773842039b7d9112d3e5346014212a5866988178d7e3b0345aed50f5ac9746e79aa10fe8cee2c79caa22c923e2507e7529dc51482c7c9dbfd9e534b47f913a6e6079494e5bffeb6af5ab33e52fc0675523f1313b0f1e7d716faaeaa321e939f0192c17775e22d907a80a118c7b19617fabe4970f04ad8b71c02e6ae5d8c00987437b2c8a4c31d1c41d94c18dd210e7ee14cc20295b65eb67ddc99e4cb312d2e71af9256933d97db21aaba9922475a955dda19e8a5cc2414abe4c52a2ebe441dbd8112a035bb7b67f5fda389221b77d3bf15c2b5ba32fe07c76602528e93ef6a4a5e28b80b5ab3de8b5047a394558fc6e3a140c1355da0627d9f9dae6c7f6a8d6954799b03b70bf8fa91c217396d816701540d2ddd7b73585142b9dd1fa40c9fbcdebd16a3e2216f24fd940dc23942150e08e56506e7ded5031d2cde939db39dfd878df471c404ac6711aa7bcbf0f70cd7de7f77928af48b4396310f13d440ec2bd17d31c3d6c66d4673a009e7996ede9406e67c14c235e2cfbd5590ebde370397323793d3ca2d64e2c891fe9b121243fb08e26b3a20cc4f3b026b84bc8a36bf3542dc3e3c499f092a8a82adc235071634d9551f05264332b3e7e5a68fe8f784fd055bd8bf563411aaba2013e4ca1fc2bfed54e48db7fb956a476a5b375618977c7c2a79ccfc486aae29283c8e54a771efe38925cc974c3324f300826cabdc7a08014f780f649f954097fbbe50982d1c974bb6d982ec40b04c899a61802afff79f63e210480a6eeea59f7701010177e7ea9d3edf62ff6863b31612fef07b670b7c2de1067c57344ae1785760db2f1bc9e1bbbae9d873f5c9712d83dad4c047598807f489255324643be5b28fdd5bb314e9069ee74e37cb76b486fe3c0395f100ef9b5b89fe86124e68eb0164e587bc496ee3e28a874d41f56f9cedc67a5e241d0f8ef802cc785243ac29a298fe5ce003bdec2c98b2cb84bddaa1a2161add0ee7d5734b27cd25b819e9dfe0523b91e2524220456f1c62565fe222b5d53157fefda2d574e93df5787295afb78507930dd5ad7136ed2ad9e627ed8ab5ac75f4517b4ed3de2dc9dcd00e6cebb43503896a7493ef86b5e7258a7485fa714a48443b318e2202aca8efe15e0a7b9464d5c73fc7c3ddc0bd8fd596f230d66f5fed1ee49d4c2395417e3a9f3c7cd7a315b5d56e5aa52dd588dd9d77389aba1c9ce74df8dbe03d6e32c23a64cc111334c2ef2d5e508cae6e355a4dff58a0d508fdd0ff0cb40143c6afd3fcd6dfdff2719b51de8ee114a8003eeacca24281073cc9334e86fa08867242b3a0b06dd1e89b8a4cab358687058a35229b3b6c5d586155a0d8c339a8c3807e812b71921861d7b5a0b4c130a0c2540a74ea1e74465ca5fb2df25cd2767706d3c10a42572ae34b825e4912e95cfa55a2f2274b2befeca63f40364022c05175cffb5452275cc9913e294b538eca4ee8e1ef4ac6182b13b61cdda1a2df53b2d705f3a5f4eb4ee44da9a04d028ebc6d481eb269121fbaa1c91af0d60649110253cff4489db086bdf3e3954de076ae6dd77ddaee112462a20d8b89b27b03a0463bafe5f23e1b38baf60121e4425bef0de6df02cb754eb93513bf12618b63cabab768f0e2e280f3f1244c2dc0d0297b7d25799f941480c0a18290fe029a202607dd92ca2dc0e7e4d94eab3ea7efa04eda6309f07aad3cc02544d4fec855eadcc5e0f264ca3c9d2bba096f039ec1fb8441bdc0772f13b69577b58c880865da103e9c17e709a6b1546581a395b08a4bc782d817fd20e2325ae27babbf20ff3126111e2e3f8d01fb8554858dddd95c1a2f607527c07d6430f4fcaaca6ea2ac23eb45693b64200de58636ca4c75567f1c75353146678e3d0c1a40bfcd6caba0e3ab7513d9d3f4d62cace41d98acbb4d060029d4c9528e33be99423bd92bdebc65cdef6882fec706676043f7ffd50aceba3c9d84caa0e053a24397a05771d341fb77c75b784ef23d6178c4aa60b35c97dfcf428398c489d629f5c70dd316752502b3a80d67bc6bcf3164fb3ea8e3ac7fcc064b8a2ebadcd00bd6a7d8f9fdc54903ffa3376379e0eec71d17d63b2aad824261f72c8cd31e2fcc6b74b3f63ff2c858f65aeba87da9b47764f28f77bbd8b4743b382aba5fdbc0570aa3779ca23402a1726417adc9d68e8e5caeb80ab31cee684aebb32fcea2d2c20beef4056f876b081b6ca076338289841bddd4b08d83c0e98e36c1daf64bffdf9006be6b110443760ee01e6de42e100075c69f83a10bc367ef1c09d1315b4fca26fb8e9c29e577df1e314556d198c43d967982e7efee14e41e62f192244fc07cdbe7ca3f5add4fda9a905b191dadd702e92ed4114d570ed24ede5f3634b7f4f6894e95d7bbbb8fcbb7160fbc9921506c6c0d19b6c3b5b40595cfa452f39bbaf38d328a2ca8de92afe240810aa6ef2c9c5e56e1100421d129eb456d0647e113efcce45700eb0990fe966cb908f4398a0be4018ed41df8b38556afef1f3286fc1c3f330ab973159f052a7d492a6cff9f874781b7ff4ac987f8e0368a6943e6df4bac19985a61140f5aea7d24caf49a8d4d73950bea8a46108e5868b85071addd4d4f2f7d90142c7653f8aa1a1fede3dc645028f30b44c83f20f2caa5d375c65e63452ba02d362c9e3b37d0b958a0ae43fad39bca4b80ae1f16a1a7b32e8831704188347b74f5264c772bfb74b619feec66ae5c159f0704e3f7d2b2dbd3a327baa88c4f8e3ca96312236fd829ec793543ab691e0cd1ce3be5717d47f7f8caeb28aa875b2f47b316a2a11e004907e2ce72de8f1527995ca8ea86f6cd94e5325ed4f97b421873824c2230710889eb8b18b237fed31963f23ece324a19e7cea8789cd4c473f582d3dadbacc5d77da36d791fa241bc68e00d9237743a6827c48246a151c364acc352917dfa24d0b1e72f15bcc57a5ea38c4733e17fafdf2962b5b634f4a243aa5aac6f99c936bad7703f3d47c72e0084c5655b850627179dd4810d9b0fb2df815d22bbb1559d19e51fec3a4290a9fb4ada71db0e59d7be5fbd7dc5f41aebf464c92ad7f24781302a5a55570a5b26c31f24c4013a52474fb5832718cb4c814522e6e6efed809c960dc79a8bf071a3a79f18f991f63e626950867f3882de112bd0051a209d990c2fa19e985deb06af471a893130f1b188f51e1aaa7565feffe46014efaa4ae66eaacf5842b6cb109dacaaa4c296af8814564a1d266fbe0682fde4924d8d0a72597570c2197b64d03b6e812ba51ae54a2a8733d17fba9802a78448d9b910519b0d42804841eee23b2c9cf97da51f4de2445044a54f8ad6d53e08bb002c7b5533dd501e5217072355da844e4e28a54f965f0b8ffcd2b6cbcdd744260c09cb62e1955d1ea5776a25ea23a49f99087d8b36bb877acc314683bb2ca505b2e0157331f54466f96a8526c5829a501e51ab6598caf8433273fd978b2e905318ff413013d189497763b427fcde8c123ece7450a7a96efaaa377c41f1a5961a5a3b88b4143f95ef703c71c337e9aa71b47c28d6418b95e9bfbff7bc68f0e4186d30381541baa9ee79102386294b4134b9ab4a41fcfef75475ecb75c6cfda90b41d273f86c2aae67b8c3becb226f5d4ff4ff2d9ec2e8177fe7aef630dbf180fad41fdbbe40a0bc2807cf10e2072b87505bb8eff483ca31de6b70fcc4a273c1bc93e1b6194f34594af79a9c34f95399c73bd1bf4882cabb4668e906c78eed479cfd897083252bdcc5af55c992130d93012f29b2af67881d6b5e3d3b0797a978e24a17669d4dfe6722a712079f01068b9e9d7e607463e2624ac9d146487f8eaa30a8ccd2438f127129c1e1cd4e6fc62076605c364049129871ec5912a0f7ea32d304e9e0ee4891d13c2a66b5399f7b6abe3a50ff36209ebb23ccabb6181b1be0c6e5b108e6329fe2c6359e6ae0bbcd3bea685b41bfec8c4b178e47d43dfc9c180840f664a9675b36774f2a0d9a6dd75ccf0282cce96a42388088058140d8e12a345b91213db7357409cb79d60b7ccb485c96d0daab7e57b483a57f4afbbebfbf17a9ab684fe59ebaba9c54a9d1cc9ae0a8766c0ae1757b6a3d0d15fe8a2bcbdf27e18dd0e48afa61800c27c2350ce92b61af27b830efef456ed850138387ed2c50b5c6deb4be299f87e8affafa20ffc27bc17ab6c9b60c2dfde75f5abdebb0c84fe1f8ed6bc4ed120273d79e8ca9fb3315dfaa940df96dcc4f8370e49caace52c8aadcfa709419dd88fb0a2bccbb59777f474aa1513f0c7a073288d94e7ff7a87d92cf06cfae5ca8c886bfd117f3af6927fb6fb51f8e772353989945f9d4bd4b5c9d819d2ff931389e8030eeda2f405324986086f926ab400698dbb5fc4130546335a774038f46284742990b6df628bd057ce264d452b4a48f61cf43721ba989fb1f2c590eba016351003dafbb637ba3101f2dd8068c930f73530079eb806b9dd904e1b43bd2d30f556436f8dd0babf418aca8d959ee5f5434bb8c54a72d979690d91b0e02fd727ad60a68fac4f0ed3086219d7b6e91e74b730a511050aee28b2c540441172f8cba3a51d5697814c53c724630d698b073cf539892664a0911588b73441b2553ed579e2e61cbe721b9bc3c03c8257b3972cde0a8837014a671d12e1c483e77ce36792353855edbdb256fef952edb90192b356977ea93b7d1b5f9d92990d01f3532e1c09a92696201371106755fb56de3c0ecc9056c3f96981bcd1ae07acac4994d9157d277ddeddc696f6a22095401df5592c6d7ad9b2bfbebe425e6b7fe36bd0e418fb4960ce6d07fee9300079f82dfed17d1f92a0b6d3f0df6e83b2a978fffa9fb5ed8b1f39eaa99aeec32684bfcffdb76b184297b61322ed0603f6b638877b6c6d790f9d759204e1058546fdf7a7d6eb7c5bba5755a4087f5d7cb85515ebb04e46945fea1ed7c6e8e302f6db417e034980c80c88f5ea66a2681b3ffc22c60a5fd8f90cabf046ba1722a7ca484693b49ae3075df422742e6bbbbafe1d405a35c4858a338bf297b2d2990b715732b158a39746a4792edbd50119122c24237c1c1eb8d01f9edd4ede39cf145361900038e0957a64a73613d164ed08f0af15469eb867a181e62ba8f434e805df2823134fc1bcf67208b7007411527a0330efc2be541ad4a21a4ece405f4a7f4a8810785a0c86b6773bb180ba552c6af260f677c4c2fb201a563cdf5b06f37e8729959b17725ae9117c5a28f6397127e7b6b7ab4774454b554b6cda550a94cb91302432abdf6b9deb022bde4cea3fd3732f55289a7189971a9d1f64582a8fbd8f3602697b72d2b0517a3f602d56329dd8cd3ea1ae9d2fcdec3ded2a5cff08f35e07cb525819a945e7e73022cb53e15728b3f5d75756e67b2da9379897a3594887f983262bc5275b3d35d3951e010dd7fb2420625d4b64aa56f86301c7388d2ffae7d19029b5e5499db3d0c99905bbaac3dfb24887a1c151cb7955bb02e84108b41f967dac39b4f05f0336491816fd9c70924a5953c629b693bf235cf5f2b8a7dc2057dd6edc94d04963cb1ea6da6a7a1afd7346e5600899c8db1ca79d2113565aee0b54c7e261a559ba9143448399375980013dd91f3c09179ea1bc057cdf89cbece709376494b68b39954976c85233bef0275973d5393aa311427b6d38e595e4be002f920d0b0f41a950acccdfa72080f5f7ddfa23ef03f67edbcfb700b1956b3b1a09e37efd27ba086b461a1bd8539957a041940c80e3196c6a0b594152b134041e999299b921b57e754efbbd8de7e8cee95f18df07cf4e852333f8c5839ade5df046f8d47facf9d86e6acb8b10059906eba974b86b601b107da9f235d8f8d9bf95943f41f6102f4da23e24650076caf185e41b0043d2e22b833adbdd049e15a6f997da98123799625d66403b268959e19d552388a2b3feb8bd04b7cffbb5cbdc19117c57ad8a7a5bfcbdef0ae22698550d740db1d298afb996818ef32c9e769d85b2c797dd7bf0641eb179f378dc736693d3da07096753604d84786542cd9c79023690a89afbc56010ee16d3a15d2c7bbe3952ec7fe67f459360413148b507e6c5babeaef95c5da4c5e80d956c30c823e66e705a5bd310d1da8a227c45caf94e3a24089e58ece2240a78fcc2fdbb37306a12281c43dcdbe189a580776d92ac8d43588dbb04ea4552f8df3707ca378f071369d6e06437d47a845f733e1fb69f0e83620f8831e8833ace309d642e3401959a33175e9a6c71317ef01d2bcb46a7c9a7876fe91a29a8f52ccc25ef6e5cc863ad38aec2ebd722d06f95d0b48d5516e616f61b4b2e7af65a6adf7bfdeed45f16c1f17c05617853aae94debec4a5f296350d1ff500a58d39afd28e2e99ad9e87cd50871d37e492739f05651c89e180e7eb63d4248951dc15327bda7a6dd57607a1901eff8fa4eba4970623aca6b302ac507743b854123d592efd72b9b6d8b26f33c11e70799f6f0dd7647f2e268d46ccf928456bf9bc9c1eacbb1a25c31219b33eb381a698998a3ff19b66baecf1923a47072342b617e5a40ff778f1998dda4f13ab2fa0ea7ef61f872bc79b21ed295e98fdd3b298d2d82956fb90b49c67b991e10e660b99c7c56bab032d834bf5a1bd15a24758cd0651afcf95f8faafeafcbd03a9240f7c400eb7c3f89a910d7d8d2837c537021480f51a51feeebff6fe4693e3a9bd19aff9cb98cd4231abc948ef9652592f6babf07d0b6efb51b4f37be922d0c6516d745480749537d8b3b0e36aed7a31904b5f0399671e73bac2f7c2880096f3b3d90c2189e614e75ba0d0c9574ef75545b878a7de4d82f7fa8ba28d366ad189c2f55bdcf91b8358e3b92bbc9242438d0987a3a7f1804be41e0d7b32a77b6a2c07db5141a870f42f60308dd9c4808713830d79aff65eddd063f1e21c3a9dfe6effdeeab7a24224e42b6a36d8b44c218987b0ed48d91091e19a6791589120ffcc2668d97c4b583e3f0c1de43fecaf5bb7859b1a3b9bebaee05ed728e91264dd7b4a46d6016534d347d7219aaa95ca57e6a45c26e3ae39cff632292374581a51105dab3be18c22f926b5ac8fcc506bab7014600b0a305f9cae6a178f38ae4bd17c5cdc595026ae62ed3def640a522460886ec9871a1a68995d5c095c7412245ad4cfb1e5db86b6f82aa51cffab4cddd0cde58de14e2c76a94509dc15b30986834c9373a905d44bf0858ba52c73571afb0b3cb0778ecef68a7e86de8511201c2594711a17a2028b376adc214374a9e7eb3a9c0a2bcd3f6c5f0cc7a5768cf5969327f9ff6114afc32c08baa30da24b3031deee66b80a3e1402ee11abb27e903599ac75eed30e60fd9c50c73d716d0eceb01ed7fb7666b47c6715691b69d76667edb697f7e2f329e6496bd5cd0d64b55d5ad1a807e1942bd41e2cd27f169c42d5a3e3f7ed520e18c4aa65dcb91cc810fdbbf54f507a0f275459e64fb43a50020b685cb219f9f1f108067569a571f53681c54aa1b7738a7e3aab15053a8e967374d45c88fd51671823af5c16ad4e1d5a2fb0772af6e144e920d0b5012dab927ee83b9abf183cf5b536c52447e8c11a2bd45723e6dec04b83e4103cdd92c96228d4bf81ad7216b302812acec93fa9c00b49cdf6d521f5cf19ca7c15e498bdb46240415c3afc61ccb42c3a3ff05b0fecb0e5db3f1a97baa40628b2d1477b0f0b8a05171617f37a990746e62e0c495a13e3ccd81c862ff451894443e81249829da1bdb3fe703421a9f473602b969fd03c23509a52dd1e9bfe51f1b5cb860658e4f8006f321f26a06fcb56e9c32bd8a4d57494b13c134759c5531c36386dc9ba65815abf1225c2b1390255e3eece16e596ee633c4979694fe7e47e8ac2a5025ef33af9d6d380bd1261a6f32dd8cb5339d2f9abf74a284933ef4f7e08128589e2bf76ae87d7d8a7e808065e804d7d63218c4a08341d4c90d4c93cb754b749b25a14c16b876c336bb8054be08e2311f8a65da6ebd28b556ddc8bf98ccc74250975ca8f60f519635058716d160e28d7fe51d04a755602a069a9e909eb22ed31d373965f8b0ded91e197681eac49c2566372f39a3bd4323021daedce399ed6876e64d811d7ebea444b222f75a42186099d719130b4bcc5782cf86ec2ced391f81c37dfe7e9c2713aa9225dfacb5269e2c2af75e2aaa34f55587a3854f3865a7bf274a66f3eb7a694df43914160357385530ac196f3c10371042e16563e85af5842dda4f7c9c6f09bc86d5ef6cbee3f8f03fe22930362728178128b692fa728404243c471e3b7e776dfab6b789b9dcad14cc5fa85043eeab60bd665817bb8ff1810db74a97ae2409fcc593260830ae919d458628451a3be560f38ad9ca7643e6c7f69f43eb55aa1d3aa966c1de34f5f3ade4817ca4062c5ba69eea8592d0a0b41cbb674dea0f386a1123e921cc560e12e1afd2492ad984f1cc33e6e97886d6853b594c03a5e382034e5b00e43893338b5fd92e4c8240cdf62ce66c71f6cf6054837c84c435a068cd58d2865ffb12791672f4f1cb9081dec5c3c0977cb6b952172f42ab37e8115ccce0a9d74a6a35e28b2a252eb6ecbeb6f961bf5277ef50557301a373f6b9891986899f3ff26430ab33ff4edc5aa9c7ee195dce338f42ca5155c1257969b90b731bfe1791d8c8bae5452ace074cf527e071305e1c44f4a2f8019fa94fd0412946dd0fe46ccebfe408ac8529e0fa527761e53c881470bbfcc8c9f9ae4649309eeda107b80f94d69cdedbd9d23f0c33826a47e232c260f440c2550297356e6a56732e2acbaa9a5b938c4f509deb44350e31af59e102bfefb7b2c3dd2bc069e122ec8583b799934ae7c0c3d5f218dbc461e35e19c6b21f434b921deeb7103d4951cd35a2d5121b44118e6262aa137bbd5505f88a5f2838ee421f4f542dab2b0c811c1b8f976b5bb9e5ac77ea4a4f402c7bf9510b27f94fa92f8d66dd7ae57bb61009e9da988fd1ac23465577f1e11295fd343fa26ab6c9d0c31cc0daa1c8efcb1a8227bc184e14562a7792db9b920232693d2da5908289334032a75cdfc41563eeda4c93116b2742c7b5dd720430c2493a52f46e4e47b56557bcd6224831e55c97581f3ec9595307a276b0bc8e51f1f18b5f4ada446fc07667c1d4f998b0260b8ef804c0282c5f7a2876b5813e75686e0834a27bcfb8169b530b3f9e5184337dce2491b624ec464e4b3cc46107d59cce9cd608dd656862eb5d457a48e977e4b5c0e83e16f56cc23ccf0cad32ef7436a27959796a343199ded30db9fb17efb122c8c4b2a5523c2a8af1983fe9762cc4460c838e21ca891f13bdc17eecad495f5cc960f4b12f0191db4ce2ab8565779adab2035c64eec1204b1a7807374e2e35abd5b7a9eeb25db25437c27abcfc7edb7b3faa14bb65daadc490c3a65386dbdeef4a9587f2c51af64909883decf2e8d2341075c7850b662dbc88cfc29aae45ea250cd785bf8584974a1e05e1c401b1a7f610bd4efc5fde3e3c9232d17a2a06349fbe7924a4c7b73f21a556bbc4d54e0b4301f5d920e6bd2f910d23a30f7e1498ce784b415ecb88025007f4c9d418727e8beb6c4454355cdb05b94c58f0cc4a51afa384dd005f6e3b5a845182ee70e4e7c4a1f9d420458f385ba53e5c5631441edb4aceabe8db57c481d2f6a705f0b40e8d227b337212d16724f2f064577edea093f7cfee8cff2c59f77c51b59655d5941ac379a87fb1d17992520172b057696f29937fe232c752063719bec100ad4b9899e3a46654e22d483f45e182e595d07637a5a3ad0b4fb44e6a6be8616a5354a9fc0dc442c463457ad0f6c1f4e0ac81127b8be39505e6a4446b7d1fc80243bff79c78ccc7bddfb2ff3596a93deec2529c4e4bdc15eba656b30fdab16fb9d407d2b5d0cfc8cd23458ee5ab06eb1198afdf6b1d3622b5d5a8983aad352f267064c0a3875ee9fc2cd39d96318ecf262120f862b906682b7e8518d3e075598c0d74771b11de3fb39a5f81170c66a5671dcecc076b90105d9aa45ccc69e9ffe54ab50b838f8026684a07e763dcf34a355f54db1c1efc781354d497a32ce152320a979df2f030e034f244661a828909e91fa356d23bc0153a5759c48385632c46e2a5af9d8f892641b77393b9d755387c0dcb8869bb39f1cff5ca957722909911dde6c6fa9953a12239517bbfa1510055d6adc4691cb9665a502628af41550f6518c6f3e43a42a6be11b8b2b910d5bcce08582e32acf62ab688edcc7841959f50500c38440802ca669d7b6b9657f5d0a3edf118e0be832a95477be4dde6675899bc44c4bd88a79d01458bbc07d9464fd48d6db461e25629c18d4539c907d5ca5d777070994cdcdabaa45be4bb031c2a1e4def4367b90aa2103d17888df739d3adb36d356fdf4531ff0c92de85b64206b460e0461f58cd69d4186def207aa5c7fb7a38ba003fd23f9d0bf4a0aba8e28cf4ebfbb9fa24d07f783974fc3b86571e93296c821464e1891926b37322e5c48882abb9d57a82fa622f8c69a143799e083c03b8206c20be4e75a95dc380da38b63c9215cde586031f9333b1007bef21dc57c388d223d3f86ac9554e278f8d92ad227910d71d6511b551010a2e4715429fad7d7c8f4e2de3723addc5bfc09965065e037ffb5ce5fa470c76416e2bedf9a2241a145931e68a87b534f4e985fc00e5a5283dd9c75a24045422f36729f50c53ab2382880cb0a7684ce5aa75ddfd266160715384371f3dc3679bc3e5f65d7c4771317a5ac9635ade3378e699b1bb769e35d422ba6bede5d5c568d98387465264d4cdcc2f98e51b2beec15977d4a45ba60b7ddf4b5ce9a7d0010fde6a25f23f8962d1fb123fe031c03c65236c738fdaaef0545e3575b82b224db4fccdac1f45d9d42647ba7b46fe218308ce9d4941b5fb97543b9cedcb17094600decdd81a565913ae1eebc4ea0d08bc8d353e1746a1d4ddcfadd6d083816ced1c0960434c80749f4209fe91fe6621c9a9680efddfe15af515fc350646c72dda873aa718189a0999c428a1daccbc1035d2d2c6d313a5dd2c2640f2b55c6bf0684674ce2699546bc823a6a7a77f0149d5eea99e8ad2f0b8f98aa904433f47082d7389c8d7df8e99d3128933c39aa0957d19e5e3ae6b2f9246d3ce696fe31bf6c9e4885318f72d3ec8b2b0fa1b8f2cdd74dcf262a6219817bfba626273c00d38693499d94fecc859e44d1af999bae844560cfa7aa052e48c570883f4d034c96163421ab5d47f2fad0e8ce804ab26965f42c787d18fef99a5c51cef02f0b6bd1b24fa979683df9919d46af3a12c0ca354d959ead952a7103474599e809b1738e5f64e499fb09f744125b5f534832bae8480a71b1ff71c75da3abede185623974ee1f06526aa3289f3e9ef6e34a432619bd27b2d3d88ab066a149f9e6499529bfc12ca24ab2c1a4bf5aa4d46b696f41ce53ba9d052d6e97e733de596558920952c593f1b47307343e78b11dab2df1ff7393990269ad8b069b60cc0402181c18ba24f01f7815dc7b57b682d08f16014176ec95278967b83be5ef8e473b9149822d2444889543525c5347c764efa7e2103797bacf0b80dd721f5ce8d099862e5e312070fc2281213f2e30d955742d966f38c10619a7b3a255a585174a3225b4ad7fcbf31c8189c0b124d8963374966b9d1989fd881ee38178042b7c1c08caf2aa4c24f1175433324bdac8ed9141a22aa8a59b8c8a789d18a6baf149e5aca87a0733a140b7c6e834e1f87111bd08c87662e63e221e009eb9edd631343afedeb663312d2c69ea16b14437b064a0f1c5c74ef72381db625b694c698a7dfbd2d01a44e11ff75a7055af1c7f4a1d73f557c4f58172321ed700a9dab8efe3f7368289527d06b2c954143b9bdc1965f83227c759010f9657963eb26209e79e768e60ec0fe14c59ed2dc6ffe9eef77815b4df98743b40e575c3ee8b1e9538bc71bfdd81508ba861c0070e0f12ef6e5f45a031b5a32172ececf8d14a8e2d87e30139ff15d22b61574502e33e89d25206716e25308829d6d6aeb5114c5c75747a97d3903a4031c8b4089b426719c768c937eef0f0d1619406962757f8a5ea096363d6429866e82f753a6d25a3055bb0e52e2bba1814cdcf832cfc19f5afd298a8e29ebffd5ca219c4f711b934713747ceecbc98a65fddc5dbff86e94b6999b194c59a3838773bec0497e5050fd3f504774e23329d29908566d1f827cbd288badb383c236a80640aba5cc69d5ecde96d40b146efa0668d1ca4bc5d9533c40135d5726c4a6c0ccce716ac91c4e969049db27a7baa2d39271e969fd49e678388f3def7b4c8b4ccb725493ce645825f53a927839512a1bc02a3149b06f6d56d1a261e9b042d8b983358dc8f74de797d9ef6a497cf9726f2ab4fe85852fdc2e5d037431a427ae096c36ca4d4f38f5dbb8c5cb4ccd2c581df4f2dc96157a5a28ce71600961d944e354a0e1aef3085f213925752c7f0c2e0ffba9c1892a08fb53a8f47d53e239fe8f561acdcf24e94276bee4708711de892219ff1567157e056e09281504c6ba199b1c6aa6a4fcea95b049a80434053ee18a475006f35ed5b1497d72b79a2f4a19f851adf3122a407ffa5da99672b8fb72df5161cda6104766426f5a33ac0c2d62db96e0c3e3b6987eeaa7b180f3ab9d7eb52fe02ea716ef8267d2648ef8282b1b4af62d4ae068ce4f21edf6b1c2cf2490cdbea738ca13da977d273bbfd071ec05190b7fc912037a0b9ebf8be56daf52f77b305ed43f7050954abd87a3146dedd1824e7a2d40655a2c962397f601ea4bd065a083e16340297b776c18482e8badb6bf298db22781f565652e5e7b2e3dd6f13f695b5ef10532736dd72dfffb7f78f9bc13fd242bf34249fffda6dc0880557f1002139bd70ba7cdb19441435f9a3c6cdc0dc2a13f2fb4cc45576dc70d14a95a752720905cda5a5e439e3e7f7d9c5785176f2abe0ef057d14fbba5f37ed32c96739aec44375909cc02019ca421b8f90d90b29facea6628abad257e6af9248bfcf62db0e51c91b026ed76fdc987d070f8b50827a1e54ffa24417f6a55986565106fe14eb5d9705480929cf1aef94c267224fd86c97417b155e8733c712ca454c6a586016e31ac67f6f5043d65aa1a33751e1074e53c90fd8f4c52833dc024dc1947f69adc5abc71ab798a2d4f0538e99d1ed2a95ed392a65ed83933e1f0409c5165947e9224473bcc211c2162eec5e15a1ef37397603d34992147026574e0ee661fa16918c4afc062e35c2d80051c8aed307ef9fbc273ce4f02212e34dd5bfff2cfd3961c21a931a646432ca29000f17d6c57504101f58066c6ba83d5014c97511fb4702097076ad13414ca3c8110ff0171e6400d668d16be995de11b48afd44874ccc8188922c131bd0fbb5eee205d21a260413307e04b70d6c83a4cfe60277b27f7b2c8a0efd4ebdd610a5b17a53bbef75c315c260fb5d29d144241eb8c36747467592827d68664f613ae8d6f83afb0e907d8fce918d4888f406c40f4c4a13bbf1efc8db46f2bbc166b699e191f86686de96a8307172ca3542a905edeeb40673c25b14ad802fe5c44549f6507d8043b30e0a3e33016af7d336a840cba2ce24114fe30d5b8dc0de2e33037e494d272b6397f79940f58228fd7f06c1eaed8298e786196d5ded9ee62e34725e42ba22b92d49ea1ecb4cbacdf6ec3f49ed2bd231b338913ed1ec3b9f24556e8ee315373e9fdb990269ec886677f666e7901e2f6a71e2220a37e804a92634da853405eed0ea2ea913fcdebe1e0eb3f426cec08d7288606d89deab516a4c8b93d7b3ce69debc4b9acc9be915ae07cba5c8599b2050b0b6c6d555ecd583cd9cd3650b33e1522ddacd3a950b0937b0b102c02f9c4dae9f301bc9c4893d17988f60f430ad9070766a7459bb5984fc7615ebba32382aa143a06e8e632fd1d72d19c6a08f405255e81b529907699e7a4887067ced66969538557ef4100c28eb5e9db9689078cc1b8198e62f1f097d4152871cdad1829148d6584dedb6497bbdeab964373776887b804187f98f38fdd52479a348759c06d36985038ef85c0a167a855e350e420bd79b408d9fffb777182de53d5ef1c3dbac1d033b39f8d90addfc3af30755d1ad39e318005952daa024bf6b0614dde41615ce201b3fd9616fe24d245d180f03325f9ba5871ddd6919b2c99c9e0284fbe6cd7618739c5890a84083cc10719dcb37133110604e556dca333b30c9f5179d4b008f0423b7364e0a3129f23dd9a457f79a5fe58720455579a7bcf7e35d28c6f1681363b4b5c28e38263c3cb7a0a088bb38558af05bfd1b33ad7f108a389ce3bc7a48ee46c6e17bd310d91737c95f7c9f46b69943a146ae60c4985f87ca1ad4c8c7dbb4e5c117e6a20d62b311de5c780a7f456d8b598d4f2732d5b2df66f8fe71c6ff7ec7d3f720ffa7ec328cf65d2d4b4d7c8275750b628ab56080fc9403684f386ccc1d9179f5a6c397643462268eb0a306a84a10825155d95805586df5063bc95aae0eb234f187005730960e5f3cbdc44ab8b568f17160f109ae2bd11ea70723b4040f7929eca0852d3235f8f7dc689ce70b53ac2f25d01efd5d1b7ef466c313d5f96bd7cfab875b37d496b778eb415e16a8d7467e315de1d7e58b1731166710bad42643cb805b08c36ae8a1fbfd845af6f1a4a0f8ea373079d0cf41fd2cab15e908dcb8451f3020ac38e29660605e4d983a38a3ddaeb001ca708ce259f0365fa95565e5dac0effe34d35b5b65ae1038b1a47300f523ad872f8c6e12ba20c6673d6d956d3992ba6e2a42b8ab47e8c7e910fd3f82deca199c22c209ff39aa5994cdb6c46c49304f9be1db93b78653e20f12b3c598298cb464e682b3ba8c1f24a036e079b901008e7c9e31a89f4d38b3e0e4c62f73b418ba970923c8d19e1644be36c740be5f087b655546bccc8c07582fd4d2762f0517822f8e2a604ab5d9f61280ccdaca033e766ed01a9b6df339c492c96e08856aa9c1d4f9d933dee0fd2ea63c39b1c4a0dca3b88c9e76c1eaf932813d472948093a36e80bc3a1e243b665a095be30f76bba2346217f914e1ec702e67585477f94f5d85d6d1bf519fe393887d1033c2dab5e00526566fb8004d75e8c1687c427f8a614b56a3bd67ba26ca348574a1c799336cad72f2d78593b9eb4f836cc1ce2f093814f106133067a001749c267ffd67bee155205ba3013ec312e8651a55f0d64dfc6565dc2ece9dd5b3ab91425dd2e7fa7cb5e6008a669f05f56e5a4c28391a3090508e8d4965e2b430ddd7760f01cdf96ff1861dcdaaa86cc934fc39bf1939469da5aa07744ed606923be6</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>ACM学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL rope 可持久化平衡树 (可持久化数组)</title>
    <url>/2019/10/02/C-STL-rope-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B3%E8%A1%A1%E6%A0%91-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>官方文档好像 GG 了。</p>
<p>rope 不属于标准 STL，属于扩展 STL，来自 pb_ds 库 (Policy-Based Data Structures)。</p>
<a id="more"></a>
<p>基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;  // 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;  <span class="comment">// 注意名称空间</span></span><br><span class="line"></span><br><span class="line">rope&lt;<span class="keyword">int</span>&gt; rp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rp.push_back(x); <span class="comment">// 在末尾插入 x</span></span><br><span class="line">    rp.insert(pos, x); <span class="comment">// 在 pos 处插入 x</span></span><br><span class="line">    rp.erase(pos, x); <span class="comment">// 在 pos 处删除 x 个元素</span></span><br><span class="line">    rp.length(); <span class="comment">// 返回 rp 的大小</span></span><br><span class="line">    rp.size(); <span class="comment">// 同上</span></span><br><span class="line">    rp.replace(pos, x); <span class="comment">// 将 pos 处的元素替换成 x</span></span><br><span class="line">    rp.substr(pos, x); <span class="comment">// 从 pos 处开始提取 x 个元素</span></span><br><span class="line">    rp.copy(pos, x, s); <span class="comment">// 从 pos 处开始复制 x 个元素到 s 中</span></span><br><span class="line">    rp[x]; <span class="comment">// 访问第 x 个元素</span></span><br><span class="line">    rp.at(x); <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rope 内部是块状链表实现的，黑科技是支持 $O(1)$ 复制，而且不会空间爆炸 (rope 是平衡树，拷贝时只拷贝根节点就行)。因此可以用来做可持久化数组。</p>
<p>拷贝历史版本的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rope&lt;<span class="keyword">int</span>&gt; *his[<span class="number">100000</span>];</span><br><span class="line">his[i] = <span class="keyword">new</span> rope&lt;<span class="keyword">int</span>&gt; (*his[i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>缺点是常数大 (C++ STL 的通病)。</p>
<p>还有一个叫 crope 的东西，crope 即 rope<char>，可以用 cin/cout 直接输入输出，常用于字符串操作。</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>ACM学习</tag>
        <tag>数据结构</tag>
        <tag>可持久化平衡树</tag>
        <tag>可持久化数组</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ bitset的使用</title>
    <url>/2019/11/23/C-bitset%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>bitset 一般代替 bool 数组使用，常用于优化空间，因为 bitset 中一个元素只占 1 bit。</p>
<a id="more"></a>
<p>bitset 的大小在定义使就需要确定。如果想要不定长的 bitset，就需要使用 vector<bool>。</p>
<p>bitset 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bt;  <span class="comment">// 定义大小为16的bitset，每一位都是0</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;16&gt; <span class="title">bt</span><span class="params">(<span class="built_in">string</span>(<span class="string">"11001"</span>))</span></span>;  <span class="comment">// 定义大小为16的bitset，并用string初始化，注意高位为0，也就是 0000000000011001</span></span><br></pre></td></tr></table></figure>
<p>bitset 可以直接使用 cin 和 cout 输入输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; bt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; bt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bt &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>bitset 可以像数组一样访问或修改某一位置的元素，注意0表示低位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;8&gt; bt;</span><br><span class="line">bt[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure>
<p>bitset 也可以像一个数一样进行位运算：与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)。</p>
<p>常用函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;8&gt; bt;</span><br><span class="line">bt.size(); <span class="comment">// 返回大小</span></span><br><span class="line">bt.count(); <span class="comment">// 返回1的个数</span></span><br><span class="line">bt.<span class="built_in">set</span>(); <span class="comment">// 全部置1</span></span><br><span class="line">bt.<span class="built_in">set</span>(pos);  <span class="comment">// pos位置1</span></span><br><span class="line">bt.reset();  <span class="comment">// 全部置0</span></span><br><span class="line">bt.reset(pos);  <span class="comment">// pos位置0</span></span><br><span class="line">bt.flip(); <span class="comment">// 全部取反</span></span><br><span class="line">bt.flip(pos); <span class="comment">// pos位取反</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 常见的cin的错误处理</title>
    <url>/2019/11/07/C-%E5%B8%B8%E8%A7%81%E7%9A%84cin%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>写程序时想要用 cin 对输入的合法性检查，于是学习了一下 cin.fail() 函数，顺便学习了类似的一些函数。</p>
<p>cin 对象包含了一个描述流状态的数据成员。流状态有 3 个标志位：eofbit，badbit 和 failbit。</p>
<p>当 cin 操作到达文件末尾时，eofbit 置 1。</p>
<p>当流被破坏时，badbit 置 1。例如：试图读取不可访问的文件、写入写保护的磁盘、写入的设备剩余空间不足等。</p>
<p>cin 操作未能读取到预期的字符时 failbit 会置 1。例如：要输入到一个整型变量中，输入的却是字符时 failbit 置 1。I/O 失败时 failbit 也可能置 1。</p>
<p>如果 3 个状态位都为 0 表示一切顺利。</p>
<a id="more"></a>
<p>下面介绍一些检查或改变流状态的方法。</p>
<ul>
<li>eof()</li>
</ul>
<p>如果 eofbit 为 1 返回 true。</p>
<p>所以可以用 <code>cin.eof()</code> 来判断是否读到文件尾。</p>
<ul>
<li>good()</li>
</ul>
<p>如果流可以使用，也就是 3 个状态位都为 0，返回 true。</p>
<p>只有 <code>cin.good()</code> 为 true 时，<code>while(cin &gt;&gt; input)</code> 才返回 true。</p>
<ul>
<li>bad()</li>
</ul>
<p>如果 badbit 为 1 返回 true。</p>
<ul>
<li>fail()</li>
</ul>
<p>如果 failbit 或 badbit 为 1 返回 true。所以与 bad() 一样的情况会返回 true，输入一个类型不匹配的字符也是返回 true。</p>
<p>可用于检查输入是否合法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果输入不合法重新输入，failbit 是不会自动重置的。</p>
<ul>
<li>rdstate()</li>
</ul>
<p>返回流状态。</p>
<ul>
<li>clear(iostate s)</li>
</ul>
<p>状态位置位后不会改变。因此要重置状态位需使用 clear(iostate s)。该方法将所有的状态位都设置为 s，其中 s 默认为 0。也就是 clear() 将所有状态位清零。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://book.douban.com/subject/10789789/" target="_blank" rel="noopener">《C++ Primer Plus》 Stephen Prata</a></p>
<p><a href="https://blog.csdn.net/maoliran/article/details/51725396" target="_blank" rel="noopener">C++之cin.eof, cin.bad, cin.good, cin.fail, cin.clear</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1119E Pavel and Triangles (贪心)</title>
    <url>/2019/09/27/Codeforces-1119E-Pavel-and-Triangles-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1119" target="_blank" rel="noopener">Codeforces Global Round 2</a></p>
<p>题目链接：</p>
<p><a href="https://codeforces.com/problemset/problem/1119/E" target="_blank" rel="noopener">E. Pavel and Triangles</a></p>
<blockquote>
<p>Pavel has several sticks with lengths equal to powers of two.</p>
<p>He has $a_0$ sticks of length $2^0=1$, $a1$ sticks of length $2^1=2$, …, $a_{n−1}$ sticks of length $2^{n−1}$.</p>
<p>Pavel wants to make the maximum possible number of triangles using these sticks. The triangles should have strictly positive area, each stick can be used in at most one triangle.</p>
<p>It is forbidden to break sticks, and each triangle should consist of exactly three sticks.</p>
<p>Find the maximum possible number of triangles.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains a single integer $n (1\le n\le 300000)$ — the number of different lengths of sticks.</p>
<p>The second line contains $n$ integers $a_0, a_1, …, a_{n−1} (1\le a_i\le 10^9)$, where ai is the number of sticks with the length equal to $2^i$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print a single integer — the maximum possible number of non-degenerate triangles that Pavel can make.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>5 
1 2 2 2 2 
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>3
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3
1 1 1
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>0
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3
3 3 3
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>3
</code></pre></blockquote>
</blockquote>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>In the first example, Pavel can, for example, make this set of triangles (the lengths of the sides of the triangles are listed): $(2^0,2^4,2^4), (2^1,2^3,2^3), (2^1,2^2,2^2)$.</p>
<p>In the second example, Pavel cannot make a single triangle.</p>
<p>In the third example, Pavel can, for example, create this set of triangles (the lengths of the sides of the triangles are listed): $(2^0,2^0,2^0), (2^1,2^1,2^1), (2^2,2^2,2^2)$.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数，第 $i$ 个数 $a[i]$ 表示长度为 $2^i$ 的木棒的数量，求最多可以拼成多少个三角形。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心</strong></p>
<p>本来以为要 FFT 的，结果贪心就完事了。</p>
<p>构成三角形只有两种情况：等腰三角形和等边三角形。优先采用等边三角形，剩下的边去凑等腰三角形，贪心一下就可以了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll ans = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ll a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(k) &#123;</span><br><span class="line">            ll t = min(k, a / <span class="number">2</span>);</span><br><span class="line">            a -= t * <span class="number">2</span>;</span><br><span class="line">            ans += t;</span><br><span class="line">            k -= t;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += a / <span class="number">3</span>;</span><br><span class="line">        k += a % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CH1201 最大子序和 (单调队列)</title>
    <url>/2019/09/08/CH1201-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>题目链接：</p>
<p><a href="https://www.acwing.com/problem/content/description/137/" target="_blank" rel="noopener">AcWing</a><br><a href="https://ac.nowcoder.com/acm/contest/1006/D" target="_blank" rel="noopener">牛客</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>输入一个长度为n的整数序列，从中找出一段不超过m的连续子序列，使得整个序列的和最大。<br>例如 1,-3,5,1,-2,3<br>当m=4时，S=5+1-2+3=7<br>当m=2或m=3时，S=5+1=6</p>
</blockquote>
<a id="more"></a>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><blockquote>
<p>第一行两个数n,m（$n,m \leq 300000$）<br>第二行有n个数，要求在n个数找到最大子序和</p>
</blockquote>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><blockquote>
<p>一个数，数出他们的最大子序和</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><blockquote>
<p>输入</p>
<blockquote>
<pre><code>6 4
1 -3 5 1 -2 3
</code></pre></blockquote>
<p>输出</p>
<blockquote>
<pre><code>7
</code></pre></blockquote>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>单调队列</strong></p>
<p>单调队列模板题</p>
<p>首先这是区间和的问题，先求前缀和 $sum$。题目转化为求最大的 $sum[r] - sum[l]$ 且 $r - l &lt;= m$。</p>
<p>枚举右端点 $r$，维护左端点 $l \in [r - m, r - 1]$，保持 $sum[l]$ 最小。</p>
<p>如果某个位置 $k &lt; l$，且 $sum[k] \ge sum[l]$，那么直接舍弃 $k$。因为 $l$ 更靠近 $r$ 且 $sum[l] &lt;= sum[k]$，这意味着 $l$ 的生存能力更强。</p>
<p>因此维护一个前缀和递增的单调队列，保持队尾的元素的下标与队首的元素的下标之差不超过 $m$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll sum[maxn];</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    q[l] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r &amp;&amp; i - q[l] &gt; m) ++l;</span><br><span class="line">        ans = max(ans, sum[i] - sum[q[l]]);</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r &amp;&amp; sum[i] &lt;= sum[q[r]]) --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + x;       </span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deque 版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; ll val;</span><br><span class="line">&#125; node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;Node&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; i - q.front().id &gt; m) q.pop_front();</span><br><span class="line">        ans = max(ans, node[i].val - q.front().val);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; node[i].val &lt;= q.back().val) q.pop_back();</span><br><span class="line">        q.push_back(node[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        node[i].val = node[i - <span class="number">1</span>].val + x;</span><br><span class="line">        node[i].id = i;       </span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://book.douban.com/subject/30136932/" target="_blank" rel="noopener">《算法竞赛进阶指南》</a> 李煜东 著</p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>STL</tag>
        <tag>单调队列</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1195E OpenStreetMap (单调队列)</title>
    <url>/2019/10/06/Codeforces-1195E-OpenStreetMap-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1195" target="_blank" rel="noopener">Codeforces Round #574 (Div. 2)</a></p>
<p>题目链接：<a href="https://codeforces.com/problemset/problem/1195/E" target="_blank" rel="noopener">E. OpenStreetMap</a></p>
<blockquote>
<p>Seryozha conducts a course dedicated to building a map of heights of Stepanovo recreation center. He laid a rectangle grid of size $n×m$ cells on a map (rows of grid are numbered from $1$ to $n$ from north to south, and columns are numbered from $1$ to $m$ from west to east). After that he measured the average height of each cell above Rybinsk sea level and obtained a matrix of heights of size $n×m$. The cell $(i,j)$ lies on the intersection of the $i$-th row and the $j$-th column and has height $h_{i,j}$.</p>
<p>Seryozha is going to look at the result of his work in the browser. The screen of Seryozha’s laptop can fit a subrectangle of size $a×b$ of matrix of heights $(1≤a≤n, 1≤b≤m)$. Seryozha tries to decide how the weather can affect the recreation center — for example, if it rains, where all the rainwater will gather. To do so, he is going to find the cell having minimum height among all cells that are shown on the screen of his laptop.</p>
<p>Help Seryozha to calculate the sum of heights of such cells for all possible subrectangles he can see on his screen. In other words, you have to calculate the sum of minimum heights in submatrices of size $a×b$ with top left corners in $(i,j)$ over all $1≤i≤n−a+1$ and $1≤j≤m−b+1$.</p>
<p>Consider the sequence $g_i=(g_{i−1}⋅x+y) mod z$. You are given integers $g0$, $x$, $y$ and $z$. By miraculous coincidence, $h_{i,j}=g_{(i−1)⋅m+j−1}$ ($(i−1)⋅m+j−1$ is the index).</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input contains four integers $n$, $m$, $a$ and $b$ $(1≤n,m≤3000, 1≤a≤n, 1≤b≤m)$ — the number of rows and columns in the matrix Seryozha has, and the number of rows and columns that can be shown on the screen of the laptop, respectively.</p>
<p>The second line of the input contains four integers $g0$, $x$, $y$ and $z$ $(0≤g_0,x,y&lt;z≤10^9)$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print a single integer — the answer to the problem.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3 4 2 1 
1 2 3 59
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>111
</code></pre></blockquote>
</blockquote>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>The matrix from the first example:<br><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/06/1570371742359-1570371742391.png" alt=""></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n \times m$ 的矩阵，求所有 $a \times b$ 的子矩阵的最小值的和。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>单调队列</strong></p>
<p>与 <a href="https://wutao18.github.io/2019/09/09/P2216-HAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">洛谷 P2216</a> 类似，先用单调队列维护每一行的最小值，再用单调队列维护每一列的最小值。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line">ll mt[maxn][maxn];</span><br><span class="line"></span><br><span class="line">ll minr[maxn][maxn], minc[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll a, b, m, n;</span><br><span class="line">    ll g, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; g &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            mt[i][j] = g;</span><br><span class="line">            g = (g * x + y) % z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        ll q[maxn] = &#123;<span class="number">0</span>, l&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; j - q[l] &gt;= b) ++l;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; mt[i][j] &lt;= mt[i][q[r]]) --r;</span><br><span class="line">            q[++r] = j;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= b) &#123;</span><br><span class="line">                minr[i][j - b + <span class="number">1</span>] = mt[i][q[l]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m - b + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        ll q[maxn] = &#123;<span class="number">0</span>, l&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; j - q[l] &gt;= a) ++l;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; minr[j][i] &lt;= minr[q[r]][i]) --r;</span><br><span class="line">            q[++r] = j;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= a) &#123;</span><br><span class="line">                minc[j - a + <span class="number">1</span>][i] = minr[q[l]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - a + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - b + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            ans += minc[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>单调队列</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 166B - Polygon (判断凸包位置关系)</title>
    <url>/2019/08/27/Codeforces-166B-Polygon-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/166" target="_blank" rel="noopener">Codeforces Round #113 (Div. 2)</a></p>
<p>题目链接：<a href="https://codeforces.com/contest/166/problem/B" target="_blank" rel="noopener">Polygons</a></p>
<blockquote>
<p>You’ve got another geometrical task. You are given two non-degenerate polygons $A$ and $B$ as vertex coordinates. Polygon $A$ is strictly convex. Polygon $B$ is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.</p>
<p>Your task is to check whether polygon $B$ is positioned strictly inside polygon $A$. It means that any point of polygon $B$ should be strictly inside polygon $A$. “Strictly” means that the vertex of polygon $B$ cannot lie on the side of the polygon $A$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains the only integer $n (3 \le n \le 10^5)$ — the number of vertices of polygon $A$. Then $n$ lines contain pairs of integers $x_i, y_i (|x_i|, |y_i| \le 10^9)$ — coordinates of the i-th vertex of polygon $A$. The vertices are given in the clockwise order.</p>
<p>The next line contains a single integer $m (3 \le m \le 2·10^4)$ — the number of vertices of polygon $B$. Then following $m$ lines contain pairs of integers $x_j, y_j (|x_j|, |y_j| \le 10^9)$ — the coordinates of the $j$-th vertex of polygon $B$. The vertices are given in the clockwise order.</p>
<p>The coordinates of the polygon’s vertices are separated by a single space. It is guaranteed that polygons $A$ and $B$ are non-degenerate, that polygon $A$ is strictly convex, that polygon $B$ has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print on the only line the answer to the problem — if polygon $B$ is strictly inside polygon $A$, print “YES”, otherwise print “NO” (without the quotes).</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>6
-2 1
0 3
3 3
4 1
3 -2
2 -2
4
0 1
2 2
3 1
1 0
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>YES
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>5
1 2
4 2
3 -3
-2 -2
-2 1
4
0 1
1 2
4 1
2 -1
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>NO
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>5
-1 2
2 3
4 1
3 -2
0 -3
5
1 0
1 1
3 1
5 -1
2 -1
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>NO
</code></pre></blockquote>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个凸包 $A$ 和 $B$。判断凸包 $B$ 是否严格在凸包 $A$ 内。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对凸包 $A$ 和 $B$ 的所有点构造凸包，判断该凸包是否等于凸包 $A$。若相等，则凸包 $B$ 严格在凸包 $A$ 内。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*<span class="keyword">this</span>) == a)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (dcmp(cross(a, b)) &lt;= <span class="number">0</span>)  <span class="comment">// 为了让凸包边上可以有点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span> </span>&#123;</span><br><span class="line">    Polygon u, l;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; s.size() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = u.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(u[n - <span class="number">2</span>], u[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.size() ; n &gt;=<span class="number">2</span> &amp;&amp; !isclock(l[n<span class="number">-2</span>],l[n<span class="number">-1</span>],s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(cross(p2 - p1, p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Polygon A, B;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">        A.push_back(Point(x, y));</span><br><span class="line">        B.push_back(Point(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">        B.push_back(Point(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    A = Andrew(A);</span><br><span class="line">    B = Andrew(B);</span><br><span class="line">    <span class="keyword">if</span>(A.size() != B.size()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    sort(A.begin(), A.end());</span><br><span class="line">    sort(B.begin(), B.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i]) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 340B - Maximal Area Quadrilateral (计算几何)</title>
    <url>/2019/09/01/Codeforces-340B-Maximal-Area-Quadrilateral-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/340" target="_blank" rel="noopener">Codeforces Round #198 (Div. 2)</a></p>
<p>题目链接：<a href="https://codeforces.com/contest/340/problem/B" target="_blank" rel="noopener">Maximal Area Quadrilateral</a></p>
<blockquote>
<p>Iahub has drawn a set of $n$ points in the cartesian plane which he calls “special points”. A quadrilateral is a simple polygon without self-intersections with four sides (also called edges) and four vertices (also called corners). Please note that a quadrilateral doesn’t have to be convex. A special quadrilateral is one which has all four vertices in the set of special points. Given the set of special points, please calculate the maximal area of a special quadrilateral.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains integer $n (4 \le n \le 300)$. Each of the next $n$ lines contains two integers: $x_i, y_i ( - 1000 \le xi, yi \le 1000)$ — the cartesian coordinates of ith special point. It is guaranteed that no three points are on the same line. It is guaranteed that no two points coincide.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Output a single real number — the maximal area of a special quadrilateral. The answer will be considered correct if its absolute or relative error does’t exceed $10 ^{- 9}$.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>5
0 0
0 4
4 0
4 4
2 3
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>16.000000
</code></pre></blockquote>
</blockquote>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>In the test example we can choose first $4$ points to be the vertices of the quadrilateral. They form a square by side $4$, so the area is $4\cdot 4 = 16$.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点的坐标，选择其中 $4$ 个点构成四边形，求最大四边形面积。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>四边形的面积等于两个三角形面积的和。枚举四边形的对角线，以及左右两边的点，选择两个面积最大的三角形，更新 $ans$。</p>
<p>三重循环枚举，时间复杂度 $O(n^3)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point tmp;</span><br><span class="line">        tmp.input();</span><br><span class="line">        p.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; p.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[&#123;i, j&#125;]) &#123;</span><br><span class="line">                mp[&#123;i, j&#125;] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">double</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p.size(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == i || k == j) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dcmp((p[j] - p[i]).cross(p[k] - p[i])) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        s1 = max(s1, <span class="built_in">fabs</span>((p[j] - p[i]).cross(p[k] - p[i])) * <span class="number">0.5</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        s2 = max(s2, <span class="built_in">fabs</span>((p[j] - p[i]).cross(p[k] - p[i])) * <span class="number">0.5</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dcmp(s1) == <span class="number">0</span> || dcmp(s2) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ans = max(ans, s1 + s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>枚举</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 578B &quot;Or&quot; Game (前缀和 + 贪心)</title>
    <url>/2019/10/01/Codeforces-578B-Or-Game-%E5%89%8D%E7%BC%80%E5%92%8C-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/578" target="_blank" rel="noopener">Codeforces Round #320 (Div. 1) [Bayan Thanks-Round]</a></p>
<p>题目链接：<a href="https://codeforces.com/problemset/problem/578/B" target="_blank" rel="noopener">B. “Or” Game</a></p>
<blockquote>
<p>You are given $n$ numbers $a_1, a_2, …, a_n$. You can perform at most $k$ operations. For each operation you can multiply one of the numbers by $x$. We want to make $a_1 | a_2 | … | a_n$ as large as possible, where $|$ denotes the bitwise OR.</p>
<p>Find the maximum possible value of $a_1 | a_2 | … | a_n$ after performing at most $k$ operations optimally.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains three integers $n$, $k$ and $x (1 ≤ n ≤ 200 000, 1 ≤ k ≤ 10, 2 ≤ x ≤ 8)$.</p>
<p>The second line contains $n$ integers $a_1, a_2, …, a_n (0 ≤ a_i ≤ 10^9)$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Output the maximum value of a bitwise OR of sequence elements after performing operations.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3 1 2 
1 1 1 
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>3
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>4 2 3
1 2 4 8
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>79
</code></pre></blockquote>
</blockquote>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>For the first sample, any possible choice of doing one operation will result the same three numbers $1, 1, 2$ so the result is $1 | 1 | 2 = 3$.</p>
<p>For the second sample if we multiply $8$ by $3$ two times we’ll get $72$. In this case the numbers will become $1, 2, 4, 72$ so the OR value will be $79$ and is the largest possible result.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数 $a_1 … a_n$，可以进行 $k$ 次操作，每次可以给任意一个数乘上 $x$，求 $a_1 | a_2 | … | a_n$ 最大为多少。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心 前缀和</strong></p>
<p>因为 $x \ge 2$，因此一个数乘上 $x$ 后二进制位数必然增加一位。</p>
<p>由于或运算是 $0 | 1$ 时才会使答案增加，因此让 $k$ 个 $x$ 乘在同一个数上就行。</p>
<p>计算一下前缀和和后缀和，然后暴力枚举每一个数乘以 $x^k$，找到最大值即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a[maxn], s1[maxn], s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll n, k, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] | a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        s2[i] = s2[i + <span class="number">1</span>] | a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll tmp = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        tmp *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = max(ans, s1[i - <span class="number">1</span>] | tmp * a[i] | s2[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>枚举</tag>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 388C Fox and Card Game (贪心博弈)</title>
    <url>/2019/10/20/Codeforces-388C-Fox-and-Card-Game-%E8%B4%AA%E5%BF%83%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/388" target="_blank" rel="noopener">Codeforces Round #228 (Div. 1)</a></p>
<p>题目链接：<a href="https://codeforces.com/problemset/problem/388/C" target="_blank" rel="noopener">C. Fox and Card Game</a></p>
<blockquote>
<p>Fox Ciel is playing a card game with her friend Fox Jiro. There are n piles of cards on the table. And there is a positive integer on each card.</p>
<p>The players take turns and Ciel takes the first turn. In Ciel’s turn she takes a card from the top of any non-empty pile, and in Jiro’s turn he takes a card from the bottom of any non-empty pile. Each player wants to maximize the total sum of the cards he took. The game ends when all piles become empty.</p>
<p>Suppose Ciel and Jiro play optimally, what is the score of the game?</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contain an integer $n (1 ≤ n ≤ 100)$. Each of the next $n$ lines contains a description of the pile: the first integer in the line is $s_i (1 ≤ s_i ≤ 100)$ — the number of cards in the $i$-th pile; then follow $s_i$ positive integers $c_1, c_2, …, c_k, …, c_{s_i} (1 ≤ c_k ≤ 1000)$ — the sequence of the numbers on the cards listed from top of the current pile to bottom of the pile.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print two integers: the sum of Ciel’s cards and the sum of Jiro’s cards if they play optimally.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>2 
1 100
2 1 10
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>101 10
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>1 
9 2 8 6 5 9 4 7 1 3
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>30 15
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3
3 1 3 2
3 5 4 6 
2 8 7
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>18 18
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3
3 1000 1000 1000
6 1000 1000 1000 1000 1000 1000
5 1000 1000 1000 1000 1000
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>7000 7000
</code></pre></blockquote>
</blockquote>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>In the first example, Ciel will take the cards with number 100 and 1, Jiro will take the card with number 10.</p>
<p>In the second example, Ciel will take cards with numbers 2, 8, 6, 5, 9 and Jiro will take cards with numbers 4, 7, 1, 3.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 叠牌，第 $i$ 叠牌有 $s_i$ 张，第 $k$ 张牌的值为 $c_k$。</p>
<p>Ciel 先手，每次选择一叠牌，拿走最上面的一张牌，Jiro 后手，每次选择一叠牌，拿走最下面的一张牌。</p>
<p>求两者在采取最优策略的情况下各自的分数。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>贪心博弈。如果一叠牌的数量是偶数，那么两个人各自取一半，如果是奇数，则中间的一叠牌单独取，其余的牌一人一半。</p>
<p>对所有的中间的牌排序后再轮流取。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            sum1 += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            a.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            sum2 += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(), a.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            sum2 += a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum1 += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, sum1, sum2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 743C - Vladik and fractions (构造)</title>
    <url>/2019/09/03/Codeforces-743C-Vladik-and-fractions-%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/743" target="_blank" rel="noopener">Codeforces Round #384 (Div. 2)</a></p>
<p>题目链接：<a href="http://codeforces.com/problemset/problem/743/C" target="_blank" rel="noopener">Vladik and fractions</a></p>
<blockquote>
<p>Vladik and Chloe decided to determine who of them is better at math. Vladik claimed that for any positive integer $n$ he can represent fraction $\frac{2}{n}$ as a sum of three distinct positive fractions in form $\frac{1}{m}$.</p>
<p>Help Vladik with that, i.e for a given $n$ find three distinct positive integers $x, y$ and $z$ such that $\frac{2}{n} = \frac{1}{x} + \frac{1}{y} + \frac{1}{z}$. Because Chloe can’t check Vladik’s answer if the numbers are large, he asks you to print numbers not exceeding $10^9$.</p>
<p>If there is no such answer, print $-1$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The single line contains single integer $n (1 \le  n \le  10^4)$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>If the answer exists, print 3 distinct numbers $x, y$ and $z (1 \le  x, y, z \le  10^9, x \neq y, x \neq  z, y \neq  z)$. Otherwise print $-1$.</p>
<p>If there are multiple answers, print any of them.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>3
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>2 7 42
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>7
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>7 8 56
</code></pre></blockquote>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个正整数 $n$，求正整数 $x,y,z$ 满足 $\frac{2}{n} = \frac{1}{x} + \frac{1}{y} + \frac{1}{z}$。</p>
<p>其中 $x \neq y, x \neq z, y \neq z$。若无解输出 $-1$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>构造</strong></p>
<script type="math/tex; mode=display">\frac{1}{n} - \frac{1}{n + 1} = \frac{1}{n(n+1)}</script><script type="math/tex; mode=display">\frac{1}{n} = \frac{1}{n + 1} + \frac{1}{n(n+1)}</script><script type="math/tex; mode=display">\frac{2}{n} = \frac{1}{n + 1} + \frac{1}{n(n+1)} + \frac{1}{n}</script><p>当 $n=1$ 时，$\frac{2}{n}=2$。而 $(\frac{1}{x}+\frac{1}{y}+\frac{1}{z})_{max} = \frac{1}{1}+\frac{1}{2}+\frac{1}{3} &lt; 2$，所以当 $n=1$ 时无解。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (n + <span class="number">1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; (n * (n + <span class="number">1</span>)) &lt;&lt; <span class="string">" "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 993E Nikita and Order Statistics (FFT)</title>
    <url>/2019/09/22/Codeforces-993E-Nikita-and-Order-Statistics-FFT/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/993" target="_blank" rel="noopener">Codeforces Round #488 by NEAR (Div. 1)</a></p>
<p>题目链接：</p>
<p><a href="https://codeforces.com/problemset/problem/993/E" target="_blank" rel="noopener">Nikita and Order Statistics</a></p>
<p><a href="https://www.luogu.org/problem/CF993E" target="_blank" rel="noopener">CF993E Nikita and Order Statistics</a></p>
<blockquote>
<p>Nikita likes tasks on order statistics, for example, he can easily find the $k$-th number in increasing order on a segment of an array. But now Nikita wonders how many segments of an array there are such that a given number $x$ is the $k$-th number in increasing order on this segment. In other words, you should find the number of segments of a given array such that there are exactly $k$ numbers of this segment which are less than $x$.</p>
<p>Nikita wants to get answer for this question for each $k$ from $0$ to $n$, where $n$ is the size of the array.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains two integers $n$ and $x (1 \le n \le 2 \cdot 10^5, -10^9 \le x \le 10^9)$.</p>
<p>The second line contains $n$ integers $a_1,a_2,…,a_n (-10^9 \le a_i \le 10^9)$ — the given array.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print $n+1$ integers, where the $i$-th number is the answer for Nikita’s question for $k=i−1$.</p>
</blockquote>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>5 3
1 2 3 4 5
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>6 5 4 0 0 0
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>2 6
-5 9
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>1 2 0
</code></pre></blockquote>
<p><strong>input</strong></p>
<blockquote>
<pre><code>6 99
-1 -1 -1 -1 -1 -1
</code></pre></blockquote>
<p><strong>output</strong></p>
<blockquote>
<pre><code>0 6 5 4 3 2 1
</code></pre></blockquote>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的数组，对于 $k \in [0, n]$，求有多少个区间满足区间内恰好有 $k$ 个数比 $x$ 小。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>FFT</strong></p>
<p>首先，对于数组中的每一个数，如果比 $x$ 小，那么把这个数置为 $1$，否则置为 $0$。然后求该数组的前缀和 $s$。</p>
<p>设 $f[i]$ 表示前缀和等于 $i$ 的个数。那么 $ans[k] = \sum_{i=k}^nf[i]f[i-k] = \sum_{i=k}^nf[i]f[n-(n+k-i)] = \sum_{i+j=n+k}f[i]f[n-j]$。</p>
<p>令 $g[i] = f[n - i]$，则 $ans[k] = \sum_{i+j=n+k}f[i]g[j]$。</p>
<p>问题就转化为求 $f$ 与 $g$ 的卷积。</p>
<p>注意 $k = 0$ 的情况要特判。此时会有 $n + 1$ 次自己和自己算到一起，也就是空串的情况。所以要对 $ans[0]$ 减去 $n + 1$。减完后还要除以 $2$，因为 $k \neq 0$ 时，由于 $s$ 单调不减，因此 $s[i] \ge s[i - k]$。此时一定保证区间的左端点在前，右端点在后。而 $k = 0$ 时，不能保证左端点一定在前，右端点一定在后，所以要除以 $2$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; Complex;</span><br><span class="line"></span><br><span class="line">ll n, x;</span><br><span class="line">ll s[maxn], cnt[maxn];</span><br><span class="line">Complex f[maxn], g[maxn];</span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">2</span>, rev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rev, <span class="number">0</span>, <span class="keyword">sizeof</span>(rev));</span><br><span class="line">    <span class="keyword">while</span>(bit &lt;= n * <span class="number">2</span>) bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | (bit &gt;&gt; <span class="number">1</span>) * (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; bit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(PI / mid), op * <span class="built_in">sin</span>(PI / mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit; j += mid&lt;&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k, w = w * wn) &#123;</span><br><span class="line">                Complex x = a[j + k], y = w * a[j + k + mid];</span><br><span class="line">                a[j + k] = x + y, a[j + k + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    ++cnt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + (a &lt; x);</span><br><span class="line">        ++cnt[s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = cnt[i];</span><br><span class="line">        g[n - i] = cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    get_rev();</span><br><span class="line">    FFT(f, <span class="number">1</span>), FFT(g, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        f[i] = f[i] * g[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(f, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans[i] = (ll)(f[n + i].real() / bit + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans[<span class="number">0</span>] - n - <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>构造</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #572 (Div. 2)</title>
    <url>/2019/08/31/Codeforces-Round-572-Div-2/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1189" target="_blank" rel="noopener">Codeforces Round #572 (Div. 2)</a></p>
<p>官方题解：<a href="https://codeforces.com/blog/entry/68079" target="_blank" rel="noopener">Editorial of Codeforces Round #572</a></p>
<a id="more"></a>
<h2 id="A-Keanu-Reeves"><a href="#A-Keanu-Reeves" class="headerlink" title="A. Keanu Reeves"></a>A. Keanu Reeves</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如果一个 $01$ 序列中 $0$ 的数量和 $1$ 的数量不同，就认为这个序列是“好”的。</p>
<p>给定一个长度为 $n$ 的 $01$ 序列，将这个序列分割成多个“好”的序列，求最少分割次数和分割后的所有序列。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果原序列 $0$ 和 $1$ 不同就不用分割。</p>
<p>否则分割成两个串，第一串为第一个数，剩下的为第二串。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) ++one;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(one * <span class="number">2</span> != n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; s[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Number-Circle"><a href="#B-Number-Circle" class="headerlink" title="B. Number Circle"></a>B. Number Circle</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数字，将所有数字构成一个环，放置顺序任意，问是否存在一种放置顺序，使得每个数字小于左右两个数字的和。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对所有数字排序，如果 $a_n \ge a_{n - 1} + a_{n - 2}$，那么答案是 $NO$，因为这样 $a_n$ 大于等于任意两个数的和。</p>
<p>否则答案一定存在，只要交换最后两个数即可，因为 $a_i &lt; a_{i + 1} &lt; a_{i - 1} + a_{i + 1} (i &lt; n)$ 。(构造方法不唯一)</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">if</span>(a[n - <span class="number">1</span>] &gt;= a[n - <span class="number">2</span>] + a[n - <span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        swap(a[n - <span class="number">1</span>], a[n - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Candies"><a href="#C-Candies" class="headerlink" title="C. Candies!"></a>C. Candies!</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>定义 $f([a_1, a_2, \ldots, a_{2^k}])$ 为每次取两个相邻的数 $a_i$ 和 $a_{i + 1}$，将这两个数变成一个数 $(a_i + a_{i + 1}) mod 10$，经过若干次同样操作直到序列长度为 $1$ 为止。其中每次操作时如果 $a_i + a_{i + 1} \ge 10$ 就能获得一颗糖果。</p>
<p>现在给定一个长度为 $n$ 的序列 $s$，以及 $q$ 个询问。每个询问包含 $l$ 和 $r$，求 $f([s_{l}, s_{l + 1}, \ldots, s_{r}])$。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>每次合并是相加取模，所以每次序列都不会超过 $10$，$f([a_1, a_2, \ldots, a_{2^k}]) = \lfloor \frac{a_1 + a_2 + \ldots + a_{2^k}}{10} \rfloor$。</p>
<p>用前缀和处理即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (s[r] - s[l - <span class="number">1</span>]) / <span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D1-Add-on-a-Tree"><a href="#D1-Add-on-a-Tree" class="headerlink" title="D1. Add on a Tree"></a>D1. Add on a Tree</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一颗树，初始每条边的权值为 $0$。可以任选两个叶子结点，给这两个结点的简单路径的所有边加上任意实数，问是否可以通过有限次操作使得树上的所有边达到任意值。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>如果有度为 $2$ 的结点就不能。因为度为 $2$ 的结点的两条边经过任意次操作后权值都相等。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        degree[u]++; degree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(degree[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D2-Add-on-a-Tree-Revolution"><a href="#D2-Add-on-a-Tree-Revolution" class="headerlink" title="D2. Add on a Tree: Revolution"></a>D2. Add on a Tree: Revolution</h2><p>待补</p>
<h2 id="E-Count-Pairs"><a href="#E-Count-Pairs" class="headerlink" title="E.Count Pairs"></a>E.Count Pairs</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数 $a_1, a_2, …, a_n$ ，求满足 $(a_i+a_j)(a_i^2+a_j^2)\equiv k mod p$ 的 $(i, j)(1 \le i &lt; j \le n)$ 的数量。其中 $p$ 是素数，且 $n$ 个数都不同。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><script type="math/tex; mode=display">(a_i+a_j)(a_i^2+a_j^2)\equiv k\ mod\ p</script><script type="math/tex; mode=display">(a_i-a_j)(a_i+a_j)(a_i^2+a_j^2)\equiv (a_i-a_j)k\ mod\ p</script><script type="math/tex; mode=display">(a_i^2-a_j^2)(a_i^2+a_j^2)\equiv (a_i-a_j)k\ mod\ p</script><script type="math/tex; mode=display">(a_i^4-a_j^4)\equiv (a_i-a_j)k\ mod\ p</script><script type="math/tex; mode=display">a_i^4-ka_i\equiv a_j^4-ka_j\ (mod\ p)</script><p>统计一下有多少对 $(a_i^4-ka_i) mod p$ 是相同的。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans * a) % m;</span><br><span class="line">        a = (a * a) % m; </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll p, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line">    <span class="built_in">map</span>&lt;ll, <span class="keyword">int</span>&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        ll tmp = (qmod(a[i], <span class="number">4</span>, p) - k * a[i]);</span><br><span class="line">        tmp += p * (<span class="built_in">abs</span>(tmp) / p + <span class="number">1</span>);</span><br><span class="line">        b[tmp % p]++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = b.begin(); it != b.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second &gt; <span class="number">1</span>) sum += (it-&gt;second) * (it-&gt;second - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Array-Beauty"><a href="#F-Array-Beauty" class="headerlink" title="F.Array Beauty"></a>F.Array Beauty</h2><p>待补</p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #589 (Div. 2)</title>
    <url>/2019/10/09/Codeforces-Round-589-Div-2/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1228" target="_blank" rel="noopener">Codeforces Round #589 (Div. 2)</a></p>
<p>官方题解：<a href="https://codeforces.com/blog/entry/70162" target="_blank" rel="noopener">Codeforces Round #589 (Div. 2) Editorial</a></p>
<a id="more"></a>
<h2 id="A-Distinct-Digits"><a href="#A-Distinct-Digits" class="headerlink" title="A. Distinct Digits"></a>A. Distinct Digits</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个整数 $l$ 和 $r$，求一个 $x$ 满足 $l \le x \le r$ 且 $x$ 的每一位都不同。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接暴力。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m[x % <span class="number">10</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[x % <span class="number">10</span>]++;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(judge(i)) &#123;</span><br><span class="line">                f = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Filling-the-Grid"><a href="#B-Filling-the-Grid" class="headerlink" title="B. Filling the Grid"></a>B. Filling the Grid</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $h \times w$ 的矩形，以及 $h$ 个 $r$ 和 $w$ 个 $c$。</p>
<p>$r_i$ 表示第 $i$ 行左边界从左往右连续的黑色格子的是 $r_i$ 个。</p>
<p>$c_i$ 表示第 $i$ 列上边界从上往下连续的黑色格子的是 $c_i$ 个。</p>
<p>给出 $h, w, r[], c[]$，求可以构造出多少种矩形满足条件。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>模拟</strong></p>
<p>对每行每列模拟，填充黑色格子和白色格子（黑色格子旁边一个格子一定是白色），如果行列有冲突就输出零，否则找出所有的没填充的格子的个数 $cnt$，答案为 $2 ^ {cnt} \mod 10^9 + 7$。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll c[maxn], r[maxn];</span><br><span class="line">ll g[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    a %= m;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll h, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= h; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r[i];</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= r[i]; ++j) &#123;</span><br><span class="line">            g[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i][r[i] + <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= w; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= c[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[j][i] == <span class="number">2</span>) &#123;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g[c[i] + <span class="number">1</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[c[i] + <span class="number">1</span>][i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= h; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!g[i][j]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; qmod(<span class="number">2</span>, ans, mod) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Primes-and-Multiplication"><a href="#C-Primes-and-Multiplication" class="headerlink" title="C. Primes and Multiplication"></a>C. Primes and Multiplication</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>$g(x, p)$ 定义为最大的 $p ^ k$ 满足 $p^k$ 整除 $x$。</p>
<p>$f(x, y)$ 定义为所有 $g(y, p)$ 的乘积，其中 $p$ 是 $x$ 的质因数。</p>
<p>给定 $x$ 和 $n$，求 $\prod_{i=1}^n f(x,i) \mod  (10^9 + 7)$。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>理解了 $g(x, p)$ 的含义就容易做了。</p>
<p>$g(x, p)$ 其实为 $x$ 分解质因数后 $p$ 出现的次数。</p>
<p>先求出 $x$ 的所有质因数。然后对于每个质因数，求出 $1$ 到 $n$ 中这个质因数出现的次数。也就是求 $n!$ 的这个质因数的个数。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">divide</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ans.push_back(x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans * a) % m;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll x, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; p = divide(x);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); ++i) &#123;</span><br><span class="line">        ll tmp = n;</span><br><span class="line">        <span class="keyword">while</span>(tmp &gt;= p[i]) &#123;</span><br><span class="line">            ans = ans * qmod(p[i], tmp / p[i], mod) % mod;</span><br><span class="line">            tmp /= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Complete-Tripartite"><a href="#D-Complete-Tripartite" class="headerlink" title="D. Complete Tripartite"></a>D. Complete Tripartite</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个无向无环图。问能否将点集分成 $3$ 个，使得每一个点集内的任意两点没有边，每一个点集内的点与其他所有点集内的所有点都有一条边。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><strong>哈希</strong></p>
<p>特殊的三分图。</p>
<p>考虑到一个集合内的所有点都与其他两个集合内的所有点有边，也就是一个集合内的每个点的所有边连出去的点都是相同的，根据这个哈希，如果哈希值有 $3$ 个，就按哈希值分类即可。</p>
<p>我的做法是把所有的点赋一个互不相同的正整数值。每个点的哈希值 $h[i]$ 为它的所有边的另外一个点的值的和。</p>
<p>注意判断一下哈希值为 $0$ 的情况。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;ll, <span class="built_in">vector</span>&lt;ll&gt;&gt; mp;</span><br><span class="line">ll e[maxn], ans[maxn], h[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; ump;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        h[i] = rnd();</span><br><span class="line">        <span class="keyword">while</span>(ump[h[i]] || h[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            h[i] = rnd();</span><br><span class="line">        &#125;</span><br><span class="line">        ump[h[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ll a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a] += h[b];</span><br><span class="line">        e[b] += h[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]) &#123;</span><br><span class="line">            mp[e[i]].push_back(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mp.size() != <span class="number">3</span> || f == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">            ++x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (it-&gt;second).size(); ++i) &#123;</span><br><span class="line">                ans[(it-&gt;second)[i]] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模拟</tag>
        <tag>思维</tag>
        <tag>暴力</tag>
        <tag>数论</tag>
        <tag>素数</tag>
        <tag>哈希/Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ 1058. 挤模具 (多边形面积)</title>
    <url>/2019/10/16/EOJ-1058-%E6%8C%A4%E6%A8%A1%E5%85%B7-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/problem/1058/" target="_blank" rel="noopener">1058. 挤模具</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出模具的底和体积，求模具的高。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>模具的底为多边形，因此求出多边形面积，用体积除以底的面积就是答案。</p>
<p>多边形的面积求解见 <a href="https://wutao18.github.io/2019/10/16/EOJ-1127-多边形面积（计算几何）/">EOJ 1127. 多边形面积（计算几何）</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    db ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += (p[i] - p[<span class="number">1</span>]).cross(p[i + <span class="number">1</span>] - p[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        db s = <span class="number">0</span>;</span><br><span class="line">        db v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;v);</span><br><span class="line">        s = area();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"BAR LENGTH: %.2lf\n"</span>, v / <span class="built_in">fabs</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ 1127. 多边形面积（计算几何）</title>
    <url>/2019/10/16/EOJ-1127-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%89/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/problem/1127/" target="_blank" rel="noopener">1127. 多边形面积（计算几何）</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>按逆时针顺序给出 $n$ 个点的坐标，求这些点围成的多边形的面积。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>选择多边形上的一个点，然后每次枚举之后的两个点，计算叉积，注意要保留符号，对所有的叉积的结果相加就是多边形的面积。</p>
<p>举个栗子：</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/16/1571236300876-1571236301094.png" alt=""></p>
<p>计算上图多边形 $ABCDEFGH$ 的面积，选择 $A$ 点，则面积等于 $\frac{1}{2} (\boldsymbol {AB \times AC} + \boldsymbol {AC \times AD} + \boldsymbol {AD \times AE} + \boldsymbol {AE \times AF} + \boldsymbol {AF \times AG} + \boldsymbol {AG \times AH})$。其中 $\triangle ABC$ 的面积是负的，而 $\triangle ACD$ 与 $\triangle ADE$ 的面积都是正的，则多边形 $ABCDE$ 的面积相当于多边形 $ACDE$ 的面积减去 $\triangle ABC$ 的面积。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    db ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += (p[i] - p[<span class="number">1</span>]).cross(p[i + <span class="number">1</span>] - p[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        db s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        s = area();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, <span class="built_in">fabs</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #596 (Div. 2, based on Technocup 2020 Elimination Round 2)</title>
    <url>/2019/11/02/Codeforces-Round-596-Div-2-based-on-Technocup-2020-Elimination-Round-2/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1247" target="_blank" rel="noopener">Codeforces Round #596 (Div. 2, based on Technocup 2020 Elimination Round 2)</a></p>
<p>官方题解：<a href="https://codeforces.com/blog/entry/70898" target="_blank" rel="noopener">Technocup 2020 — Elimination Round 2 + Codeforces Round 596: analysis</a></p>
<a id="more"></a>
<h2 id="A-Forgetting-Things"><a href="#A-Forgetting-Things" class="headerlink" title="A. Forgetting Things"></a>A. Forgetting Things</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有两个数 $a$ 和 $b$，给定 $a$ 的首位 $d_a$ 和 $b$ 的首位 $d_b$，问能否构造出 $a$ 和 $b$，满足 $a + 1 = b$</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果 $a = b$，构造 $a1$，$b2$。</p>
<p>如果 $a + 1 = b$，构造 $a9$，$b0$。</p>
<p>如果 $a = 9$，$b = 1$，构造 $9$，$10$。</p>
<p>否则无法构造。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n == m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d1 %d2\n"</span>, n, m);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">9</span> &amp;&amp; m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"9 10\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n + <span class="number">1</span> == m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d9 %d0\n"</span>, n, m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B1-TV-Subscriptions-Easy-Version"><a href="#B1-TV-Subscriptions-Easy-Version" class="headerlink" title="B1. TV Subscriptions (Easy Version)"></a>B1. TV Subscriptions (Easy Version)</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>某电视节目有 $k$ 集，告诉你 $n$ 天每天播放哪一集，现在要看连续 $d$ 天，最少需要买几集。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>暴力。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k, d;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - d + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            mp.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; ++j) &#123;</span><br><span class="line">                mp[a[i + j]]++;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = mp.size();</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = mp.size();</span><br><span class="line">        ans = min(ans, tmp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B2-TV-Subscriptions-Hard-Version"><a href="#B2-TV-Subscriptions-Hard-Version" class="headerlink" title="B2. TV Subscriptions (Hard Version)"></a>B2. TV Subscriptions (Hard Version)</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>与上一题相同，数据范围变大。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>维护一个长度为 $d$ 的滑动窗口即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> mp[maxn * <span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">        <span class="keyword">int</span> n, k, d;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; d) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[a[i]] == <span class="number">0</span>) ++tmp;</span><br><span class="line">                mp[a[i]]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = min(ans, tmp);</span><br><span class="line">                mp[a[i - d]]--;</span><br><span class="line">                <span class="keyword">if</span>(mp[a[i - d]] == <span class="number">0</span>) --tmp;</span><br><span class="line">                <span class="keyword">if</span>(mp[a[i]] == <span class="number">0</span>) ++tmp;</span><br><span class="line">                mp[a[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = min(ans, tmp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-p-binary"><a href="#C-p-binary" class="headerlink" title="C. p-binary"></a>C. p-binary</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定两个整数 $n$ 和 $p$，将 $n$ 分解成若干个 $2^x + p$ 的和，求最少需要几项。如 $n=24,p=-1$，则 $24 = (2^4 - 1) + (2^2 - 1) + (2^2 - 1) + (2^2 - 1)$，所以答案为 $4$。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>枚举项数 $i$，$2^{31}&gt;1e9$，所以不超过 $31$ 项。然后将 $n$ 减去 $p*i$，$n - p\times i$ 最多有 $n - p\times i$ 项 (每项都为 $2^0$)，最少项数为二进制分解后二进制中为 $1$ 的个数，判断 $i$ 是否在这个范围内即可。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">31</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        tmp = n - p * i;</span><br><span class="line">        <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;= i &amp;&amp; i &lt;= n - p * i)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Power-Products"><a href="#D-Power-Products" class="headerlink" title="D. Power Products"></a>D. Power Products</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个正整数 $a_1, a_2, …, a_n$，和一个整数 $k\ge 2$，问有多少对 $a_i, a_j$ 满足 $a_i\cdot a_j = x^k$，$x$ 是整数。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>将每个数质因数分解，将每个因子和模 $k$ 后的数量存入 $map$，然后找所需的剩余因子个数满足的是否存在。</p>
<p>比如 $24 = 2^3 * 3$，设 $k = 2$，则 $map$ 中存 $((2, 3\mod k), (3, 1 \mod k))$，$((2, 1), (3, 1))$。然后在 $map$ 中找 $((2,k - 1), (3, k - 1))$ 是否存在即可。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">ll a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt; &gt;, ll&gt; mp;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt; &gt; vt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= a[i] / j; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i] % j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(a[i] % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                    a[i] /= j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num % k) &#123;</span><br><span class="line">                vt.push_back(&#123;j, num % k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; <span class="number">1</span>) vt.push_back(&#123;a[i], <span class="number">1</span> % k&#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt; &gt; vt2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vt.size(); ++j) &#123;</span><br><span class="line">            vt2.push_back(&#123;vt[j].first, k - vt[j].second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mp[vt2];</span><br><span class="line">        mp[vt]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>STL</tag>
        <tag>枚举</tag>
        <tag>思维</tag>
        <tag>素数</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 73 (Rated for Div. 2)</title>
    <url>/2019/09/26/Educational-Codeforces-Round-73-Rated-for-Div-2/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1221" target="_blank" rel="noopener">Educational Codeforces Round 73 (Rated for Div. 2)</a></p>
<p>官方题解：<a href="https://codeforces.com/blog/entry/69925" target="_blank" rel="noopener">Educational Codeforces Round 73 Editorial</a></p>
<a id="more"></a>
<h2 id="A-2048-Game"><a href="#A-2048-Game" class="headerlink" title="A. 2048 Game"></a>A. 2048 Game</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如果一个只包含 $2$ 的幂次的集合，问能否从中选择一些数使得和为 $2048$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不断合并直到凑到 $2048$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">2048</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2048</span>; i *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i] &gt;= tmp) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[i * <span class="number">2</span>] += mp[i] / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Knights"><a href="#B-Knights" class="headerlink" title="B. Knights"></a>B. Knights</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n * n$ 的棋盘，放置黑白两种马，问怎么放这些马，使得相互攻击的棋子最多。 </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>隔着放就行。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"W"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Perfect-Team"><a href="#C-Perfect-Team" class="headerlink" title="C. Perfect Team"></a>C. Perfect Team</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>要组队参加 ICPC 比赛，有三种学生：coder，mathematician，普通人。每个队伍至少一名 coder，至少一名 mathematician，并且必须是三个人。现在给定每种学生的人数，求最多能组多少支队伍。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>设总人数为 $x$。则队伍数最多为 $\lfloor x / 3 \rfloor$。然后分别看一下 coder 的人数和 mathematician 的人数是否多于 $\lfloor x / 3 \rfloor$，取三者最少的就是答案。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, m, x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; m &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> sum = c + m + x;</span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; sum) &#123;</span><br><span class="line">            sum = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; sum) &#123;</span><br><span class="line">            sum = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Make-The-Fence-Great-Again"><a href="#D-Make-The-Fence-Great-Again" class="headerlink" title="D. Make The Fence Great Again"></a>D. Make The Fence Great Again</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 块板，第 $i$ 块板的高度为 $a_i$，要使相邻两块板的高度不同，可以增加板的高度，增加的代价为 $b_i$，求最少的代价。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>每块板要么不增加，要么增加 $1$，要么增加 $2$。每次从上一块板的三种状态转移过来即可。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn], b[maxn], dp[maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = inf;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">2</span>] = b[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i - <span class="number">1</span>] + k != a[i] + j) &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][k] + b[i] * j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = min(&#123;dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]&#125;);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>动态规划</tag>
        <tag>模拟</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Kick Start Round A 2020</title>
    <url>/2020/03/24/Google-Kick-Start-Round-A-2020/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7" target="_blank" rel="noopener">kick start Round A 2020</a></p>
<a id="more"></a>
<h2 id="A-Allocation"><a href="#A-Allocation" class="headerlink" title="A. Allocation"></a>A. Allocation</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f56" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出 $N$ 栋房子的价格，第 $i$ 栋房子的价格为 $A_i$，你有 $B$ 美元，问最多可以买多少栋房子？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>典型的贪心问题，将所有的房子按价格从低到高排序后选取即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                b -= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Plates"><a href="#B-Plates" class="headerlink" title="B. Plates"></a>B. Plates</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d40bb" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有 $N$ 叠盘子，每叠有 $K$ 个盘子，每个盘子有个 <em>beauty value</em>，现在要拿 $P$ 个盘子，使得 <em>beauty value</em> 之和最大。拿盘子的条件：如果一个盘子的上面的盘子都被拿走了，才能拿到这个盘子。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>看完题目就想到是动态规划的题了，但是还是忍不住先暴搜试试能不能水过小数据，结果 WA 了，于是只好老老实实写 DP。</p>
<p>本题有一点点像多重背包。首先计算每叠盘子各自的前缀和 $sum[N][K]$，设 $dp[i][j]$ 表示前 $i$ 堆盘子中取 $j$ 个盘子的 <em>beauty value</em> 的最大值，转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=max\{dp[i][j], dp[i - 1][j - l] + sum[i][l]|for\ l\ \in[0, min(j, k)]\}</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, p;</span><br><span class="line">ll a[maxn][maxn];</span><br><span class="line">ll sum[maxn][maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">                sum[i][j] = <span class="number">0</span>;</span><br><span class="line">                a[i][j] = <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                sum[i][j] = sum[i][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = sum[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * k; ++j) &#123;  <span class="comment">// 我这里多算了，实际上到 p 就行了</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= min(j, k); ++l) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - l] + sum[i][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n][p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Workout"><a href="#C-Workout" class="headerlink" title="C. Workout"></a>C. Workout</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f5b" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个严格递增的数，往这 $N$ 个数中间插 $K$ 个数，插入后要使所有的数仍然保持严格递增，而且要保证相邻两数的最大绝对值之差最小，求最小的绝对值之差。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我一开始想的是贪心+优先队列，先计算所有相邻两数的差值并加入到优先队列中，然后每次取出队首 $x$，将它分成 $x / 2$ 和 $x - x / 2$ 两部分，并将这两部分加入到优先队列中，操作 $K$ 次后的队首就是答案。提交后小数据过了，大数据 $WA$ 了。仔细一看小数据是 $K=1$。然后找到了反例，如 $K=4$，原数组是 $[10, 20]$，那么正确结果是 $[10, 12, 14, 16, 18, 20]$，而采用本方法得到的结果是 $[10, 12, 13, 15, 17, 20]$。</p>
<p>最后用的是二分答案过的，典型的最大值最小的问题。判断函数的思路：传入参数 $x$，表示答案为 $x$，然后遍历每个数 $num[i]$，如果 $num[i + 1] - num[i] &gt; x$，就插入 $num[i] + x$，如果插入的数的个数大于 $K$ 个就返回 $false$，否则返回 $true$。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll m[maxn];</span><br><span class="line">ll tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tmp[i + <span class="number">1</span>] - tmp[i] &gt; x) &#123;</span><br><span class="line">            tmp[i] += x;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = inf;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                tmp[i] = m[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge(mid)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Bundling"><a href="#D-Bundling" class="headerlink" title="D. Bundling"></a>D. Bundling</h2><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3ff3" target="_blank" rel="noopener">题目链接</a></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个字符串，把它们分组，每组 $K$ 个。每组的分数是该组所有字符串的最长公共前缀。求最大的所有组的分数和。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>很容易想到前缀树 (字典树 / trie 树)，建完树后从根节点 $dfs$，同时记录深度 $d$，然后从叶子节点回溯，统计每个节点出现的个数 $cnt$，如果某个节点 $u$ 的 $cnt[u] ≥ K$，那么说明有 $K$ 个字符串的前缀是以该节点结尾，深度 $d$ 表示它们的前缀的长度，由于是从叶子节点回溯的，所以一定是最长公共前缀，所以 $ans = ans + d$，同时 $cnt[u]$ 减去 $k$，即这 $k$ 个字符串已经分完组，不再分到其他组。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[maxn &lt;&lt; <span class="number">2</span>][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span>(trie));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = ch - <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[p][id]) &#123;</span><br><span class="line">            trie[p][id] = tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = trie[p][id];</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="number">26</span>; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(trie[u][v]) &#123;</span><br><span class="line">            dfs(trie[u][v], d + <span class="number">1</span>);</span><br><span class="line">            cnt[u] += cnt[trie[u][v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt[u] &gt;= k) &#123;</span><br><span class="line">        cnt[u] -= k;</span><br><span class="line">        ans += d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>二分</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
        <tag>Trie/字典树/前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1028 Ignatius and the Princess III (动态规划)</title>
    <url>/2019/11/04/HDU-1028-Ignatius-and-the-Princess-III-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1028" target="_blank" rel="noopener">HDU 1028</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.</p>
<p>“The second problem is, given an positive integer N, we define an equation like this:</p>
<p>  N=a[1]+a[2]+a[3]+…+a[m];</p>
<p>  a[i]&gt;0,1&lt;=m&lt;=N;</p>
<p>My question is how many different equations you can find for a given N.</p>
<p>For example, assume N is 4, we can find:</p>
<p>  4 = 4;</p>
<p>  4 = 3 + 1;</p>
<p>  4 = 2 + 2;</p>
<p>  4 = 2 + 1 + 1;</p>
<p>  4 = 1 + 1 + 1 + 1;</p>
<p>so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!”</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, you have to output a line contains an integer P which indicate the different equations you have found.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">42</span><br><span class="line">627</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$，求 $n$ 的划分数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最容易想到的就是直接递归，但是复杂度很高，可以用动态规划降低复杂度。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];  <span class="comment">// dp[i][j] 表示将i划分成最大数不超过j的划分数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> || j == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i][i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// dp[i][j - 1]表示最大数不超过j-1的方案数, dp[i - j][j]表示拿出一个j后最大数不超过j的方案数</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - j][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1028 Ignatius and the Princess III (生成函数/母函数)</title>
    <url>/2019/11/10/HDU-1028-Ignatius-and-the-Princess-III-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-%E6%AF%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1028" target="_blank" rel="noopener">HDU 1028</a></p>
<a id="more"></a>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.</p>
<p>“The second problem is, given an positive integer N, we define an equation like this:</p>
<p>  N=a[1]+a[2]+a[3]+…+a[m];</p>
<p>  a[i]&gt;0,1&lt;=m&lt;=N;</p>
<p>My question is how many different equations you can find for a given N.</p>
<p>For example, assume N is 4, we can find:</p>
<p>  4 = 4;</p>
<p>  4 = 3 + 1;</p>
<p>  4 = 2 + 2;</p>
<p>  4 = 2 + 1 + 1;</p>
<p>  4 = 1 + 1 + 1 + 1;</p>
<p>so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the same in this problem. Now, you do it!”</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains several test cases. Each test case contains a positive integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the end of file.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, you have to output a line contains an integer P which indicate the different equations you have found.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">42</span><br><span class="line">627</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$，求 $n$ 的划分数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>普通母函数。母函数 $G(x) = (1+x+x^2+…)(1+x^2+x^4+…)(1+x^3+x^6+…)…$。</p>
<p>$(1+x+x^2+…)=(x^{0\times1}+x^{1\times1}+x^{2\times1}+…)$ 代表不用数字 $1$，用一次数字 $1$，用两次数字 $1$……</p>
<p>动态规划的版本见<a href="https://wutao18.github.io/2019/11/04/HDU-1028-Ignatius-and-the-Princess-III-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">这里</a>。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c1[maxn], c2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        c1[i] = <span class="number">1</span>;</span><br><span class="line">        c2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + j &lt; maxn; k += i) &#123;</span><br><span class="line">                c2[k + j] += c1[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            c1[j] = c2[j];</span><br><span class="line">            c2[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c1[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>生成函数/母函数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1205 吃糖果 (鸽巢原理)</title>
    <url>/2019/11/05/HDU-1205-%E5%90%83%E7%B3%96%E6%9E%9C-%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1205" target="_blank" rel="noopener">HDU 1205</a></p>
<a id="more"></a>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对于每组数据，输出一行，包含一个”Yes”或者”No”。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4 1 1</span><br><span class="line">5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>Please use function scanf</p>
</blockquote>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><blockquote>
<p>Gardon</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=Gardon-DYGG+Contest+2&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">Gardon-DYGG Contest 2</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $N$ 种糖果，问是否存在一种排列使得任意连续两颗糖果是不同的糖果。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>鸽巢原理</strong></p>
<p>设数量最多的糖果数量为 $max$，其余糖果的数量为 $s$。把数量最多的糖果看成隔板，可以分隔成 $max - 1$ 个空间。</p>
<p>当 $s&lt;max-1$ 时，必然至少有两个隔板之间没有糖果，那么这两个隔板就是相同的糖果，所以无解。否则一定能把 $s$ 个糖果隔开 (每次依次放每一种糖果)。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll maxa = <span class="number">0</span>;</span><br><span class="line">        ll s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;arr[i]);</span><br><span class="line">            maxa = max(maxa, arr[i]);</span><br><span class="line">            s += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s -= maxa;</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= maxa - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>鸽巢原理</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1269 迷宫城堡 (Kosaraju)</title>
    <url>/2019/11/21/HDU-1269-%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1-Kosaraju/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1269" target="_blank" rel="noopener">HDU 1269</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+2006-4+Programming+Contest+&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">HDU 2006-4 Programming Contest</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求强连通分量的模板题。</p>
<p>这里使用的是 Kosaraju 算法。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn], rg[maxn];  <span class="comment">// 原图和反图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 时间戳</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> sccno[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// 强连通分量的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">        rg[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">memset</span>(sccno, <span class="number">0</span>, <span class="keyword">sizeof</span>(sccno));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line">        dfs1(g[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sccno[u]) <span class="keyword">return</span>;</span><br><span class="line">    sccno[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rg[u].size(); ++i) &#123;</span><br><span class="line">        dfs2(rg[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dfs1(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!sccno[s[i]]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            dfs2(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">            rg[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        Kosaraju(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (cnt == <span class="number">1</span>? <span class="string">"Yes"</span>: <span class="string">"No"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>强连通分量</tag>
        <tag>图论</tag>
        <tag>模板题</tag>
        <tag>Kosaraju</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1392 Surround the Trees (凸包周长)</title>
    <url>/2019/08/16/HDU-1392-Surround-the-Trees-%E5%87%B8%E5%8C%85%E5%91%A8%E9%95%BF/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1392" target="_blank" rel="noopener">HDU 1392</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>There are a lot of trees in an area. A peasant wants to buy a rope to surround all these trees. So at first he must know the minimal required length of the rope. However, he does not know how to calculate it. Can you help him? </p>
<p>The diameter and length of the trees are omitted, which means a tree can be seen as a point. The thickness of the rope is also omitted which means a rope can be seen as a line.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/16/1565965282361-1565965283259.png" alt=""></p>
<p>There are no more than 100 trees.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains one or more data sets. At first line of each input data set is number of trees in this data set, it is followed by series of coordinates of the trees. Each coordinate is a positive integer pair, and each integer is less than 32767. Each pair is separated by blank.</p>
<p>Zero at line for number of trees terminates the input for your program.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The minimal length of the rope. The precision should be 10^-2.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9 </span><br><span class="line">12 7 </span><br><span class="line">24 9 </span><br><span class="line">30 5 </span><br><span class="line">41 9 </span><br><span class="line">80 7 </span><br><span class="line">50 87 </span><br><span class="line">22 9 </span><br><span class="line">45 1 </span><br><span class="line">50 7 </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">243.06</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p>Asia 1997, Shanghai (Mainland China)</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定若干个点的坐标，求凸包周长。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>凸包</strong></p>
<p>凸包入门模板题，我用的是 $Andrew$ 算法 </p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> a, <span class="keyword">double</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; b.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; b.x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[maxn], stk[maxn];</span><br><span class="line"><span class="keyword">typedef</span> Point Vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vec a, Vec b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; k &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = Andrew();</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t; i++) &#123;</span><br><span class="line">            ans += dist(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, n == <span class="number">2</span> ? ans / <span class="number">2</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1575 Tr A (矩阵快速幂)</title>
    <url>/2019/08/27/HDU-1575-Tr-A-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1575" target="_blank" rel="noopener">HDU 1575</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。  </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>数据的第一行是一个T，表示有T组数据。 </p>
<p>每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。  </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对应每组数据，输出Tr(A^k)%9973。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">3 99999999</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2686</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>矩阵快速幂</strong></p>
<p>矩阵快速幂模板题。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">    Matrix(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>) : n(n), m(m) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld"</span>, a[i][j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, j == n? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m) &#123;</span><br><span class="line">            init();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                a[i][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix b) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">c</span><span class="params">(n, b.m)</span></span>;</span><br><span class="line">        c.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c.n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c.m; ++j) &#123;</span><br><span class="line">                    c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">qmod</span><span class="params">(ll b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m) &#123;</span><br><span class="line">            Matrix a = *<span class="keyword">this</span>;</span><br><span class="line">            Matrix ans = Matrix(n, n);</span><br><span class="line">            ans.unit();</span><br><span class="line">            <span class="keyword">if</span>(!b) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">while</span>(b) &#123;</span><br><span class="line">                <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">                a = a * a;</span><br><span class="line">                b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="function">Matrix <span class="title">m</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        m.input();</span><br><span class="line">        m = m.qmod(k);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans = (ans + m.a[i][i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1548 A strange lift (BFS)</title>
    <url>/2019/08/06/HDU-1548-A-strange-lift-BFS/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1548" target="_blank" rel="noopener">HDU 1548</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>There is a strange lift.The lift can stop can at every floor as you want, and there is a number Ki(0 &lt;= Ki &lt;= N) on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up Ki floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down Ki floor,i.e,you will go to the i-Ki th floor. Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and k1 = 3, k2 = 3,k3 = 1,k4 = 2, k5 = 5.Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist. </p>
<p>Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of several test cases.,Each test case contains two lines.<br>The first line contains three integers N ,A,B( 1 &lt;= N,A,B &lt;= 200) which describe above,The second line consist N integers k1,k2,….kn.<br>A single 0 indicate the end of the input.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">3 3 1 2 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一幢楼有 n 层，电梯在每一层都可以上或者下 k 层，问能不能从 A 层到达 B 层，如果能输出最少坐几次电梯，如果不能输出 -1。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>BFS 水题</p>
<p>使用 BFS 求最少次数，每次搜索两种状态：上或下，如果能到达 B 层，就输出最先到达的步数，如果不能输出-1。</p>
<p>注：此题还可用 Dijkstra 求解。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, A, B;</span><br><span class="line"><span class="keyword">int</span> k[maxn], dis[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span>(x == B) <span class="keyword">return</span> dis[x];  <span class="comment">// 如果到达 B 层就输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = x + i * k[x];  <span class="comment">// 往上或者往下</span></span><br><span class="line">            <span class="comment">// 判断楼层是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; tmp &lt;= n &amp;&amp; !vis[tmp]) &#123;</span><br><span class="line">                dis[tmp] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                vis[tmp] = <span class="number">1</span>;</span><br><span class="line">                que.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 无法到达 B 层</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dis[i] = inf;</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dis[A] = <span class="number">0</span>;</span><br><span class="line">        vis[A] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索并输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(A));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1686 Oulipo (KMP)</title>
    <url>/2019/10/30/HDU-1686-Oulipo-KMP/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1686" target="_blank" rel="noopener">HDU 1686</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book:</p>
<p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p>
<p>Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces.</p>
<p>So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:</p>
<p>One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W).<br>One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">BAPC</span><br><span class="line">BAPC</span><br><span class="line">AZA</span><br><span class="line">AZAZAZA</span><br><span class="line">VERDI</span><br><span class="line">AVERDXIVYERDIAN</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%BB%AA%B6%AB%C7%F8%B4%F3%D1%A7%C9%FA%B3%CC%D0%F2%C9%E8%BC%C6%D1%FB%C7%EB%C8%FC_%C8%C8%C9%ED%C8%FC&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">华东区大学生程序设计邀请赛_热身赛</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串，求第一个字符串在第二个字符串中出现的次数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>KMP 模板题。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix_function</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) ++j;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pi = prefix_function(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; t.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) ++i;</span><br><span class="line">            <span class="keyword">else</span> j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == p.size()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">string</span> p, t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; t;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; kmp(p, t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1700 Points on Cycle (坐标旋转)</title>
    <url>/2019/09/28/HDU-1700-Points-on-Cycle-%E5%9D%90%E6%A0%87%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1700" target="_blank" rel="noopener">HDU 1700</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>There is a cycle with its center on the origin.</p>
<p>Now give you a point on the cycle, you are to find out the other two points on it, to maximize the sum of the distance between each other</p>
<p>you may assume that the radius of the cycle will not exceed 1000.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>There are T test cases, in each case there are 2 decimal number representing the coordinate of the given point.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each testcase you are supposed to output the coordinates of both of the unknow points by 3 decimal places of precision</p>
<p>Alway output the lower one first(with a smaller Y-coordinate value), if they have the same Y value output the one with a smaller X.</p>
<blockquote>
<p>NOTE</p>
<p>when output, if the absolute difference between the coordinate values X1 and X2 is smaller than 0.0005, we assume they are equal.</p>
</blockquote>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1.500 2.000</span><br><span class="line">563.585 1.251</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0.982 -2.299 -2.482 0.299</span><br><span class="line">-280.709 -488.704 -282.876 487.453</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2007%CA%A1%C8%FC%BC%AF%D1%B5%B6%D3%C1%B7%CF%B0%C8%FC%A3%A81%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2007省赛集训队练习赛（1）</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个圆形在原点的圆和一个圆上的点，在圆上另外找两个点使得三个点组成的三角形周长最大。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>坐标旋转</strong></p>
<p>坐标旋转模板题。</p>
<p>三角形是等边三角形是周长最大。</p>
<p>让给定的点绕原点旋转 $120\degree$ 和 $240\degree$ 即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(y - a.y))? dcmp(x - a.x) &lt; <span class="number">0</span>: y &lt; a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * <span class="built_in">cos</span>(rad) - y * <span class="built_in">sin</span>(rad), x * <span class="built_in">sin</span>(rad) + y * <span class="built_in">cos</span>(rad));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point ans[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Point p;</span><br><span class="line">        p.input();</span><br><span class="line">        <span class="keyword">double</span> r = <span class="number">2.0</span> * pi / <span class="number">3.0</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = p.Rotate(r);</span><br><span class="line">        ans[<span class="number">1</span>] = p.Rotate(r * <span class="number">2</span>);</span><br><span class="line">        sort(ans, ans + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf %.3lf %.3lf %.3lf\n"</span>, ans[<span class="number">0</span>].x, ans[<span class="number">0</span>].y, ans[<span class="number">1</span>].x, ans[<span class="number">1</span>].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>坐标旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1711 Number Sequence (KMP)</title>
    <url>/2019/10/29/HDU-1711-Number-Sequence-KMP/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1711" target="_blank" rel="noopener">HDU 1711</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000].</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">13 5</span><br><span class="line">1 2 1 2 3 1 2 3 1 3 2 1 2</span><br><span class="line">1 2 3 1 3</span><br><span class="line">13 5</span><br><span class="line">1 2 1 2 3 1 2 3 1 3 2 1 2</span><br><span class="line">1 2 3 2 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+2007-Spring+Programming+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">HDU 2007-Spring Programming Contest</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个大小分别为 $n$ 和 $m$ 的数组，求第二个数组在第一个数组中出现的位置。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>KMP 模板题。把字符串改成数组就行了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>, maxm = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxm], pi[maxm];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prefix_function</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; b[i] != b[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(b[i] == b[j]) ++j;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    prefix_function(m);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) ++i;</span><br><span class="line">            <span class="keyword">else</span> j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = kmp(n, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1724 Ellipse (自适应辛普森积分)</title>
    <url>/2019/10/23/HDU-1724-Ellipse-%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1724" target="_blank" rel="noopener">HDU 1724</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Math is important!! Many students failed in 2+2’s mathematical test, so let’s AC this problem to mourn for our lost youth..</p>
<p>Look this sample picture:</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/23/1571842055416-1571842055662.png" alt=""></p>
<p>A ellipses in the plane and center in point O. the L,R lines will be vertical through the X-axis. The problem is calculating the blue intersection area. But calculating the intersection area is dull, so I have turn to you, a talent of programmer. Your task is tell me the result of calculations.(defined PI=3.14159265 , The area of an ellipse A=PI<em>a</em>b )</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input may contain multiple test cases. The first line is a positive integer N, denoting the number of test cases below. One case One line. The line will consist of a pair of integers a and b, denoting the ellipse equation $\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$, A pair of integers l and r, mean the L is (l, 0) and R is (r, 0). (-a &lt;= l &lt;= r &lt;= a).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, output one line containing a float, the area of the intersection, accurate to three decimals after the decimal point.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 1 -2 2</span><br><span class="line">2 1 0 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6.283</span><br><span class="line">3.142</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HZIEE+2007+Programming+Contest+&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">HZIEE 2007 Programming Contest</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定椭圆和两条直线，求上图阴影部分的面积。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>自适应辛普森积分</strong></p>
<p>Simpson 积分是数值计算中用来近似求解积分值的一种方法。公式如下：</p>
<script type="math/tex; mode=display">\int_a^bf(x)dx \approx \frac{b - a}{a}(f(a) + 4f(\frac{a + b}{2}) + f(b))</script><p>普通的 Simpson 积分误差比较大，一般使用自适应 Simpson 积分。</p>
<p>代码中的自适应 Simpson 积分来自 Kuangbin 的模板。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line">db a, b, l, r;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">F</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="number">1</span> - x * x / a / a) * b * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">simpson</span><span class="params">(db a, db b)</span> </span>&#123;</span><br><span class="line">    db c = a + (b - a) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (F(a) + <span class="number">4</span> * F(c) + F(b)) * (b - a) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">asr</span><span class="params">(db a, db b, db eps, db A)</span> </span>&#123;</span><br><span class="line">    db c = a + (b - a) / <span class="number">2</span>;</span><br><span class="line">    db L = simpson(a, c), R = simpson(c, b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(L + R - A) &lt;= <span class="number">15</span> * eps) <span class="keyword">return</span> L + R + (L + R - A) / <span class="number">15.0</span>;</span><br><span class="line">    <span class="keyword">return</span> asr(a, c, eps / <span class="number">2</span>, L) + asr(c, b, eps / <span class="number">2</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">asr</span><span class="params">(db a, db b, db eps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asr(a, b, eps, simpson(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;a, &amp;b, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, <span class="number">2.0</span> * asr(l, r, eps));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>模板题</tag>
        <tag>自适应辛普森积分/自适应Simpson积分</tag>
        <tag>数值计算</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1847 Good Luck in CET-4 Everybody!  (巴什博弈)</title>
    <url>/2019/10/07/HDU-1847-Good-Luck-in-CET-4-Everybody-%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" target="_blank" rel="noopener">HDU 1847</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。</p>
<p>“升级”？“双扣”？“红五”？还是“斗地主”？</p>
<p>当然都不是！那多俗啊~</p>
<p>作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的：</p>
<p>1、  总共n张牌;</p>
<p>2、  双方轮流抓牌；</p>
<p>3、  每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）</p>
<p>4、  抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；</p>
<p>假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？</p>
<p>当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。</p>
<p>Good luck in CET-4 everybody!</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Kiki</span><br><span class="line">Cici</span><br></pre></td></tr></table></figure>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><blockquote>
<p>lcy</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ACM+Short+Term+Exam_2007%2F12%2F13&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ACM Short Term Exam_2007/12/13</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 张牌，两个人轮流抓牌，每次可以取 $2^i$ 张，最后取完的人获胜，求获胜者。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所有的数要么是 $3$ 的倍数，要么是 $3$ 的倍数余 $1$，要么是 $3$ 的倍数余 $2$。</p>
<p>如果轮到对手时且只剩下 $3$ 张牌，那么对手只能取 $1$ 张或 $2$ 张，对手必败。</p>
<p>如果轮到对手时且只剩下 $3i$ 张牌，那么不管对手取几张，剩下的牌数为 $3j + 1$ 或 $3j + 2$，然后你只要取走余数，又构造一个 $3$ 的倍数。</p>
<p>所以牌数为 $3$ 的倍数时先手必败，否则先手必胜。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Kiki"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cici"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>巴什博弈</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1879 继续畅通工程 (最小生成树)</title>
    <url>/2019/09/20/HDU-1879-%E7%BB%A7%E7%BB%AD%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1879" target="_blank" rel="noopener">HDU 1879</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。</p>
</blockquote>
<a id="more"></a> 
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1&lt; N &lt; 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。</p>
<p>当N为0时输入结束。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>每个测试用例的输出占一行，输出全省畅通需要的最低成本。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 0</span><br><span class="line">2 3 4 0</span><br><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 0</span><br><span class="line">2 3 4 1</span><br><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 1</span><br><span class="line">2 3 4 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><blockquote>
<p>ZJU</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%D5%E3%B4%F3%BC%C6%CB%E3%BB%FA%D1%D0%BE%BF%C9%FA%B8%B4%CA%D4%C9%CF%BB%FA%BF%BC%CA%D4-2008%C4%EA&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">浙大计算机研究生复试上机考试-2008年</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>最小生成树</strong></p>
<p>最小生成树裸题。把已建的道路的成本设为 0，跑一遍最小生成树即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> far[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) far[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(far[x] != x) far[x] = find(far[x]);</span><br><span class="line">    <span class="keyword">return</span> far[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    init(n);</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(edge[i].u);</span><br><span class="line">        <span class="keyword">int</span> y = find(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">            far[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> f;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w &gt;&gt; f;</span><br><span class="line">            <span class="keyword">if</span>(f) &#123;</span><br><span class="line">                edge[i].w = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Kruskal(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>模板题</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1875 畅通工程再续 (Prim)</title>
    <url>/2019/10/18/HDU-1875-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD-Prim/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1875" target="_blank" rel="noopener">HDU 1875</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。</p>
<p>每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">20 20</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1414.2</span><br><span class="line">oh!</span><br></pre></td></tr></table></figure>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><blockquote>
<p>8600</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2008%D5%E3%B4%F3%D1%D0%BE%BF%C9%FA%B8%B4%CA%D4%C8%C8%C9%ED%C8%FC%A3%A82%A3%A9%A1%AA%A1%AA%C8%AB%D5%E6%C4%A3%C4%E2&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2008浙大研究生复试热身赛（2）——全真模拟</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个小岛的坐标，要在小岛间建桥，联通所有的岛。建桥的条件是两个小岛间距离为 $[10, 1000]$，建桥的价格是 $100$ 元/米，求最小造价。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最小生成树裸题。</p>
<p>只有小岛距离在 $[10, 1000]$ 才建边。</p>
<p>注意 $double$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> db inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;db, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    db x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    db w;</span><br><span class="line">    Edge(<span class="keyword">int</span> to, db w): to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point p[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[N];</span><br><span class="line">db d[N];</span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, db z)</span> </span>&#123;</span><br><span class="line">    G[x].push_back(Edge(y, z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        d[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    db ans = <span class="number">0</span>;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(P(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        P p = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        ans += d[x];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge e = G[x][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &gt; e.w &amp;&amp; !v[e.to]) &#123;</span><br><span class="line">                d[e.to] = e.w;</span><br><span class="line">                q.push(P(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                db tmp = dis(p[i], p[j]);</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                    add(i, j, tmp);</span><br><span class="line">                    add(j, i, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        db ans = prim(<span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"oh!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2087 剪花布条 (KMP)</title>
    <url>/2019/11/01/HDU-2087-%E5%89%AA%E8%8A%B1%E5%B8%83%E6%9D%A1-KMP/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2087" target="_blank" rel="noopener">HDU 2087</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">abcde a3</span><br><span class="line">aaaaaa  aa</span><br><span class="line"><span class="section">#</span></span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%B6%AC%C1%B7%C8%FD%BE%C5%D6%AE%B6%FE&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">冬练三九之二</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>KMP 裸题，每次匹配成功后模式串指针指向模式串首就行了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pi[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prefix_function</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pi, <span class="number">0</span>, <span class="keyword">sizeof</span>(pi));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) ++j;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> t, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    prefix_function(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; t.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) ++i;</span><br><span class="line">            <span class="keyword">else</span> j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == p.size()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> t, p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; kmp(t, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2063 过山车 (匈牙利算法)</title>
    <url>/2019/11/18/HDU-2063-%E8%BF%87%E5%B1%B1%E8%BD%A6-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="HDU-2063-过山车-匈牙利算法"><a href="#HDU-2063-过山车-匈牙利算法" class="headerlink" title="HDU 2063 过山车 (匈牙利算法)"></a>HDU 2063 过山车 (匈牙利算法)</h1><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener">HDU 2063</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000<br>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6 3 3</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=RPG%D7%A8%B3%A1%C1%B7%CF%B0%C8%FC&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">RPG专场练习赛</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分图最大匹配。</p>
<p>可以用最大流解决。也可以用匈牙利算法。匈牙利算法是最大流方法的一种优化。若采用邻接矩阵存图，时间复杂度 $O(V^2)$，空间复杂度 $O(V^2)$。若采用邻接表，时间复杂度 $O(VE)$，空间复杂度 $O(V+E)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], ok[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; g[x][i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ok[i] || dfs(ok[i])) &#123;</span><br><span class="line">                ok[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(ok, <span class="number">0</span>, <span class="keyword">sizeof</span>(ok));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            g[a][b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i)) ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>匈牙利算法</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2266 How Many Equations Can You Find (DFS)</title>
    <url>/2019/08/06/HDU-2266-How-Many-Equations-Can-You-Find-DFS/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2266" target="_blank" rel="noopener">HDU 2266</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Now give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Each case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The output contains one line for each data set : the number of ways you can find to make the equation.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">123456789 3</span><br><span class="line">21 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">18</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一串只包含数字的字符串，和一个数 n，在串中任意两个相邻的字符之间加上 + 或 - 构成表达式，问表达式的值有多少种情况等于 n。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>DFS 水题</p>
<p>每个位置可以选择加入符号或者不加，用 DFS 搜索即可，计算最终表达式是否等于 n，注意开头不能放减号。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">ll n;</span><br><span class="line">ll len;</span><br><span class="line">ll cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l为插入符号的位置 sum为当前表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll l, ll sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == len &amp;&amp; sum == n) &#123;</span><br><span class="line">        <span class="comment">// 如果没有位置可以放入符号了并且表达式值等于 n 就累加 cnt</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 搜索剩余表达式</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = l; i &lt; len; ++i) &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;  <span class="comment">// 从 l 到 i 置为数字</span></span><br><span class="line">        dfs(i + <span class="number">1</span>, sum + ans);   <span class="comment">// i + 1 位置置为加号</span></span><br><span class="line">        <span class="keyword">if</span>(l) dfs(i + <span class="number">1</span>, sum - ans);  <span class="comment">// i + 1 位置置为减号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s %lld"</span>, str, &amp;n)) &#123;  <span class="comment">// 多组输入</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(str);  <span class="comment">// 字符串长度</span></span><br><span class="line">        cnt = <span class="number">0</span>;  <span class="comment">// 最终答案</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2512 一卡通大冒险 (第二类斯特林数)</title>
    <url>/2019/11/17/HDU-2512-%E4%B8%80%E5%8D%A1%E9%80%9A%E5%A4%A7%E5%86%92%E9%99%A9-%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2512" target="_blank" rel="noopener">HDU 2512</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>因为长期钻研算法， 无暇顾及个人问题，BUAA ACM/ICPC 训练小组的帅哥们大部分都是单身。某天，他们在机房商量一个绝妙的计划”一卡通大冒险”。这个计划是由wf最先提出来的，计划的内容是，把自己的联系方式写在校园一卡通的背面，然后故意将自己的卡”遗失”在某处（如水房，TD，食堂，主M。。。。）他们希望能有MM看到他们遗失卡，能主动跟他们联系，这样就有机会请MM吃饭了。他们决定将自己的一卡通夹在基本相同的书里，然后再将书遗失到校园的各个角落。正当大家为这个绝妙的计划叫好时，大家想到一个问题。很明显，如果只有一张一卡通，那么只有一种方法，即，将其夹入一本书中。当有两张一卡通时，就有了两种选择，即，将两张一卡通夹在一本书里，或者分开夹在不同的书里。当有三张一卡通时，他们就有了5种选择，即：</p>
<p>((A),(B),(C)) , ((A,B),(C)), ((B,C),(A)), ((A,C),(B)) ,((A,B,C)) 于是，</p>
<p>这个邪恶计划的组织者wf希望了解，如果ACM训练对里有n位帅哥（即有N张一卡通），那么要把这些一卡通夹到书里有多少种不同的方法。</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>包含多组数据，第一行为n，表示接下来有n组数据。以下每行一个数x，表示共有x张一卡通。(1≤x≤2000).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对每组数据，输出一行：不同的方法数，因为这个数可能非常大，我们只需要它除以1000的余数。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">751</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=ECJTU+2008+Autumn+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">ECJTU 2008 Autumn Contest</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将 $n$ 个各不相同的物品放到若干个相同的盒子，很明显就是第二类 Stirling 数。</p>
<p>题目中要把 $1$ 到 $n$ 个盒子的方案数加起来。该方案总数也称为贝尔 (Bell) 数。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        s[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        s[i][i] = <span class="number">1</span>;</span><br><span class="line">        sum[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            s[i][j] = (s[i - <span class="number">1</span>][j - <span class="number">1</span>] + j * s[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            sum[i] = (sum[i] + s[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>斯特林数/Stirling number</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2553 N皇后问题 (DFS)</title>
    <url>/2019/08/14/HDU-2553-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98-DFS/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2553" target="_blank" rel="noopener">HDU 2553</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>在 $N*N$ 的方格棋盘放置了 $N$ 个皇后，使得它们不相互攻击（即任意 $2$ 个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成 $45$ 角的斜线上。 </p>
<p>你的任务是，对于给定的 $N$，求出有多少种合法的放置方法。 </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>共有若干行，每行一个正整数 $N\le 10$，表示棋盘和皇后的数量；如果 $N=0$，表示结束。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">92</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>DFS</strong></p>
<p>每行放置一个，位置用 $pos[i]$ 表示，这样就不用处理行冲突的问题；保证每行的 $pos$ 不同，就可以解决列冲突的问题；最后要保证不在同一斜线上。</p>
<p>注意此题要打表。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// k表示第 k行 也表示放第 k个皇后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nqueen</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == n) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 判断当前位置是否和之前的所有棋子有冲突</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[j] == i || <span class="built_in">abs</span>(pos[j] - i) == <span class="built_in">abs</span>(j - k)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for循环跑完表示没有冲突</span></span><br><span class="line">        <span class="keyword">if</span>(j == k) &#123;</span><br><span class="line">            pos[k] = i;  <span class="comment">// 记录合法的位置</span></span><br><span class="line">            nqueen(k + <span class="number">1</span>);  <span class="comment">// 搜索下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 打表</span></span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; n &lt;= <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        nqueen(<span class="number">0</span>);</span><br><span class="line">        a[n] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2899 Strange fuction (模拟退火)</title>
    <url>/2019/10/31/HDU-2899-Strange-fuction-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2899" target="_blank" rel="noopener">HDU 2899</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Now, here is a fuction:</p>
<p> F(x) = 6x^7+8x^6+7x^3+5x^2-yx (0 &lt;= x &lt;=100)</p>
<p>Can you find the minimum value when x is between 0 and 100.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">100</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-74.4291</span><br><span class="line">-178.8534</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $y$，求函数 $F(x) = 6x^7 + 8x^6 + 7x^3 + 5x^2 - yx$ 的最小值，其中 $x$ 的范围是 $[0, 100]$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>模拟退火</strong></p>
<p>模拟退火算法是一种随机化算法，在数学建模中比较常见，在 ACM 中不太常用。主要用于求解函数 (不是单峰函数的时候) 的最值，在最小圆/球覆盖中也有应用。</p>
<p>模拟退火算法基于物理退火的原理，将固体加热至高温然后冷却，温度越高降温的概率越大 (降温更快)，温度越低降温的概率越小 (降温越慢)。模拟退火算法进行多次降温，直到找到一个可行解。</p>
<p>简单来说，如果新的状态比当前状态更优就接受该状态，否则以一定概率接受新状态。概率为：$P(\Delta E) = e^{\frac{-\Delta E}{T}}$，其中 $T$ 为当前温度，$\Delta E$ 新状态与当前状态的能量差。</p>
<p>模拟退火主要有三个参数：初始温度 $T_0$，降温系数 $d$，终止温度 $T_k$。</p>
<p>让当前温度 $T = T_0$，温度下降，尝试转移，如果转移 $T = d * T$。当 $T &lt; T_k$ 时结束模拟退火算法。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T0 &#x3D; 100000;  &#x2F;&#x2F; 初始温度为高温，设置成一个大数</span><br><span class="line">Tk &#x3D; 1e-8;  &#x2F;&#x2F; 终止温度为低温，设置为一个接近于0的数</span><br><span class="line">d &#x3D; 0.98;  &#x2F;&#x2F; d是一个小于1但是非常接近于1的数</span><br><span class="line">f(x);  &#x2F;&#x2F; 评价函数，比如物理意义上的温度</span><br><span class="line">T &#x3D; T0;  &#x2F;&#x2F; 当前温度</span><br><span class="line">now, nxt;  &#x2F;&#x2F; 当前状态与新状态</span><br><span class="line">while(T &gt; Tk) &#123;</span><br><span class="line">    dE &#x3D; f(now) - f(nxt);  &#x2F;&#x2F; 能量差</span><br><span class="line">    if(dE &gt;&#x3D; 0) &#123;  &#x2F;&#x2F; 新状态更优就接受</span><br><span class="line">        now &#x3D; nxt;</span><br><span class="line">    &#125; else if(exp(-dE&#x2F;T) &gt; rand()) &#123;  &#x2F;&#x2F; 否则以一定概率接受</span><br><span class="line">        now &#x3D; nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    T *&#x3D; d;  &#x2F;&#x2F; 降温</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟退火算法的缺点主要是精度不高，求得的是近似最优解而不是最优解。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db Tk = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> db T0 = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> db d = <span class="number">0.98</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 评估函数</span></span><br><span class="line"><span class="function">db <span class="title">func</span><span class="params">(db x, db y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span> * <span class="built_in">pow</span>(x, <span class="number">7.0</span>) + <span class="number">8</span> * <span class="built_in">pow</span>(x, <span class="number">6.0</span>) + <span class="number">7</span> * <span class="built_in">pow</span>(x, <span class="number">3.0</span>) + <span class="number">5</span> * <span class="built_in">pow</span>(x, <span class="number">2.0</span>) - y * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟退火</span></span><br><span class="line"><span class="function">db <span class="title">simulateAnneal</span><span class="params">(db y)</span> </span>&#123;</span><br><span class="line">    db T = T0;</span><br><span class="line">    db x = <span class="number">50.0</span>;  <span class="comment">// x的初始值</span></span><br><span class="line">    db now = func(x, y);  <span class="comment">// 当前状态</span></span><br><span class="line">    db nxt;</span><br><span class="line">    db ans = now;  <span class="comment">// 最优解</span></span><br><span class="line">    <span class="keyword">while</span>(T &gt; Tk) &#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        db newx = x + f[rand() % <span class="number">2</span>] * T;  <span class="comment">// 按概率改变x，温度越低概率越小</span></span><br><span class="line">        <span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newx &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            nxt = func(newx, y);  <span class="comment">// 新状态</span></span><br><span class="line">            ans = min(ans, nxt);  <span class="comment">// 在退火过程中维护遇到的所有解的最优值</span></span><br><span class="line">            db dE = now - nxt;  <span class="comment">// 能量差</span></span><br><span class="line">            <span class="keyword">if</span>(dE &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                now = nxt;</span><br><span class="line">                x = newx;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(dE / T) &gt; rand()) &#123;</span><br><span class="line">                now = nxt;</span><br><span class="line">                x = newx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T *= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    db y;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, simulateAnneal(y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="https://oi-wiki.org/misc/simulated-annealing/" target="_blank" rel="noopener">OI-Wiki 模拟退火</a></p>
<p>《算法竞赛 入门到进阶》罗勇军 郭卫斌 著</p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数值计算</tag>
        <tag>模拟退火</tag>
        <tag>随机化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3746 Cyclic Nacklace (KMP找循环节)</title>
    <url>/2019/11/03/HDU-3746-Cyclic-Nacklace-KMP%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3746" target="_blank" rel="noopener">HDU 3746</a></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/03/1572791173434-1572791173438.png" alt=""></p>
<a id="more"></a>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aaa</span><br><span class="line">abca</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><blockquote>
<p>possessor WC</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+3rd+%A1%B0Vegetable-Birds+Cup%A1%B1+Programming+Open+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">HDU 3rd “Vegetable-Birds Cup” Programming Open Contest</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串，问至少需要在末尾添加多少个字符使得字符串循环。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>KMP</strong></p>
<p>设前缀函数为 $\pi()$，字符串长度为 $n$，下标从 $1$ 开始。</p>
<p>最小循环节为 $k = n - \pi(n)$。</p>
<p>如果 $n \% k=0$，那么字符串已经循环。</p>
<p>否则还需要添加 $k - n \% k$ 个字符。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, pi[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prefix_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[j+<span class="number">1</span>] != str[i]) j = pi[j];</span><br><span class="line">		<span class="keyword">if</span> (str[j+<span class="number">1</span>] == str[i]) j++;</span><br><span class="line">		pi[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">		n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">		prefix_function();</span><br><span class="line">		<span class="keyword">if</span>(pi[n] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> k = n - pi[n];</span><br><span class="line">			<span class="keyword">if</span>(n % k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k - n % k);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3949 XOR (线性基)</title>
    <url>/2019/08/28/HDU-3949-XOR-%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3949" target="_blank" rel="noopener">HDU 3949</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>XOR is a kind of bit operator, we define that as follow: for two binary base number A and B, let C=A XOR B, then for each bit of C, we can get its value by check the digit of corresponding position in A and B. And for each digit, 1 XOR 1 = 0, 1 XOR 0 = 1, 0 XOR 1 = 1, 0 XOR 0 = 0. And we simply write this operator as ^, like 3 ^ 1 = 2,4 ^ 3 = 7. XOR is an amazing operator and this is a question about XOR. We can choose several numbers and do XOR operatorion to them one by one, then we get another number. For example, if we choose 2,3 and 4, we can get 2^3^4=5. Now, you are given N numbers, and you can choose some of them(even a single number) to do XOR on them, and you can get many different numbers. Now I want you tell me which number is the K-th smallest number among them.  </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>First line of the input is a single integer T(T&lt;=30), indicates there are T test cases. </p>
<p>For each test case, the first line is an integer N(1&lt;=N&lt;=10000), the number of numbers below. The second line contains N integers (each number is between 1 and 10^18). The third line is a number Q(1&lt;=Q&lt;=10000), the number of queries. The fourth line contains Q numbers(each number is between 1 and 10^18) K1,K2,……KQ.  </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case,first output Case #C: in a single line,C means the number of the test case which is from 1 to T. Then for each query, you should output a single line contains the Ki-th smallest number in them, if there are less than Ki different numbers, output -1.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case #1:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">-1</span><br><span class="line">Case #2:</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>If you choose a single number, the result you get is the number you choose.</p>
<p>Using long long instead of int because of the result may exceed 2^31-1.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数，$q$ 个询问。</p>
<p>每个询问包含一个正整数 $k$。在 $n$ 个数中选择若干个数求异或和。求所有异或和中第 $k$ 小的异或和。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>线性基</strong></p>
<p>首先，原数集 $S$ 的所有异或和与线性基 $P$ 的所有异或和是相同的。所有的异或和就是线性基中所有的基的线性组合。</p>
<p>构造一个特殊的线性基，使得线性基中每一个行向量都是最小的。也就是每个行向量的最高位的 $1$ 所在的列向量只有一个 $1$。此时所有异或和不变。</p>
<p>求第 $k$ 小的数，把 $k$ 转成二进制，第 $i$ 位为 $1$ 表示取第 $i$ 小的行向量。</p>
<p><strong>注</strong>：异或和的个数有两种情况。异或和包含 $0$ 和不包含 $0$。如果两个向量线性相关，则一定可以通过异或得到 $0$。而线性基是极大线性无关组，若 $|S| = |P|$，则不能得到 $0$，否则一定可以。若可以得到 $0$，则有 $2^{|P|}$ 个异或和，否则有 $2^{|P|} - 1$ 个异或和。</p>
<p><strong>举个例子</strong></p>
<p>假设 $S = {1, 5, 8, 9, 20}$</p>
<p>线性基为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 0 1 0 1</span><br><span class="line">0 0 0 0 1</span><br></pre></td></tr></table></figure>
<p>构造上述的特殊线性基</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 0 0 0</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 0 1</span><br></pre></td></tr></table></figure>
<p>共有 $2^{4} = 16$ 个异或和 (包含 $0$)。</p>
<p>当 $k = 1$ 时，二进制为 $(00001)_2$，取第一小的行向量，即最后一行，因此答案为 $(00001)_2$。</p>
<p>当 $k = 2$ 时，二进制为 $(00010)_2$，取第二小的行向量，即第三行，因此答案为 $(00100)_2$。</p>
<p>当 $k = 3$ 时，二进制为 $(00011)_2$，取第一小的和第二小的行向量，即最后两行，因此答案为 $(00001)_2 xor (00100)_2 = (00101)_2$。</p>
<p>…</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxbit = <span class="number">63</span>;</span><br><span class="line"></span><br><span class="line">ll p[maxbit];</span><br><span class="line">ll tmp[maxbit];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                p[i] = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ll x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; maxbit; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>((p[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    p[j] ^= p[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxbit; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]) &#123;</span><br><span class="line">                tmp[cnt++] = p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            ll k;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="comment">// 判断异或和能否为 0 </span></span><br><span class="line">            <span class="keyword">if</span>(cnt != n) &#123;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 k 是否超过异或和能表示的数量</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt;= (<span class="number">1L</span>L &lt;&lt; cnt)) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxbit; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>((k&gt;&gt;i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    ans ^= tmp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5119 Happy Matt Friends (背包DP + 滚动数组)</title>
    <url>/2019/09/13/HDU-5119-Happy-Matt-Friends-%E8%83%8C%E5%8C%85DP-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5119" target="_blank" rel="noopener">HDU 5119</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Matt has N friends. They are playing a game together.</p>
<p>Each of Matt’s friends has a magic number. In the game, Matt selects some (could be zero) of his friends. If the xor (exclusive-or) sum of the selected friends’magic numbers is no less than M , Matt wins.</p>
<p>Matt wants to know the number of ways to win.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains only one integer $T$ , which indicates the number of test cases.</p>
<p>For each test case, the first line contains two integers $N, M (1 \le N \le 40, 0 \le M \le 10^6)$.</p>
<p>In the second line, there are $N$ integers $k_i (0 ≤ k_i ≤ 10^6)$, indicating the $i$-th friend’s magic number.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output a single line “Case #x: y”, where x is the case number (starting from 1) and y indicates the number of ways where Matt can win.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">1 2 3</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case #1: 4</span><br><span class="line">Case #2: 2</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>In the ﬁrst sample, Matt can win by selecting:</p>
<p>friend with number 1 and friend with number 2. The xor sum is 3.</p>
<p>friend with number 1 and friend with number 3. The xor sum is 2.</p>
<p>friend with number 2. The xor sum is 2.</p>
<p>friend with number 3. The xor sum is 3. Hence, the answer is 4.</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2014ACM%2FICPC%D1%C7%D6%DE%C7%F8%B1%B1%BE%A9%D5%BE-%D6%D8%CF%D6%C8%FC%A3%A8%B8%D0%D0%BB%B1%B1%CA%A6%BA%CD%C9%CF%BD%BB%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2014ACM/ICPC亚洲区北京站-重现赛（感谢北师和上交）</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数 $k[i]$，从中取出一些数使得异或和大于等于 $m$，求有几种取法。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>背包DP 滚动数组</strong></p>
<p>设 $dp[i][j]$ 表示前 $i$ 个数中异或和为 $j$ 的所有取法。状态转移方程为 $dp[i][j] = dp[i - 1][j] + dp[i - 1][j xor k[i]]$。</p>
<p>由于当前状态只和前一个状态有关，因此可以用滚动数组优化。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">10</span>][maxn];</span><br><span class="line">ll k[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j] + dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j ^ k[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; maxn; ++i) &#123;</span><br><span class="line">            ans += dp[n &amp; <span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; _ &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>动态规划</tag>
        <tag>背包DP</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4513 吉哥系列故事——完美队形II (Manacher)</title>
    <url>/2019/11/15/HDU-4513-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2II-Manacher/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4513" target="_blank" rel="noopener">HDU 4513</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>吉哥又想出了一个新的完美队形游戏！</p>
<p>假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] … h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：</p>
<p>1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；</p>
<p>2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；</p>
<p>3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &lt;= H[2] &lt;= H[3] …. &lt;= H[mid]。</p>
<p>现在吉哥想知道：最多能选出多少人组成新的完美队形呢？</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>输入数据第一行包含一个整数T，表示总共有T组测试数据(T &lt;= 20)；</p>
<p>每组数据首先是一个整数n(1 &lt;= n &lt;= 100000)，表示原先队形的人数，接下来一行输入n个整数，表示原队形从左到右站的人的身高（50 &lt;= h &lt;= 250，不排除特别矮小和高大的）。</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>请输出能组成完美队形的最多人数，每组输出占一行。</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">51 52 51</span><br><span class="line">4</span><br><span class="line">51 52 52 51</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2013%CC%DA%D1%B6%B1%E0%B3%CC%C2%ED%C0%AD%CB%C9%B3%F5%C8%FC%B5%DA%B6%FE%B3%A1%A3%A83%D4%C222%C8%D5%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2013腾讯编程马拉松初赛第二场（3月22日）</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在 Manacher 求最长回文子串时增加一个判断条件: h[i - len[i]] &lt;= h[i - len[i] + 2]</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[maxn &lt;&lt; <span class="number">1</span>], len[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n * <span class="number">2</span> + <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h[i - len[i]] == h[i + len[i]] &amp;&amp; h[i - len[i]] &lt;= h[i - len[i] + <span class="number">2</span>]) &#123;  <span class="comment">// 这里要保持递增</span></span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        h[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            h[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; h[i * <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        h[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5183 Negative and Positive (NP)  (手写哈希)</title>
    <url>/2019/11/08/HDU-5183-Negative-and-Positive-NP-%E6%89%8B%E5%86%99%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5183" target="_blank" rel="noopener">HDU 5183</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>When given an array $(a_0,a_1,a_2,⋯a_{n−1})$ and an integer $K$, you are expected to judge whether there is a pair $(i,j)(0≤i≤j&lt;n)$ which makes that $NP−sum(i,j)$ equals to $K$ true. Here $NP−sum(i,j)=a_i−a_{i+1}+a_{i+2}+⋯+(−1)^{j−i}a_j$</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Multi test cases. In the first line of the input file there is an integer $T$ indicates the number of test cases.</p>
<p>In the next $2∗T$ lines, it will list the data for each test case.</p>
<p>Each case occupies two lines, the first line contain two integers $n$ and $K$ which are mentioned above.</p>
<p>The second line contain $(a_0,a_1,a_2,⋯a_{n−1})$ separated by exact one space.</p>
<p>[Technical Specification]</p>
<p>All input items are integers.</p>
<p>$0&lt;T≤25,1≤n≤1000000,−1000000000≤a_i≤1000000000,−1000000000≤K≤1000000000$</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case，the output should occupies exactly one line. The output format is Case #id: ans, here id is the data number starting from 1; ans is “Yes.” or “No.” (without quote) according to whether you can find $(i,j)$ which makes $PN−sum(i,j)$ equals to $K$.</p>
<p>See the sample for more details.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">2 1</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case #1: Yes.</span><br><span class="line">Case #2: No.</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>If input is huge, fast IO method is recommended.</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><blockquote>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=BestCoder+Round+%2332&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">BestCoder Round #32</a></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长度为 $n$ 的数组，问是否存在一段区间其加减交错的和等于 $k$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对该数组求前缀和然后哈希就行。</p>
<p>不过这题不同的 set 过不了。</p>
<p>所以要手写哈希。</p>
<p>当然 unordered_set 也可以过。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashMap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[maxn], next[maxn];</span><br><span class="line">    ll num[maxn];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">abs</span>(val) % maxn;</span><br><span class="line">        num[tot] = val, next[tot] = head[h], head[h] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">find</span><span class="params">(ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">abs</span>(val) % maxn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[h]; ~i; i = next[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; hashmap;</span><br><span class="line"></span><br><span class="line">ll arr[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        hashmap.init();</span><br><span class="line">        ll n, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + (i &amp; <span class="number">1</span>? arr[i]: -arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">            hashmap.insert(sum[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmap.find(sum[i - <span class="number">1</span>] + k)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmap.find(sum[i - <span class="number">1</span>] - k)) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; (flag? <span class="string">"Yes."</span> : <span class="string">"No."</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>前缀和</tag>
        <tag>哈希/Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5251 矩形面积 (旋转卡壳)</title>
    <url>/2019/08/30/HDU-5251-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</url>
    <content><![CDATA[<p>2015年百度之星程序设计大赛 - 初赛(1) 1006</p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2015%C4%EA%B0%D9%B6%C8%D6%AE%D0%C7%B3%CC%D0%F2%C9%E8%BC%C6%B4%F3%C8%FC+-+%B3%F5%C8%FC%281%29&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2015年百度之星程序设计大赛 - 初赛(1)</a></p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5251" target="_blank" rel="noopener">HDU 5251</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>小度熊有一个桌面，小度熊剪了很多矩形放在桌面上，小度熊想知道能把这些矩形包围起来的面积最小的矩形的面积是多少。 </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>第一行一个正整数 $T$，代表测试数据组数 $(1\le T\le 20)$，接下来 $T$ 组测试数据。 </p>
<p>每组测试数据占若干行，第一行一个正整数 $N(1\le N\le 1000)$，代表矩形的数量。接下来 $N$ 行，每行 $8$ 个整数 $x1,y1,x2,y2,x3,y3,x4,y4$，代表矩形的四个点坐标，坐标绝对值不会超过10000。  </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>对于每组测试数据，输出两行： </p>
<p>第一行输出”Case #i:”，i 代表第 i 组测试数据。</p>
<p>第二行包含1 个数字，代表面积最小的矩形的面积，结果保留到整数位。 </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">5 10 5 8 3 10 3 8</span><br><span class="line">8 8 8 6 7 8 7 6</span><br><span class="line">1</span><br><span class="line">0 0 2 2 2 0 0 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case #1:</span><br><span class="line">17</span><br><span class="line">Case #2:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>旋转卡壳</strong></p>
<p>思路见这里：<a href="https://wutao18.github.io/2019/08/30/%E6%B4%9B%E8%B0%B7-P3187-BZOJ-1185-HNOI2007-%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/">洛谷 P3187 BZOJ 1185 [HNOI2007]最小矩形覆盖 (旋转卡壳)</a></p>
<p>杭电就比较良心了，没有卡精度。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * a, y * a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x &amp;&amp; y == a.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point ans[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = P.size(), k = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">H</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">    sort(P.begin(), P.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">2</span> &amp;&amp; cross(H[k - <span class="number">1</span>] - H[k - <span class="number">2</span>], P[i] - H[k - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        H[k++] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= t &amp;&amp; cross(H[k - <span class="number">1</span>] - H[k - <span class="number">2</span>], P[i - <span class="number">1</span>] - H[k - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        H[k++] = P[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H.resize(k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rotating_caliper</span><span class="params">(Polygon v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> min_s = <span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = v.size();</span><br><span class="line">    v.push_back(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">1</span>, r = <span class="number">1</span>, l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="comment">// 最上面的点</span></span><br><span class="line">        <span class="keyword">while</span> (dcmp(<span class="built_in">fabs</span>(cross(v[u] - v[i], v[i + <span class="number">1</span>] - v[i])) - <span class="built_in">fabs</span>(cross(v[u + <span class="number">1</span>] - v[i], v[i + <span class="number">1</span>] - v[i]))) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            u = (u + <span class="number">1</span>) % cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最右边的点</span></span><br><span class="line">        <span class="keyword">while</span> (dcmp(dot(v[r] - v[i], v[i + <span class="number">1</span>] - v[i]) - dot(v[r + <span class="number">1</span>] - v[i], v[i + <span class="number">1</span>] - v[i])) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r = (r + <span class="number">1</span>) % cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!i) l = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最左边的点</span></span><br><span class="line">        <span class="keyword">while</span> (dcmp(dot(v[l] - v[i], v[i + <span class="number">1</span>] - v[i]) - dot(v[l + <span class="number">1</span>] - v[i], v[i + <span class="number">1</span>] - v[i])) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            l = (l + <span class="number">1</span>) % cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> d = v[i].dis(v[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">double</span> R = dot(v[r] - v[i], v[i + <span class="number">1</span>] - v[i]) / d; </span><br><span class="line">        <span class="keyword">double</span> L = dot(v[l] - v[i], v[i + <span class="number">1</span>] - v[i]) / d;</span><br><span class="line">        <span class="keyword">double</span> ll = R - L;</span><br><span class="line">        <span class="keyword">double</span> dd = <span class="built_in">fabs</span>(cross(v[u] - v[i], v[i + <span class="number">1</span>] - v[i])) / d;</span><br><span class="line">        min_s = min(min_s, ll * dd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        Polygon s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            Point p;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p.x, &amp;p.y);</span><br><span class="line">            s.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        Polygon p = Andrew(s);</span><br><span class="line">        <span class="keyword">double</span> d = rotating_caliper(p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n%.0lf\n"</span>, _, d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5443 The Water Problem (ST算法)</title>
    <url>/2019/09/04/HDU-5443-The-Water-Problem-ST%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5443" target="_blank" rel="noopener">HDU 5443</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>In Land waterless, water is a very limited resource. People always fight for the biggest source of water. Given a sequence of water sources with $a_1,a_2,a_3,…,a_n$ representing the size of the water source. Given a set of queries each containing $2$ integers $l$ and $r$, please find out the biggest water source between $a_l$ and $a_r$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>First you are given an integer $T(T\le 10)$ indicating the number of test cases. For each test case, there is a number $n(0\le n\le 1000)$ on a line representing the number of water sources. $n$ integers follow, respectively $a_1,a_2,a_3,…,a_n$, and each integer is in ${1,…,10^6}$. On the next line, there is a number $q(0\le q\le 1000)$ representing the number of queries. After that, there will be $q$ lines with two integers $l$ and $r(1\le l\le r\le n)$ indicating the range of which you should find out the biggest water source.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each query, output an integer representing the size of the biggest water source.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">100</span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">3</span><br><span class="line">1 999999 1</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">999999</span><br><span class="line">999999</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2015+ACM%2FICPC+Asia+Regional+Changchun+Online&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2015 ACM/ICPC Asia Regional Changchun Online</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数，$q$ 个询问，每个询问包含 $l$ 和 $r$，求区间 $[l, r]$ 内的最大值。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>ST算法</strong></p>
<p>$RMQ$ 问题。ST 算法模板题。预处理时间 $O(nlogn)$，查询时间 $O(1)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">st_query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        st_prework();</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; st_query(l, r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>RMQ</tag>
        <tag>ST算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6590 Code (判断凸包相交)</title>
    <url>/2019/08/21/HDU-6590-Code-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/</url>
    <content><![CDATA[<p>2019 杭电多校 1 1013</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6590" target="_blank" rel="noopener">HDU 6590</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+1&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 1</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>After returning with honour from ICPC(International Cat Programming Contest) World Finals, Tom decides to say goodbye to ICPC and start a new period of life. He quickly gets interested in AI.</p>
<p>In the subject of Machine Learning, there is a classical classification model called perceptron, defined as follows:</p>
<p>Assuming we get a set of training samples: $D={(\boldsymbol{x_1},y_1),(\boldsymbol{x_2},y_2),…,(\boldsymbol{x_N},y_N)}$, with their inputs $\boldsymbol{x}\in \mathbb{R}^d$, and outputs $y\in \{−1,1\}$. We will try to find a function $f(\boldsymbol{x})=sign(\sum_{i=1}^d w_i\cdot x_i+b)=sign(\boldsymbol{w^T} \cdot \boldsymbol{x}+b)$ so that $f(\boldsymbol{x_i})=y_i,i=1,2,…,N$.</p>
<p>$\boldsymbol{w}, \boldsymbol{x}$ mentioned above are all d-dimensional vectors, i.e. $\boldsymbol{w}=(w_1,w_2,…,w_d), \boldsymbol{x}=(x_1,x_2,…,x_d)$. To simplify the question, let $w_0=b$, $x_0=1$, then $f(\boldsymbol{x})=sign(\sum_{i = 0}^d w_i\cdot x_i)=sign(\boldsymbol{w^T}\cdot \boldsymbol{x})$. Therefore, finding a satisfying function $f(\boldsymbol{x})$ is equivalent to finding a proper $\boldsymbol{w}$.</p>
<p>To solve the problem, we have a algorithm, PLA(Popcorn Label Algorithm).</p>
<p>Accoding to <em>PLA</em>, we will randomly generate $\boldsymbol{w}$.</p>
<p>If $f(\boldsymbol{x})=sign(\boldsymbol{w^T}\cdot \boldsymbol{x})$ fails to give any element $(\boldsymbol{x_i},y_i)\in D$ the right classification, i.e. $f(\boldsymbol{x_i})\neq y_i$, then we will replace $w$ with another random vector. We will do this repeatedly until all the samples $\in D$ are correctly classified.</p>
<p>As a former-JBer, Tom excels in programming and quickly wrote the pseudocode of <em>PLA</em>.</p>
<pre><code>  w := a random vector
  while true do
      flag:=true
      for i:=1 to N do
          if f(x[ i ]) != y[ i ] then
              flag:=false
              break
      if flag then
          break
      else
          w := a random vector
  return w
</code></pre><p>But Tom found that, in some occasions, <em>PLA</em> will end up into an infinite loop, which confuses him a lot. You are required to help Tom determine, when performed on a given sample set $D$, if <em>PLA</em> will end up into an infinite loop. Print Infinite loop! if so, or Successful! otherwise.</p>
<p>We only consider cases when $d=2$ for simplification.</p>
<p>Note: </p>
<script type="math/tex; mode=display">sign(x)= \begin{cases} -1& x < 0 \\ 0& x = 0 \\ 1&  x > 0 \end{cases}</script></blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains an integer $T(1\le T\le 1000)$, the number of test cases.</p>
<p>Each test case begins with a line containing a single integer $n(1\le n\le 100)$, size of the set of training samples $D$.</p>
<p>Then $n$ lines follow, the ith of which contains three integers $x_{i,1},x_{i,2},y_i (−10^5\le x_{i,1},x_{i,2}\le 10^5, y_i\in {−1,1})$, indicating the ith sample $(x_i,y_i)$ in $D$, where $x_i=(x_{i,1},x_{i,2})$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output a single line containing the answer: “Infinite loop!” or “Successful!”.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 1 1</span><br><span class="line">2 0 -1</span><br><span class="line">4</span><br><span class="line">0 0 1</span><br><span class="line">2 0 -1</span><br><span class="line">1 1 1</span><br><span class="line">1 -1 -1</span><br><span class="line">6</span><br><span class="line">0 0 1</span><br><span class="line">2 0 -1</span><br><span class="line">1 1 1</span><br><span class="line">1 -1 -1</span><br><span class="line">1 0 1</span><br><span class="line">0 1 -1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Successful!</span><br><span class="line">Successful!</span><br><span class="line">Infinite loop!</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出两类点的坐标，问能否用一条直线将两类点分开。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目看懂了就很好做了。</p>
<p>就是分别对两类点求凸包，然后判断两个凸包是否相交。若不相交，则能够用一条直线分开两类点，否则不能。</p>
<p>其实就是判断凸包是否相交的模板题。</p>
<p>类似的题目有：</p>
<ul>
<li><a href="https://wutao18.github.io/2019/08/21/UVA-10256-The-Great-Divide-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/">UVA 10256 The Great Divide</a></li>
<li><a href="https://wutao18.github.io/2019/08/21/POJ-3805-Separate-Points-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/#more">POJ 3805 Separate Points</a></li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (cross(a, b) &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span> </span>&#123;</span><br><span class="line">    Polygon u, l;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; s.size() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = u.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(u[n - <span class="number">2</span>], u[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.size() ; n &gt;=<span class="number">2</span> &amp;&amp; !isclock(l[n<span class="number">-2</span>],l[n<span class="number">-1</span>],s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线段相交</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),</span><br><span class="line">            c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(cross(p2 - p1, p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Polygon s1, Polygon s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = s1.size(), c2 = s2.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s1[i], s2)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Infinite loop!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c2; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s2[i], s1)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Infinite loop!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Intersection(s1[i], s1[(i + <span class="number">1</span>) % c1], s2[j], s2[(j + <span class="number">1</span>) % c2])) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Infinite loop!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Successful!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        Polygon s1, s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;x1, &amp;x2, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">1</span>) &#123;</span><br><span class="line">                s1.push_back(Point(x1, x2));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s2.push_back(Point(x1, x2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Successful!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.size()) s1 = Andrew(s1);</span><br><span class="line">        <span class="keyword">if</span>(s2.size()) s2 = Andrew(s2);</span><br><span class="line">        solve(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6651 Final Exam (思维)</title>
    <url>/2019/08/12/HDU-6651-Final-Exam-%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>2019 杭电多校 7 1006</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6651" target="_blank" rel="noopener">HDU 6651</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+7&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 7</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Final Exam is coming! Cuber QQ has now one night to prepare for tomorrow’s exam.</p>
<p>The exam will be a exam of problems sharing altogether $m$ points. Cuber QQ doesn’t know about the exact distribution. Of course, different problems might have different points; in some extreme cases, some problems might worth $0$ points, or all $m$ points. Points must be integers; a problem cannot have $0.5$ point.</p>
<p>What he knows, is that, these $n$ problems will be about $n$ totally different topics. For example, one could be testing your understanding of Dynamic Programming, another might be about history of China in 19th century. So he has to divide your night to prepare each of these topics separately. Also, if one problem is worth $x$ points in tomorrow’s exam, it takes at least $x+1$ hours to prepare everything you need for examination. If he spends less than $x+1$ hours preparing, he shall fail at this problem.</p>
<p>Cuber QQ’s goal, strangely, is not to take as much points as possible, but to solve at least $k$ problems no matter how the examination paper looks like, to get away from his parents’ scoldings. So he wonders how many hours at least he needs to achieve this goal.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input is an integer $t (1\le t\le 20 000)$, denoting the number of test cases.</p>
<p>Each test case are three space-separated integers $n,m,k (0\le m\le 10^9, 1\le k\le n\le 10^9)$. </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output the number of hours Cuber QQ needs.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 10 1</span><br><span class="line">10 109 10</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">1100</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>Cuber QQ should solve one problem in sample 1, so he at least prepares 11 hours when the problem one is 10 point. </p>
<p>Cuber QQ should solve all the ten problems in sample 2, so he at least prepares 110 hours for each problem because there may be one problem is 109 point.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一次考试共有 $n$ 道题，总分为 $m$ 分。每道题的分数不一定，可能是 $0$ 分，也可能是 $m$ 分，分数一定是整数。如果一道题分数为 $x$，那么复习这道题的时间为 $x + 1$，现在要保证在考试中做出 $k$ 题，求准备考试的时间最少为多少。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><strong>思维</strong></p>
<p>如果做不出 $k$ 题，那么也就是复习时间最少的 $n − k + 1$ 道题的难度都小于等于复习的时间。因此想要做出 $k$ 题，只要让复习时间最少的 $n − k + 1$ 道题的复习时间总和 $&gt; m$ 即可。</p>
<p>也就是 $n - k + 1$ 道题的复习时间总和为 $m + 1$，剩下 $k - 1$ 道题的复习时间不是最少的 $k - 1$ 道题即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n, m, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m + <span class="number">1</span> + (m / (n - k + <span class="number">1</span>) + <span class="number">1</span>) * (k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6627 equation (分类讨论)</title>
    <url>/2019/08/15/HDU-6627-equation-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<p>2019 杭电多校 5 1004</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6627" target="_blank" rel="noopener">HDU 6627</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+5&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 5</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>You are given two integers $N,C$ and two integer sequences $a$ and $b$ of length $N$. The sequences are indexed from $1$ to $N$. </p>
<p>Please solve the following equation for $x$: </p>
<p>$∑_{i=1}^N|a_i\cdot x + b_i| = C$, where $|v|$ means the absolute value of $v$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains an integer $T$ indicating there are $T$ tests. Each test consists of $N+1$ lines. The first line contains two integers $N,C$. The $i$-th line of following $N$ lines consists of two integers $a_i,b_i$. </p>
<p>$* 1\le T\le 50$ </p>
<p>$* 1\le N\le 10^5$ </p>
<p>$* 1\le a_i\le 1000$ </p>
<p>$* −1000\le b_i\le 1000$ </p>
<p>$* 1\le C\le 10^9$ </p>
<p>$*$ only $5$ tests with $N$ larger than $1000$</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test, output one line. </p>
<p>If there are an infinite number of solutions, this line consists only one integer $−1$. </p>
<p>Otherwise, this line first comes with an integer $m$ indicating the number of solutions, then you must print $m$ fractions from the smallest to the largest indicating all possible answers. (It can be proved that all solutions can be written as fractions). The fraction should be in the form of “a/b” where a must be an integer, b must be a positive integer, and $gcd(abs(a),b)=1$. If the answer is $0$, you should output “$0/1$”.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">1 -1</span><br><span class="line">3 3</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 1</span><br><span class="line">3 5</span><br><span class="line">4 -1</span><br><span class="line">3 2</span><br><span class="line">1 -1</span><br><span class="line">1 -2</span><br><span class="line">1 -3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">2 -3/2 -1/2</span><br><span class="line">0</span><br><span class="line">1 2/1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个整数 $C$ 和 $N$ 组 $a_i,b_i$，求 $∑_{i=1}^N|a_i\cdot x + b_i| = C$ 的所有解，如果有无穷多个解就输出 -1.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>分类讨论</strong></p>
<p>分类讨论去绝对值。根据 $b_i / a_i$ 排序，可得各段区间：$[-b_0/a_0, ∞), [-b_1/a_1, -b_0/a_0), [-b_2/a_2, -b_1/a_1), … ,[-b_n/a_n, -b_{n-1}/a_{n-1}), [∞, -b_n/a_n)$ 设 $suma = \sum_{i=1}^Na_i, sumb = \sum_{i=1}^Nb_i$，依次让 $a_ix+b_i$ 变成 $-a_ix-b_i$，也就是 $suma - 2a_i, sumb-2b_i$，求出 $x_i = \frac{c - sumb}{suma}$ 并判断是否在区间内。无穷解的情况：$suma = 0, sumb = c$。 </p>
<p>感谢杭电没有卡 $double$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coefficient</span> &#123;</span></span><br><span class="line">    ll a, b;</span><br><span class="line">&#125; co[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Coefficient c1, Coefficient c2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.b * <span class="number">1.0</span> / c1.a &lt; c2.b * <span class="number">1.0</span> / c2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Coefficient&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        ll c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;c);</span><br><span class="line">        ll suma = <span class="number">0</span>, sumb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;co[i].a, &amp;co[i].b);</span><br><span class="line">            suma += co[i].a;</span><br><span class="line">            sumb += co[i].b;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(co + <span class="number">1</span>, co + n + <span class="number">1</span>, cmp);</span><br><span class="line">        Coefficient t;</span><br><span class="line">        t.a = suma, t.b = sumb;</span><br><span class="line">        <span class="keyword">if</span>((c - sumb) * <span class="number">1.0</span> / suma &gt;= -co[<span class="number">1</span>].b * <span class="number">1.0</span> / co[<span class="number">1</span>].a) &#123;</span><br><span class="line">            t.b = c - t.b;</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            suma -= co[i].a * <span class="number">2</span>;</span><br><span class="line">            sumb -= co[i].b * <span class="number">2</span>;</span><br><span class="line">            t.a = suma;</span><br><span class="line">            t.b = sumb;</span><br><span class="line">            <span class="keyword">if</span>(!suma) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sumb == c) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>((c - sumb) * <span class="number">1.0</span> / suma &gt;= -co[i + <span class="number">1</span>].b * <span class="number">1.0</span> / co[i + <span class="number">1</span>].a &amp;&amp; (c - sumb) * <span class="number">1.0</span> / suma &lt; -co[i].b * <span class="number">1.0</span> / co[i].a) &#123;</span><br><span class="line">                    t.b = c - t.b;</span><br><span class="line">                    ans.push_back(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>((c - sumb) * <span class="number">1.0</span> / suma &lt; -co[i].b * <span class="number">1.0</span> / co[i].a) &#123;</span><br><span class="line">                    t.b = c - t.b;</span><br><span class="line">                    ans.push_back(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(ans.begin(), ans.end(), cmp);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans.size());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i].b * <span class="number">1.0</span> / ans[i].a &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" -"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                ll g = gcd(<span class="built_in">abs</span>(ans[i].b), <span class="built_in">abs</span>(ans[i].a));</span><br><span class="line">                <span class="keyword">if</span>(ans[i].b == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0/1"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, <span class="built_in">abs</span>(ans[i].b) / g, <span class="built_in">abs</span>(ans[i].a) / g);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6656 Kejin Player (期望DP 逆元)</title>
    <url>/2019/08/13/HDU-6656-Kejin-Player-%E6%9C%9F%E6%9C%9BDP-%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>2019 杭电多校 7 1011</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6656" target="_blank" rel="noopener">HDU 6656</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+7&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 7</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Cuber QQ always envies those Kejin players, who pay a lot of RMB to get a higher level in the game. So he worked so hard that you are now the game designer of this game. He decided to annoy these Kejin players a little bit, and give them the lesson that RMB does not always work.</p>
<p>This game follows a traditional Kejin rule of “when you are level i, you have to pay $a_i$ RMB to get to level $i+1$”. Cuber QQ now changed it a little bit: “when you are level $i$, you pay $a_i$ RMB, are you get to level $i+1$ with probability $p_i$; otherwise you will turn into level $x_i (x_i\le i)$”.</p>
<p>Cuber QQ still needs to know how much money expected the Kejin players needs to ``ke’’ so that they can upgrade from level $l$ to level $r$, because you worry if this is too high, these players might just quit and never return again.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input is an integer t, denoting the number of test cases.</p>
<p>For each test case, there is two space-separated integers $n (1\le n\le 500 000)$ and $q (1\le q\le 500 000)$ in the first line, meaning the total number of levels and the number of queries.</p>
<p>Then follows $n$ lines, each containing integers $r_i, s_i, x_i, a_i$$(1\le r_i\le s_i\le 10^9, 1\le x_i\le i, 0\le a_i\le 10^9)$ , space separated. Note that $p_i$ is given in the form of a fraction $\frac{r_i}{s_i}$.</p>
<p>The next $q$ lines are $q$ queries. Each of these queries are two space-separated integers $l$ and $r$ $(1\le l &lt; r\le n+1)$.</p>
<p>The sum of $n$ and sum of $q$ from all $t$ test cases both does not exceed $10^6$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each query, output answer in the fraction form modulo $10^9+7$, that is, if the answer is $\frac{P}{Q}$, you should output $P\cdot Q^{−1}$ modulo $10^9+7$, where $Q^{−1}$ denotes the multiplicative inverse of $Q$ modulo $10^9+7$.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 2</span><br><span class="line">1 1 1 2</span><br><span class="line">1 2 1 3</span><br><span class="line">1 3 3 4</span><br><span class="line">1 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">22</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>从 $i$ 级升级到 $i + 1$ 级需要花费 $a_i$ RMB，成功的概率为 $p_i = \frac{r_i}{s_i}$，若失败则降到 $x_i$ 级，然后给出 $q$ 个询问求 $l$ 级升级到 $r$ 级花费的期望。 </p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><strong>期望DP 逆元</strong></p>
<p>设 $g(l, r)$ 为 $l$ 升到 $r$ 的期望，这种期望满足减法 $g(l, r) = g(1, r) − g(1, l)$。因为升级只能一级一级升, 所以要从 $1$ 升级到 $r$, 必然要经过 $l$。可以降维，用 $dp[i]$ 表示从 $1$ 升到 $i$ 的期望，则 $g(l, r) = dp[r] − dp[l]$。</p>
<p>从 $dp[i]$ 转移至 $dp[i + 1]$，假设尝试了 $t$ 次才成功，那么也就是前面 $t - 1$ 次都是失败的，所以下一状态的花费为当前状态的花费 + 成功的花费 + 失败的花费 + 失败后再次回到当前状态的花费。于是：</p>
<script type="math/tex; mode=display">dp[i + 1] = dp[i] + 1 \times a[i] + (t - 1) \times a[i] + (t- 1) \times (dp[i] - dp[x_i])</script><p>又 $\frac{t - 1}{t} = 1 - \frac{r_i}{s_i}$，即 $t = \frac{s_i}{r_i}$</p>
<p>于是状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i + 1] = dp[i] + \frac{s_i}{r_i} \times a[i] + (\frac{s_i}{r_i} - 1) \times (dp[i] - dp[x_i])</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll r[maxn], s[maxn], x[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;r[i], &amp;s[i], &amp;x[i], &amp;a[i]);</span><br><span class="line">            ll t = (s[i] * qmod(r[i], mod - <span class="number">2</span>, mod)) % mod;</span><br><span class="line">            dp[i + <span class="number">1</span>] = (dp[i] + (t * a[i]) % mod + ((t - <span class="number">1</span>) * (dp[i] - dp[x[i]])) % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (dp[r] - dp[l] + mod) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>动态规划</tag>
        <tag>期望DP</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6628 permutation 1 (暴力)</title>
    <url>/2019/08/14/HDU-6628-permutation-1-%E6%9A%B4%E5%8A%9B/</url>
    <content><![CDATA[<p>2019 杭电多校 5 1005</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6628" target="_blank" rel="noopener">HDU 6628</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+5&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 5</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>A sequence of length $n$ is called a permutation if and only if it’s composed of the first $n$ positive integers and each number appears exactly once.</p>
<p>Here we define the “difference sequence” of a permutation $p_1, p_2,…,p_n$ as $p_2−p_1,p_3−p_2,…,p_n−p_{n−1}$. In other words, the length of the difference sequence is $n−1$ and the $i$-th term is $p_{i+1}−p_i$</p>
<p>Now, you are given two integers $N,K$. Please find the permutation with length $N$ such that the difference sequence of which is the $K$-th lexicographically smallest among all difference sequences of all permutations of length $N$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains one integer $T$ indicating that there are $T$ tests.</p>
<p>Each test consists of two integers $N,K$ in a single line.</p>
<p>$* 1≤T≤40$ </p>
<p>$* 2≤N≤20$ </p>
<p>$* 1\le K\le min(10^4, N!)$</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test, please output $N$ integers in a single line. Those $N$ integers represent a permutation of $1$ to $N$, and its difference sequence is the $K$-th lexicographically smallest.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">20 10000</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">20 1 2 3 4 5 6 7 8 9 10 11 13 19 18 14 16 15 17 12</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>定义排列 $p_1, p_2, … , p_n$ 的 “difference sequence” 为 $p_2-p_1, p_3-p_2,…,p_n-p_{n-1}$。现在给定 $N$ 和 $K$，求长度为 $N$ 的所有排列中 “difference sequence” 的字典序第 $K$ 小的排列。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><strong>暴力 STL 全排列</strong></p>
<p>题目给定 $K$ 的范围不超过 $10^4$，而 $8! = 40320 &gt; K$，因此可以预处理 $N &lt;= 8$ 的情况，当 $N &gt; 8$ 时暴力求 $a[1] = n$ 的全排列。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125; ans[<span class="number">10</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(P p1, P p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.str &lt; p2.str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// for(int j = 0; j &lt; i; ++j) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; a[j] &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                ans[i][cnt].num[j] = a[j];</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i) ans[i][cnt].str += a[j + <span class="number">1</span>] - a[j] + <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span>(next_permutation(a + <span class="number">1</span>, a + <span class="number">1</span> + i));</span><br><span class="line">        sort(ans[i] + <span class="number">1</span>, ans[i] + cnt, cmp);</span><br><span class="line">        <span class="comment">// for(int j = 1; j &lt; cnt; ++j) &#123; for(int k = 1; k &lt;= i; ++k) cout &lt;&lt; ans[i][j].num[k] &lt;&lt; ""; cout &lt;&lt; endl;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[n][k].num[j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, j == n? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a[<span class="number">30</span>];</span><br><span class="line">            a[<span class="number">1</span>] = n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                a[i] = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                next_permutation(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, i == n? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6659 Acesrc and Good Numbers (数学 思维)</title>
    <url>/2019/08/19/HDU-6659-Acesrc-and-Good-Numbers-%E6%95%B0%E5%AD%A6-%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>2019 杭电多校 8 1003</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6659" target="_blank" rel="noopener">HDU 6659</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+8&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 8</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Acesrc is a famous mathematician at Nanjing University second to none. Playing with interesting numbers is his favorite. Today, he finds a manuscript when cleaning his room, which reads</p>
<p>… Let $f(d,n)$ denote the number of occurrences of digit $d$ in decimal representations of integers $1,2,3,⋯,n$. The function has some fantastic properties …</p>
<p>… Obviously, there exist some nonnegative integers $k$, such that $f(d,k)=k$, and I decide to call them $d$-good numbers …</p>
<p>… I have found all d-good numbers not exceeding $10^{1000}$, but the paper is too small to write all these numbers …</p>
<p>Acesrc quickly recollects all $d$-good numbers he found, and he tells Redsun a question about $d$-good numbers: what is the maximum $d$-good number no greater than $x$? However, Redsun is not good at mathematics, so he wants you to help him solve this problem.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input consists of a single integer $q (1\le q\le 1500)$, denoting the number of test cases. Each test case is a single line of two integers $d (1\le d\le 9)$ and $x (0\le x\le 10^{18})$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, print the answer as a single integer in one line. Note that $0$ is trivially a $d$-good number for arbitrary $d$.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">1 199999</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">199990</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义 $f(d, n)$ 为十进制下 $1$ 到 $n$ 所有数的数位中数字 $d$ 出现的次数。给定 $x$，找出最大的 $n(n \le x)$ 满足 $f(d, n) = n$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看到了一个神仙做法。</p>
<p>显然如果 $f(d, x) = x$ 时就直接输出。</p>
<p>否则，需要缩小 $x$。令 $f(d, x) = y$，则需要将 $x$ 缩小 $\lceil \frac{|x - y|}{18} \rceil$。即 $x = x - abs(f(d, x) - x) / 18$。原因是 $f(d, x)$ 与 $f(d, x - 1)$ 最多相差 $18$ 个 $d$ $ (e.g.  f(9, 10^{18}-1) to f(9, 10^{18}-2))$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 1 到 n 中数字 x 出现的次数</span></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll d, ll n)</span> </span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>, k;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; k = n / i; i *= <span class="number">10</span>) &#123;</span><br><span class="line">        cnt += (k / <span class="number">10</span>) * i;</span><br><span class="line">        <span class="keyword">int</span> cur = k % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; d) &#123;</span><br><span class="line">            cnt += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur == d) &#123;</span><br><span class="line">            cnt += n - k * i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll d, x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ll num = f(d, x);</span><br><span class="line">            <span class="keyword">if</span> (num == x) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x -= max(<span class="number">1L</span>L, <span class="built_in">abs</span>(num - x) / <span class="number">18</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/jk_chen_acmer/article/details/99595262" target="_blank" rel="noopener">2019 Multi-University Training Contest 8——Acesrc and Good Numbers（数学 想法）</a></p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6685 Rikka with Coin (枚举 思维)</title>
    <url>/2019/08/20/HDU-6685-Rikka-with-Coin-%E6%9E%9A%E4%B8%BE-%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>2019 杭电多校 9 1006</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685" target="_blank" rel="noopener">HDU 6685</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 9</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Rikka hates coins, and she used to never carry any coins with her. These days, Rikka is doing her summer internship abroad. Without mobile payment, Rikka has to face strange prices of commodities, and as a result of always using paper currency, she has to face mountainous coins on here table. </p>
<p>In the local currency system, there are $4$ kinds of coins: $10$ cents, $20$ cents, $50$ cents and $1$ dollar. Up to now, Rikka has gained at least $10^{100}$ coins for each kind. </p>
<p>Now, Rikka is going to have dinner in the canteen, and she decides to pay the bill only with coins. There are $n$ different combos in the canteen and the price of the $i$th is $w_i$ cents. Rikka would like to choose one combo as dinner but she has not decided to choose which one yet. Therefore, she wants to take some coins so that whichever she chooses, she can always pay the bill without receiving any change. </p>
<p>Since Rikka hates coins, she wants to carry as few coins as possible with her. As it is generally known that Rikka is not good at math, she wants you to help her make the decision.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input contains a single integer $T(1\le T\le 500)$, the number of test cases. </p>
<p>For each test case, the first line contains a single integer $n(1\le n\le 100)$, the number of combos sold in the canteen. </p>
<p>The second line contains $n$ positive integers $w_1,…,w_n(1\le w_i\le 10^9)$, which represents the prices.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output a single line with a single integer which represents the minimum number of coins. If there is no valid solution, output $−1$. </p>
<blockquote>
<p><strong>Hint</strong></p>
<p>In the first test case, one optimal solution is to bring one coin of $10$ cents and two coins of $20$ cents.</p>
<p>In the second test case, one optimal solution is to bring $5$ coins of one dollar.</p>
</blockquote>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">10 20 30 40 50</span><br><span class="line">5</span><br><span class="line">100 200 300 400 500</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出 $n$ 种物品的价格，现在要从无限枚 $10$元，$20$元，$50$元，$100$元的硬币中选出最少的硬币，满足能购买任何一种物品都不用找零。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然如果个位不为零时没有可行方案。</p>
<p>接下来考虑可行方案的求解。</p>
<p>$10$ 分的硬币多只会用一个，如果用了两个，直接替换成一个 $10$ 分一个 $20$ 分一定不亏。</p>
<p>$20$ 分的硬币多只会用三个，如果用了四个，直接替换成一个 $10$ 分两个 $20$ 分一个 $50$ 分一定不亏。</p>
<p>$50$ 分的硬币多只会用一个，如果用了两个，直接替换成一个 $50$ 分和一个一元一定不亏。 </p>
<p>因此，直接暴力枚举 $10$, $20$, $50$ 的硬币的数量即可，整百的部分用一元硬币填充。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= c; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i * <span class="number">50</span> + j * <span class="number">20</span> + k * <span class="number">10</span> == n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">            <span class="keyword">if</span>(w[i] % <span class="number">10</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">1</span>; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(w[i] &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(judge(w[i], j, k, l)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                flag = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(judge(w[i] % <span class="number">100</span> + <span class="number">100</span>, j, k, l)) &#123;</span><br><span class="line">                                cnt = max(cnt, (w[i] - <span class="number">100</span>) / <span class="number">100</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(judge(w[i] % <span class="number">100</span>, j, k, l)) &#123;</span><br><span class="line">                                cnt = max(cnt, w[i] / <span class="number">100</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                flag = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                        ans = min(ans, cnt + j + k + l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>枚举</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6665 Calabash and Landlord (分类讨论)</title>
    <url>/2019/08/14/HDU-6665-Calabash-and-Landlord-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<p>2019 杭电多校 8 1009</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6665" target="_blank" rel="noopener">HDU 6665</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+8&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 8</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Calabash is the servant of a landlord. The landlord owns a piece of land, which can be regarded as an infinite 2D plane. </p>
<p>One day the landlord set up two orthogonal rectangular-shaped fences on his land. He asked Calabash a simple problem: how many nonempty connected components is my land divided into by these two fences, both finite and infinite? Calabash couldn’t answer this simple question. Please help him! </p>
<p>Recall that a connected component is a maximal set of points not occupied by the fences, and every two points in the set are reachable without crossing the fence.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input consists of a single integer $T (1\le T\le 10000)$, the number of test cases. </p>
<p>Each test case contains two lines, specifying the two rectangles. Each line contains four integers $x_1,y_1,x_2,y_2 (0\le x_1,y_1,x_2,y_2\le 10^9,x_1&lt;x_2,y_1&lt;y_2)$, where $(x_1,y_1),(x_2,y_2)$ are the Cartesian coordinates of two opposite vertices of the rectangular fence. The edges of the rectangles are parallel to the coordinate axes. The edges of the two rectangles may intersect, overlap, or even coincide.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, print the answer as an integer in one line.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0 1 1</span><br><span class="line">2 2 3 4</span><br><span class="line">1 0 3 2</span><br><span class="line">0 1 2 3</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给出两个矩形，求矩形把平面分割成几块。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>分类讨论</strong></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/14/1565792338325-1565792338743.png" alt=""></p>
<p>听说只要离散化到 $5*5$ 的格子里然后 $DFS$ 就可以了，有空再补。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125;p[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll maxx = <span class="number">0</span>, maxy = <span class="number">0</span>, minx = inf, miny = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        p[<span class="number">3</span>].x = p[<span class="number">1</span>].x;</span><br><span class="line">        p[<span class="number">3</span>].y = p[<span class="number">2</span>].y;</span><br><span class="line">        p[<span class="number">4</span>].x = p[<span class="number">2</span>].x;</span><br><span class="line">        p[<span class="number">4</span>].y = p[<span class="number">1</span>].y;</span><br><span class="line">        ll s1 = (p[<span class="number">2</span>].x - p[<span class="number">1</span>].x) * (p[<span class="number">2</span>].y - p[<span class="number">1</span>].y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        p[<span class="number">7</span>].x = p[<span class="number">5</span>].x;</span><br><span class="line">        p[<span class="number">7</span>].y = p[<span class="number">6</span>].y;</span><br><span class="line">        p[<span class="number">8</span>].x = p[<span class="number">6</span>].x;</span><br><span class="line">        p[<span class="number">8</span>].y = p[<span class="number">5</span>].y;</span><br><span class="line">        ll s2 = (p[<span class="number">6</span>].x - p[<span class="number">5</span>].x) * (p[<span class="number">6</span>].y - p[<span class="number">5</span>].y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            maxx = max(maxx, p[i].x);</span><br><span class="line">            maxy = max(maxy, p[i].y);</span><br><span class="line">            minx = min(minx, p[i].x);</span><br><span class="line">            miny = min(miny, p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= 8; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; p[i].x &lt;&lt; " " &lt;&lt; p[i].y &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">1</span>].y == p[<span class="number">5</span>].y &amp;&amp; p[<span class="number">3</span>].x == p[<span class="number">7</span>].x &amp;&amp; p[<span class="number">3</span>].y == p[<span class="number">7</span>].y &amp;&amp; p[<span class="number">6</span>].x == p[<span class="number">2</span>].x &amp;&amp; p[<span class="number">6</span>].y == p[<span class="number">2</span>].y &amp;&amp; p[<span class="number">4</span>].x == p[<span class="number">8</span>].x &amp;&amp; p[<span class="number">4</span>].y == p[<span class="number">8</span>].y) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll s = (maxx - minx) * (maxy - miny); <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == s || s2 == s) &#123;</span><br><span class="line">            <span class="keyword">if</span>((p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">2</span>].x == p[<span class="number">6</span>].x)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">5</span>].y == p[<span class="number">1</span>].y || p[<span class="number">6</span>].y == p[<span class="number">2</span>].y) <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>((p[<span class="number">1</span>].y == p[<span class="number">5</span>].y &amp;&amp; p[<span class="number">2</span>].y == p[<span class="number">6</span>].y)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">5</span>].x == p[<span class="number">1</span>].x || p[<span class="number">6</span>].x == p[<span class="number">2</span>].x) <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">4</span>].y &gt;= p[<span class="number">7</span>].y || p[<span class="number">8</span>].y &gt;= p[<span class="number">3</span>].y || p[<span class="number">5</span>].x &gt;= p[<span class="number">2</span>].x || p[<span class="number">1</span>].x &gt;= p[<span class="number">6</span>].x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((p[<span class="number">2</span>].x - p[<span class="number">1</span>].x) * (p[<span class="number">6</span>].y - p[<span class="number">5</span>].y) == s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">6</span>].y &gt; p[<span class="number">2</span>].y &amp;&amp; p[<span class="number">5</span>].y &lt; p[<span class="number">1</span>].y &amp;&amp; p[<span class="number">1</span>].x &lt; p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">2</span>].x &gt; p[<span class="number">6</span>].x) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"6\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">1</span>].y == p[<span class="number">5</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">3</span>].x == p[<span class="number">7</span>].x &amp;&amp; p[<span class="number">3</span>].y == p[<span class="number">7</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">2</span>].x == p[<span class="number">6</span>].x &amp;&amp; p[<span class="number">2</span>].y == p[<span class="number">6</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">4</span>].x == p[<span class="number">8</span>].x &amp;&amp; p[<span class="number">4</span>].y == p[<span class="number">8</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"5\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((p[<span class="number">6</span>].x - p[<span class="number">5</span>].x) * (p[<span class="number">2</span>].y - p[<span class="number">1</span>].y) == s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">2</span>].y &gt; p[<span class="number">6</span>].y &amp;&amp; p[<span class="number">1</span>].y &lt; p[<span class="number">5</span>].y &amp;&amp; p[<span class="number">5</span>].x &lt; p[<span class="number">1</span>].x &amp;&amp; p[<span class="number">6</span>].x &gt; p[<span class="number">2</span>].x) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"6\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">1</span>].x == p[<span class="number">5</span>].x &amp;&amp; p[<span class="number">1</span>].y == p[<span class="number">5</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">3</span>].x == p[<span class="number">7</span>].x &amp;&amp; p[<span class="number">3</span>].y == p[<span class="number">7</span>].y) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">2</span>].x == p[<span class="number">6</span>].x &amp;&amp; p[<span class="number">2</span>].y == p[<span class="number">6</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">4</span>].x == p[<span class="number">8</span>].x &amp;&amp; p[<span class="number">4</span>].y == p[<span class="number">8</span>].y) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"5\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6693 Valentine&#39;s Day (概率)</title>
    <url>/2019/08/22/HDU-6693-Valentine-s-Day-%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<p>2019 杭电多校 10 1003</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6693" target="_blank" rel="noopener">HDU 6693</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+10&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 10</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Oipotato loves his girlfriend very much. Since Valentine’s Day is coming, he decides to buy some presents for her. </p>
<p>There are $n$ presents in the shop, and Oipotato can choose to buy some of them. We know that his girlfriend will possibly feel extremely happy if she receives a present. Therefore, if Oipotato gives $k$ presents to his girlfriend, she has $k$ chances to feel extremely happy. However, Oipotato doesn’t want his girlfriend to feel extremely happy too many times for the gifts. </p>
<p>Formally, for each present $i$, it has a possibility of $P_i$ to make Oipotato’s girlfriend feel extremely happy. Please help Oipotato decide what to buy and maximize the possibility that his girlfriend feels extremely happy for <strong>exactly</strong> one time. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>There are multiple test cases. The first line of the input contains an integer $T (1\le T\le 100)$, indicating the number of test cases. For each test case: </p>
<p>The first line contains an integer $n (1\le n\le 10 000)$, indicating the number of possible presents. </p>
<p>The second line contains $n$ decimals $P_i (0\le Pi\le 1)$ with exactly six digits after the decimal point, indicating the possibility that Oipotato’s girlfriend feels extremely happy when receiving present $i$. </p>
<p>It is guaranteed that the sum of $n$ in all test cases does not exceed $450000$. </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case output one line, indicating the answer. Your answer will be considered correct if and only if the absolute error of your answer is less than $10^{−6}$. </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">0.100000 0.200000 0.900000</span><br><span class="line">3</span><br><span class="line">0.100000 0.300000 0.800000</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0.900000000000</span><br><span class="line">0.800000000000</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 种礼物，第 $i$ 种礼物能让女朋友开心的概率为 $P_i$，挑一些礼物，问让女朋友开心一次的概率最大为多少。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>概率 贪心</strong></p>
<p>如果有概率大于等于 $0.5$ 的礼物，输出其中最大的。</p>
<p>否则，对概率从大到小。暴力枚举选择前 $k$ 大的礼物的的概率，求最大值即可。</p>
<p>此题有原题。见 <a href="https://codeforces.com/problemset/problem/442/B" target="_blank" rel="noopener">CodeForces 442B</a></p>
<p>相关证明见官方题解：<a href="https://codeforces.com/blog/entry/12739" target="_blank" rel="noopener">Codeforces #253 editorial</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>, maxa = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[i]);</span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(maxa = <span class="number">-1</span>) maxa = p[i];</span><br><span class="line">                <span class="keyword">else</span> maxa = max(maxa, p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, maxa);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(p, p + n);</span><br><span class="line">            <span class="keyword">double</span> tmp1 = p[n - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> tmp2 = p[n - <span class="number">1</span>] * (<span class="number">1</span> - p[n - <span class="number">2</span>]) + p[n - <span class="number">2</span>] * (<span class="number">1</span> - p[n - <span class="number">1</span>]);</span><br><span class="line">            ans = tmp2;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp1 &lt; tmp2 &amp;&amp; k &lt;= n) &#123;</span><br><span class="line">                ans = tmp2;</span><br><span class="line">                tmp1 = tmp2;</span><br><span class="line">                tmp2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= n - k; --i) &#123;</span><br><span class="line">                    <span class="keyword">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= n - k; --j) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j == i) &#123;</span><br><span class="line">                            tmp *= p[j];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            tmp *= <span class="number">1</span> - p[j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp2 += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, max(ans, tmp2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6667 Roundgod and Milk Tea (思维)</title>
    <url>/2019/08/14/HDU-6667-Roundgod-and-Milk-Tea-%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>2019 杭电多校 8 1011</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6667" target="_blank" rel="noopener">HDU 6667</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+8&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 8</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Roundgod is a famous milk tea lover at Nanjing University second to none. This year, he plans to conduct a milk tea festival. There will be $n$ classes participating in this festival, where the ith class has $a_i$ students and will make $b_i$ cups of milk tea.</p>
<p>Roundgod wants more students to savor milk tea, so he stipulates that every student can taste at most one cup of milk tea. Moreover, a student can’t drink a cup of milk tea made by his class. The problem is, what is the maximum number of students who can drink milk tea?</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input consists of a single integer $T (1\le T\le 25)$, denoting the number of test cases. </p>
<p>Each test case starts with a line of a single integer $n (1\le n\le 10^6)$, the number of classes. For the next $n$ lines, each containing two integers $a,b (0\le a,b\le 10^9)$, denoting the number of students of the class and the number of cups of milk tea made by this class, respectively. </p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $6\times 10^6$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, print the answer as a single integer in one line.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3 4</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>有 $n$ 个班级，每个班有 $a_i$ 个人，做了 $b_i$ 杯奶茶，每个班的每个人最多喝一杯奶茶且不能和自己班做的奶茶，问最多共有多少人喝到奶茶。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最初的想法是用一个 $sum$ 记录所有剩余的奶茶数，然后每个组能喝的奶茶数为 $sum -$ 该组的奶茶(自己不能喝自己的) $+$ 上一组做的奶茶 (上一组减掉的加回来)。后来发现有点问题，就是中间一步减掉自己的奶茶可能是减多的，也就是上一组喝掉的可能就是当前组的奶茶，那么当前组剩余的奶茶是比原来少的，于是就用 $tmp2$ 保存上一组喝掉的奶茶数，每次让上一组喝掉当前组的奶茶，如果不够喝再用 $tmp$ 保存还要喝掉的奶茶数，往下迭代。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Team</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll m, n;  <span class="comment">// 人数 奶茶数</span></span><br><span class="line">&#125; t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Team t1, Team t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.m &gt; t2.m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;t[i].m, &amp;t[i].n);</span><br><span class="line">            sum += t[i].n;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(t, t + n, cmp);</span><br><span class="line">        ll ans = <span class="number">0</span>; </span><br><span class="line">        ll tmp = t[<span class="number">0</span>].n; <span class="comment">// tmp 保存喝掉的奶茶数 第一组一定要被喝</span></span><br><span class="line">        ll tmp2 = <span class="number">0</span>; <span class="comment">// tmp2 保存的是上一组喝掉的奶茶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i) &#123;</span><br><span class="line">                <span class="comment">// 上一组喝掉的奶茶数+之前喝掉的奶茶数</span></span><br><span class="line">                <span class="keyword">if</span>(t[i].n &lt; tmp2 + tmp) &#123;</span><br><span class="line">                    t[i].n = <span class="number">0</span>;</span><br><span class="line">                    tmp = tmp2 + tmp - t[i].n;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t[i].n = t[i].n - (tmp2 + tmp);</span><br><span class="line">                    tmp = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= t[i].n; <span class="comment">// 自己不能喝自己的奶茶</span></span><br><span class="line">            <span class="keyword">if</span>(i) sum += t[i - <span class="number">1</span>].n; <span class="comment">// 可以喝上一组的奶茶</span></span><br><span class="line">            <span class="comment">// 剩余的奶茶数与第 i 组人数比较</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= t[i].m) &#123;</span><br><span class="line">                ans += t[i].m;</span><br><span class="line">                sum -= t[i].m;</span><br><span class="line">                tmp2 = t[i].m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += sum;</span><br><span class="line">                sum -= sum;</span><br><span class="line">                tmp2 = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比赛中完全想复杂了，其实完全可以很快处理。把每个人能喝的奶茶加起来和所有的奶茶比较即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">            sum += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += min(a[i], sum - b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(ans, sum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6695 Welcome Party (贪心)</title>
    <url>/2019/08/23/HDU-6695-Welcome-Party-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>2019 杭电多校 10 1005</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6695" target="_blank" rel="noopener">HDU 6695</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+10&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 10</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>The annual welcome party of the Department of Computer Science and Technology is coming soon! Many students have been applying to show up at the welcome party, and every one of them can choose to sing a song or play crosstalk. This troubles the chief director a lot: how to arrange the program list, such that every student can have a chance to show up on the stage, and the satisfactory value of audiences is maximized?</p>
<p>To cope with this problem, the director proposes a model. In this model, every student has two attributes: the singing ability and crosstalking ability. The satisfactory value of audiences to singings is the maximum singing ability among all students that choose to sing a song; similarly, the satisfactory value to crosstalks is the maximum crosstalking ability among all students that choose play crosstalk. The strange thing is, the overall satisfactory value to the whole party is negatively related to the absolute difference between the satisfactory values to singings and crosstalks. The problem is, what is the minimum possible absolute difference between the satisfactory values of the two types of programs?</p>
<p>Note that:</p>
<ul>
<li>every student should choose exactly one type of programs to play;</li>
<li>at least one student should sing a song, and at least one student should play crosstalk.</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input consists of a single integer $T (1\le T\le 70)$, the number of test cases.</p>
<p>Each test case starts with a line of a single integer $n (2\le n\le 100000)$, denoting the number of students applying to show up on the stage. Then follow $n$ lines, each containing two integers $x$ and $y (0\le x,y\le 10^{18})$, denoting the singing ability and crosstalking ability of a student.</p>
<p>It is guaranteed that the sum of $n$ over all test cases never exceeds $1000000$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output a single integer, denoting the minimum possible absolute difference between the satisfactory values of the two types of programs.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">27 46</span><br><span class="line">89 13</span><br><span class="line">55 8</span><br><span class="line">71 86</span><br><span class="line">22 35</span><br><span class="line">3</span><br><span class="line">3 5</span><br><span class="line">4 7</span><br><span class="line">6 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个人，$2$ 种节目，每个人要表演其中的一种节目，每种节目至少有一人表演。用 $x_i$ 和 $y_i$ 表示第 $i (1\le i\le n)$ 个人表演两种节目的能力值。现在要使表演第一种节目的人中的能力最大值与表演第二种节目的人中的能力最大值之差最小，求这个最小值。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>贪心</strong></p>
<p>如下图，维护两个集合 $s_1$ 和 $s_2$。 </p>
<p>按 $x$ 从大到小枚举。假设 $x_i$ 为 $x$ 中的最大值 (下图中的 $4$)，则比 $x_i$ 大的都选择 $y$，也就是取 $s_1$ 中的最大值 (下图中的 $8$)。比 $x_i$ 小的取与 $x_i$ 最接近的 $y$ (下图中的 $3$)，因为更大的 $y$ 可以选择 $x$ (下图中的 $7$ 可以用 $2$ 替换)。然后取两个的较大值更新到 $ans$ (下图中 $|3 - 4| &lt; |8 - 4|$ 取 $8 - 4$)，维护最小值 $ans$ 即可。</p>
<p>比赛中队友 (线段树大佬) 用线段树过的。赛后我用 $multiset$ 写了一下。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/23/1566573834928-1566573834928.png" alt=""></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">2e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span> &#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">&#125; s[maxn];</span><br><span class="line">ll maxy[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(STU s1, STU s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.x &gt; s2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;ll&gt; s1, s2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s[i].x &gt;&gt; s[i].y;</span><br><span class="line">            s2.insert(s[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(s, s + n, cmp);</span><br><span class="line">        ll ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s2.erase(s2.find(s[i].y));  <span class="comment">// 一个人只能选择一种表演</span></span><br><span class="line">            <span class="keyword">if</span>(!s1.empty()) &#123;</span><br><span class="line">                ans = min(ans, <span class="built_in">abs</span>(*s1.rbegin() - s[i].x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.empty()) &#123;</span><br><span class="line">                <span class="built_in">multiset</span>&lt;ll&gt;::iterator it = s2.lower_bound(s[i].x); <span class="comment">// 找到第一个大于等于 s[i].x 的 y</span></span><br><span class="line">                <span class="keyword">if</span>(it == s2.end()) &#123;</span><br><span class="line">                    --it;</span><br><span class="line">                &#125;</span><br><span class="line">                ll tmp = <span class="built_in">abs</span>(*it - s[i].x);</span><br><span class="line">                <span class="keyword">if</span>(tmp &lt; ans &amp;&amp; (s1.empty() || *it &gt; *s1.rbegin())) &#123;</span><br><span class="line">                    ans = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(it != s2.begin()) &#123;  <span class="comment">// 找到最后一个小于 s[i].x 的 y</span></span><br><span class="line">                    --it;</span><br><span class="line">                    tmp = <span class="built_in">abs</span>(*it - s[i].x);</span><br><span class="line">                    <span class="keyword">if</span>(tmp &lt; ans &amp;&amp; (s1.empty() || *it &gt; *s1.rbegin())) &#123;</span><br><span class="line">                        ans = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                s1.insert(s[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>STL</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 6697 Closest Pair of Segments (计算几何 暴力)</title>
    <url>/2019/08/24/HDU-6697-Closest-Pair-of-Segments-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E6%9A%B4%E5%8A%9B/</url>
    <content><![CDATA[<p>2019 杭电多校 10 1007</p>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6697" target="_blank" rel="noopener">HDU 6697</a></p>
<p>比赛链接：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019+Multi-University+Training+Contest+10&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">2019 Multi-University Training Contest 10</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>The closest pair of points problem is a well-known problem of computational geometry. In this problem, you are given $n$ points in the Euclidean plane and you need to find a pair of points with the smallest distance between them. </p>
<p>Now, Claris, the brilliant one who has participated in programming contests for several years, is trying to solve a harder problem named the closest pair of segments problem, which also has a quite simple description as above. </p>
<p>However, the problem seems even too hard for Claris and she is asking you for help. </p>
<p>Now $n$ segments are lying on the Euclidean plane, you are asked to pick two different segments and then pick a point on the two segments respectively to minimize the distance between these two points. </p>
<p>For simplicity, any two given segments share no common point, and you don’t need to show her the two chosen points, but the distance between them instead. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains several test cases, and the first line contains a single integer $T (1\le T\le 200)$, the number of test cases. </p>
<p>For each test case, the first line contains one integer $n (2\le n\le 10000)$, which is the number of segments on the Euclidean plane. </p>
<p>The following $n$ lines describe all the segments lying on the Euclidean plane, the $i$-th of which contains for integers $x_1,y_1,x_2$ and $y_2$ describing a segment that connects $(x_1,y_1)$ and $(x_2,y_2)$, where $−10^9\le x_1,y_1,x_2,y_2\le 10^9$. </p>
<p>It’s guaranteed that the two endpoints of each segment do not coincide, any two given segments do not intersect with each other in each test case, and no more than $20$ test cases satisfy $n&gt;1000$. </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output a line containing a single real number for the answer to the closest pair of segments problem with an absolute or relative error of at most $10^{−6}$. </p>
<p>Precisely speaking, assume that your answer is $a$ and and the jury’s answer is $b$, your answer will be considered correct if and only if $\frac{|a−b|}{max\{1,|b|\}}\le 10^{−6}$. </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">0 1 1 2</span><br><span class="line">1 1 2 0</span><br><span class="line">2</span><br><span class="line">0 1 1 2</span><br><span class="line">2 2 3 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0.707106781187</span><br><span class="line">1.000000000000</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>类似于计算几何中的最近点对问题，本题求的是最近线段对。</p>
<p>给定 $n$ 条线段，求出最近线段对之间的距离。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>暴力 剪枝</strong></p>
<p>比赛时我用了三角剖分，结果超时了。</p>
<p>赛后补题时看到了这篇博客：<a href="https://www.cnblogs.com/dd-bond/p/11391771.html" target="_blank" rel="noopener">HDU 6697 Closest Pair of Segments（线段距离）</a></p>
<p>原来暴力加上剪枝就能过。思路是这样的：</p>
<p>首先将线段的左侧端点按照横坐标为第一关键字，纵坐标为第二关键字排序。然后暴力找所有线段对，维护最小值 $ans$。如果当前查询的线段对中，右侧线段的左端点与左侧线段的右端点的横坐标差值大于 $ans$ 时，就不用再找更右侧的直线了。这样剪枝能大大减少时间复杂度。</p>
<p>时限给了 20s，大概 1.3s 就能跑完。</p>
<p><del>题解看不懂</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point s, e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();</span><br><span class="line">        e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.dis(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点到直线的距离</span></span><br><span class="line">    <span class="function">db <span class="title">point_to_line</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>((p - s).cross(e - s) / length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点到线段的距离</span></span><br><span class="line">    <span class="function">db <span class="title">point_to_seg</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dcmp((p - s).dot((e - s))) &lt; <span class="number">0</span> || dcmp((p - e).dot((s - e))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> min(p.dis(s), p.dis(e));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> point_to_line(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线段到线段的距离</span></span><br><span class="line">    <span class="function">db <span class="title">seg_to_seg</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> min(min(point_to_seg(l.s), point_to_seg(l.e)), min(l.point_to_seg(s), l.point_to_seg(e)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Line l1, Line l2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> l1.s &lt; l2.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            l[i].input();</span><br><span class="line">			<span class="keyword">if</span>(l[i].e &lt; l[i].s) swap(l[i].s, l[i].e);</span><br><span class="line">        &#125;</span><br><span class="line">		sort(l, l + n, cmp);</span><br><span class="line">		<span class="keyword">double</span> ans = <span class="number">1e10</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 剪枝部分</span></span><br><span class="line">				<span class="keyword">if</span>(dcmp((l[j].s.x - l[i].e.x) - ans) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ans = min(ans, l[i].seg_to_seg(l[j])); <span class="comment">// 更新最小值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>枚举</tag>
        <tag>暴力</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC Asia Nanning 2017 F. The Chosen One (高精度运算)</title>
    <url>/2019/08/15/ICPC-Asia-Nanning-2017-F-The-Chosen-One-%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>题目链接：<a href="https://nanti.jisuanke.com/t/A1535" target="_blank" rel="noopener">The Chosen One</a></p>
<p>比赛链接：<a href="https://www.jisuanke.com/contest/3107?view=challenges" target="_blank" rel="noopener">ICPC Asia Nanning 2017</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$t$ 组样例，每组给出一个整数 $n(2\le n\le 10^{50})$，求不大于 $n$ 的最大的 $2$ 的整数次幂。</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>高精度运算</strong></p>
<p><code>Java BigInteger</code> 中的 <code>bitLength()</code> 方法可以直接计算某个大数二进制表示下的位数。</p>
<p>更多关于 <code>Java BigInteger</code> 的操作参见我的另一篇文章 <a href="https://wutao18.github.io/2019/08/15/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E4%B9%8B-Java-BigInteger-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/#more">大数运算之 Java BigInteger 的基本用法</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (t--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            BigInteger n = in.nextBigInteger();</span><br><span class="line">            BigInteger ans = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">            System.out.println(ans = ans.pow(n.bitLength() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>Java</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC Asia Nanning 2017 I. Rake It In (DFS+贪心 或 对抗搜索+Alpha-Beta剪枝)</title>
    <url>/2019/08/15/ICPC-Asia-Nanning-2017-I-Rake-It-In-DFS-%E8%B4%AA%E5%BF%83-%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2-alpha-beta%E5%89%AA%E6%9E%9D/</url>
    <content><![CDATA[<p>题目链接：<a href="https://nanti.jisuanke.com/t/A1538" target="_blank" rel="noopener">Rake It In</a></p>
<p>比赛链接：<a href="https://www.jisuanke.com/contest/3107?view=challenges" target="_blank" rel="noopener">ICPC Asia Nanning 2017</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>The designers have come up with a new simple game called “Rake It In”. Two players, Alice and Bob, initially select an integer k and initialize a score indicator. An $4 \times 4$ board is created with 16 values placed on the board. Starting with player Alice, each player in a round selects a $2 \times 2$ region of the board, adding the sum of values in the region to the score indicator, and then rotating these four values $90$ degrees counterclockwise.</p>
<p>After $2k$ rounds in total, each player has made decision in k times. The ultimate goal of Alice is to maximize the final score. However for Bob, his goal is to minimize the final score.</p>
<p>In order to test how good this game is, you are hired to write a program which can play the game. Specifically, given the starting configuration, they would like a program to determine the final score when both players are entirely rational. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains several test cases and the first line provides an integer $t (1 \le t \le 200)$ which is the number of test cases.</p>
<p>Each case contains five lines. The first line provides the integer $k (1 \le k \le 3)$. Each of the following four lines contains four integers indicating the values on the board initially. All values are integers between $1$ to $10$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, output an integer in a line which is the predicted final score.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1 1 2 2</span><br><span class="line">1 1 2 2  </span><br><span class="line">3 3 4 4  </span><br><span class="line">3 3 4 4</span><br><span class="line">2</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2 3 4</span><br><span class="line">3  </span><br><span class="line">1 1 4 4</span><br><span class="line">4 4 1 1</span><br><span class="line">1 1 4 4</span><br><span class="line">1 4 1 4</span><br><span class="line">3  </span><br><span class="line">1 2 3 4</span><br><span class="line">5 1 2 3</span><br><span class="line">4 5 1 2</span><br><span class="line">3 4 5 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">40</span><br><span class="line">63</span><br><span class="line">71</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一块 $4\times 4$ 的板，Alice 和 Bob 每次选择 $2\times 2$ 的区域并逆时针旋转 $90$ 度，这个区域的和累加到总分上。现在 Alice 先手，有 $k$ 轮游戏，Alice 想要分数最大化，Bob 想要分数最小化，求最终的分数。 </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>DFS 贪心</strong></p>
<p>比较好的解法是对抗搜索 与 $Alpha-Beta$ 剪枝。</p>
<p>题解给出是上分支定界和启发式搜索。</p>
<p>但是用贪心 + 爆搜竟然过了。</p>
<p><del>关于对抗搜索和 $Alpha-Beta$ 剪枝以后再更新。</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>DFS + 贪心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> mt[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆时针旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rote</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y]);</span><br><span class="line">    swap(mt[x][y + <span class="number">1</span>], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺时针旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rerote</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    swap(mt[x][y + <span class="number">1</span>], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mt[x][y] + mt[x + <span class="number">1</span>][y] + mt[x][y + <span class="number">1</span>] + mt[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step == <span class="number">2</span> * k) &#123; <span class="comment">// 最后一步</span></span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                ans = min(ans, sum(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 奇数步选择最大 偶数步选择最小</span></span><br><span class="line">        <span class="keyword">int</span> ans = (step &amp; <span class="number">1</span>)? <span class="number">0</span>: inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                rote(i, j); <span class="comment">// 逆时针旋转</span></span><br><span class="line">                <span class="keyword">if</span>(step &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    ans = max(ans, sum(i, j) + dfs(step + <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = min(ans, sum(i, j) + dfs(step + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                rerote(i, j); <span class="comment">// 回溯时转回来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mt[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对抗搜索 + $Alpha-Beta$ 剪枝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> mt[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rote</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y]);</span><br><span class="line">    swap(mt[x][y + <span class="number">1</span>], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rerote</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    swap(mt[x][y + <span class="number">1</span>], mt[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    swap(mt[x][y], mt[x + <span class="number">1</span>][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mt[x][y] + mt[x + <span class="number">1</span>][y] + mt[x][y + <span class="number">1</span>] + mt[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> step, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step == <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                rote(i, j);</span><br><span class="line">                <span class="keyword">if</span>(step &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    alpha = max(alpha, dfs(sum + cnt(i, j), step + <span class="number">1</span>, alpha, beta));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    beta = min(beta, dfs(sum + cnt(i, j), step + <span class="number">1</span>, alpha, beta));</span><br><span class="line">                &#125;</span><br><span class="line">                rerote(i, j);</span><br><span class="line">                <span class="keyword">if</span>(beta &lt;= alpha) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(beta &lt;= alpha) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (step &amp; <span class="number">1</span>)? alpha: beta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mt[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(<span class="number">0</span>, <span class="number">1</span>, -inf, inf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>DFS</tag>
        <tag>模板题</tag>
        <tag>对抗搜索</tag>
        <tag>alpha-beta剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC Asia Nanning 2017 L. Twice Equation (规律 高精度运算)</title>
    <url>/2019/08/15/ICPC-Asia-Nanning-2017-L-Twice-Equation-%E8%A7%84%E5%BE%8B-%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>题目链接：<a href="https://nanti.jisuanke.com/t/A1541" target="_blank" rel="noopener">Twice Equation</a></p>
<p>比赛链接：<a href="https://www.jisuanke.com/contest/3107?view=challenges" target="_blank" rel="noopener">ICPC Asia Nanning 2017</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>For given $L$, find the smallest $n$ no smaller than $L$ for which there exists an positive integer $m$ for which $2m(m + 1) = n(n + 1)$.  </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>This problem contains multiple test cases. The first line of a multiple input is an integer $T (1 \le T &lt; 1000)$ followed by $T$ input lines. Each line contains an integer $L (1 \le L &lt; 10^{190})$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each given $L$, output the smallest $n$. If available nn does not exist, output $−1$.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">20</span><br><span class="line">119</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个整数 $L$，求大于等于 $L$ 的最小整数 $n$ 满足存在一个整数 $m$ 使得 $2m(m + 1) = n(n + 1)$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>找规律 高精度运算</strong></p>
<p>打表找规律</p>
<script type="math/tex; mode=display">f(n) = f(n - 1) * 6 - f(n - 2) + 2</script><p>然后用 Java 大数求解即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        BigInteger[] a = <span class="keyword">new</span> BigInteger[<span class="number">1000</span>];</span><br><span class="line">        <span class="comment">// 打表</span></span><br><span class="line">        a[<span class="number">0</span>] = BigInteger.ZERO;</span><br><span class="line">        a[<span class="number">1</span>] = BigInteger.valueOf(<span class="number">3</span>);</span><br><span class="line">        BigInteger six = <span class="keyword">new</span> BigInteger(<span class="string">"6"</span>);</span><br><span class="line">        BigInteger two = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">300</span>; ++i) &#123;</span><br><span class="line">            a[i] = ((a[i - <span class="number">1</span>].multiply(six)).subtract(a[i - <span class="number">2</span>])).add(two);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (t--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            BigInteger l = in.nextBigInteger();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].compareTo(l) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(a[i]);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>Java</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ #113. 最大异或和 (线性基)</title>
    <url>/2019/08/28/LOJ-113-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C-%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://loj.ac/problem/113" target="_blank" rel="noopener">#113. 最大异或和</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>这是一道模板题。</p>
<p>给由 $n$ 个数组成的一个可重集 $S$，每次给定一个数 $k$，求一个集合 $T \subseteq S$，使得集合 $T$ 在 $S$ 的所有非空子集的不同的异或和中，其异或和 $T_1 xor T_2 xor …  xor T_{|T|}$ 是第 $k$ 小的。</p>
</blockquote>
<a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><blockquote>
<p>第一行一个数 $n$。</p>
<p>第二行 $n$ 个数，表示集合 $S$。</p>
<p>第三行一个数 $m$，表示询问次数。</p>
<p>第四行 $m$ 个数，表示每一次询问的 $k$。</p>
</blockquote>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><blockquote>
<p>输出 $m$ 行，对应每一次询问的答案，第 $k$ 小的异或和。如果集合 $S$ 的所有非空子集中，不同的异或和数量不足 $k$，输出 $-1$。</p>
</blockquote>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><blockquote>
<p>样例输入</p>
<blockquote>
<pre><code>3
1 2 3
5
1 2 3 4 5
</code></pre></blockquote>
<p>样例输出</p>
<blockquote>
<pre><code>0
1
2
3
-1
</code></pre></blockquote>
</blockquote>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><blockquote>
<p>$1\le n,m\le 10^5, 0\le S_i\le 2^{50}$</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>线性基 贪心</strong></p>
<p>线性基模板题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxbit = <span class="number">63</span>; <span class="comment">// long long 最大 2^63 - 1. 最多 63 位. 用数组表示为 0 ~ 62.</span></span><br><span class="line"></span><br><span class="line">ll p[maxbit];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                p[i] = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((ans ^ p[i]) &gt; ans) &#123;</span><br><span class="line">            ans ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>线性基</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1030 Discovering Gold (概率/期望DP)</title>
    <url>/2019/10/13/LightOJ-1030-Discovering-Gold-%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9BDP/</url>
    <content><![CDATA[<p>题目链接：<a href="http://lightoj.com/volume_showproblem.php?problem=1030" target="_blank" rel="noopener">LightOJ - 1030</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>You are in a cave, a long cave! The cave can be represented by a $1 \times N$ grid. Each cell of the cave can contain any amount of gold.</p>
<p>Initially you are in position $1$. Now each turn you throw a perfect $6$ sided dice. If you get $X$ in the dice after throwing, you add $X$ to your position and collect all the gold from the new position. If your new position is outside the cave, then you keep throwing again until you get a suitable result. When you reach the $N^{th}$ position you stop your journey. Now you are given the information about the cave, you have to find out the <strong>expected</strong> number of gold you can collect using the given procedure.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input starts with an integer $T (≤ 100)$, denoting the number of test cases.</p>
<p>Each case contains a blank line and an integer $N (1 ≤ N ≤ 100)$ denoting the dimension of the cave. The next line contains $N$ space separated integers. The $i^{th}$ integer of this line denotes the amount of gold you will get if you come to the $i^{th}$ cell. You may safely assume that all the given integers will be non-negative and no integer will be greater than $1000$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, print the case number and the expected number of gold you will collect. Errors less than $10^{-6}$ will be ignored.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">101</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">10 3</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">3 6 9</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case 1: 101.0000000000</span><br><span class="line">Case 2: 13.000</span><br><span class="line">Case 3: 15</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $N$ 个格子，每个格子有价值为 $val[i]$ 的金子，初始你在第一个格子。</p>
<p>每次抛一个 $6$ 面的骰子，抛到的数为 $X_i$，就往前走 $X_i$ 个格子，如果超过格子 $N$，就重新抛，走到格子 $N$ 就结束。求拿到金子的价值的期望。 </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以用 <strong>概率 DP</strong> 或 <strong>期望 DP</strong> 解决。</p>
<p><strong>概率DP</strong></p>
<p>求出到达每个格子的概率，然后乘上每个格子的价值再累加起来就行。</p>
<p>设 $dp[i]$ 为到格子 $i$ 的概率，则 $dp[i + j] = dp[i + j] + dp[i] / k (1\le j\le k, k = min(6, n - i))$。</p>
<p><strong>期望DP</strong></p>
<p>设 $dp[i]$ 为格子 $i$ 到 $N$ 的能获得黄金的期望，则 $dp[N] = val[N]$。</p>
<p>状态转移方程为 $dp[i] = \frac{1}{k} \sum_{j=1}^kdp[i+j] (k = min(6, n - i))$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><strong>概率DP</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = min(<span class="number">6</span>, n - i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                dp[i + j] += dp[i] * <span class="number">1.0</span> / k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans += dp[i] * v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.7lf\n"</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>期望DP</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[n] = v[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            dp[i] = v[i];</span><br><span class="line">            <span class="keyword">int</span> k = min(<span class="number">6</span>, n - i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                dp[i] += dp[i + j] * <span class="number">1.0</span> / k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.7lf\n"</span>, ++kase, dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>概率DP</tag>
        <tag>数学</tag>
        <tag>动态规划</tag>
        <tag>期望DP</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ #103. 子串查找 (Hash)</title>
    <url>/2019/10/10/LOJ-103-%E5%AD%90%E4%B8%B2%E6%9F%A5%E6%89%BE-Hash/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个字符串 $A$ 和 $B$，求 $B$ 在 $A$ 中的出现次数。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道 $KMP$ 的模板题。</p>
<p>不过 $Hash$ 是个好东西，可以用 $Hash$ 代替 $KMP$ 算法。</p>
<p>预处理两个字符串的哈希值，然后将 $A$ 中所有长度为 $len(B)$ 的子串的哈希值与 $B$ 的哈希值比较即可。</p>
<p>时间复杂度 $O(n + m)$，与 $KMP$ 算法一样！</p>
<p>缺点就是常数略大，而且不能用 $KMP$ 的 $next$ 数组。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line">ull h1[maxn], h2;</span><br><span class="line">ull p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i) &#123;</span><br><span class="line">        h1[i + <span class="number">1</span>] = h1[i] * base + (ull)s1[i];</span><br><span class="line">        p[i + <span class="number">1</span>] = p[i] * base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.size(); ++i) &#123;</span><br><span class="line">        h2 = h2 * base + (ull)s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s2.size(); i &lt;= s1.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(h1[i] - h1[i - s2.size()] * p[s2.size()] == h2) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/lfri/p/11375376.html" target="_blank" rel="noopener">LOJ 103子串查找——用hash代替kmp算法</a></p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>哈希/Hash</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1027 A Dangerous Maze (期望)</title>
    <url>/2019/10/13/LightOJ-1027-A-Dangerous-Maze-%E6%9C%9F%E6%9C%9B/</url>
    <content><![CDATA[<p>题目链接：<a href="http://lightoj.com/volume_showproblem.php?problem=1027" target="_blank" rel="noopener">LightOJ - 1027</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>You are in a maze; seeing $n$ doors in front of you in beginning. You can choose any door you like. The probability for choosing a door is equal for all doors.</p>
<p>If you choose the $i^{th}$ door, it can either take you back to the same position where you begun in $x_i$ minutes, or can take you out of the maze after $x_i$ minutes. If you come back to the same position, you can’t remember anything. So, every time you come to the beginning position, you have no past experience.</p>
<p>Now you want to find the expected time to get out of the maze.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input starts with an integer $T (≤ 100)$, denoting the number of test cases.</p>
<p>Each case contains a blank line and an integer $n (1 ≤ n ≤ 100)$ denoting the number of doors. The next line contains n space separated integers. If the $i^{th}$ integer $(x_i)$ is positive, you can assume that the $i^{th}$ door will take you out of maze after $x_i$ minutes. If it’s negative, then the $i^{th}$ door will take you back to the beginning position after $abs(x_i)$ minutes. You can safely assume that $1 ≤ abs(x_i) ≤ 10000$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, print the case number and the expected time to get out of the maze. If it’s impossible to get out of the maze, print ‘$inf$’. Print the result in $p/q$ format. Where $p$ is the numerator of the result and $q$ is the denominator of the result and they are relatively prime. See the samples for details.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">-10 -3</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">3 -6 -9</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case 1: 1/1</span><br><span class="line">Case 2: inf</span><br><span class="line">Case 3: 18/1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>你在一个迷宫里，面前有 $n$ 扇门，如果第 $i$ 扇门的 $X_i$ 值为正值，就可以花费 $X_i$ 的时间的走出迷宫，否则花费 $abs(X_i)$ 的时间又回到原点，且不记得之前走过哪些门。每次等概率选择一扇门，问走出迷宫的时间的期望。不能走出去输出 $inf$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设有 $n_1$ 扇门能走出迷宫，$n_2$ 不能走出迷宫，则 $n_1 + n_2 = n$。</p>
<p>设 $n_1$ 扇门的 $X_i$ 值的平均值为 $t_1$，$n_2$ 扇门的 $X_i$ 值的平均值为 $t_2$.</p>
<p>设走出去的期望为 $E$。则 $E = \frac{n_1}{n} \cdot t_1 + \frac{n_2}{n} \cdot (t_2 + E)$。</p>
<p>化简后为 $E = \frac{1}{n_1}\sum_{i=1}^n abs(X_i)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">0</span>? b: gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">            <span class="keyword">if</span>(x[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                sum += x[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += -x[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = gcd(sum, cnt);</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Case %d: inf\n"</span>, ++kase);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: %d/%d\n"</span>, ++kase, sum / d, cnt / d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1203 Guarding Bananas (凸包最小顶角)</title>
    <url>/2019/08/16/LightOJ-1203-Guarding-Bananas-%E5%87%B8%E5%8C%85%E6%9C%80%E5%B0%8F%E9%A1%B6%E8%A7%92/</url>
    <content><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/LightOJ-1203" target="_blank" rel="noopener">LightOJ 1203</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Once there was a lazy monkey in a forest. But he loved banana too much. One day there was a storm in the jungle and all the bananas fell from the trees. The monkey didn’t want to lose any of the bananas. So, he wanted to find a banana such that he can eat that and he can also look after the other bananas. As he was lazy, he didn’t want to move his eyes too wide. So, you have to help him finding the banana from where he can look after all the bananas but the degree of rotating his eyes is as small as possible. You can assume that the position of the bananas can be modeled as 2D points.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/16/1565965913509-1565965913549.png" alt=""></p>
<p>Here a banana is shown, from where the monkey can look after all the bananas with minimum eye rotation.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input starts with an integer $T (\le 13)$, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer $n (1 \le n \le 105)$ denoting the number of bananas. Each of the next $n$ lines contains two integers $x y (-10^9 \le x, y \le 10^9)$ denoting the co-ordinate of a banana. There can me more than one bananas in the same co-ordinate.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, print the case number and the minimum angle in degrees. Errors less than $10^-6$ will be ignored.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">4 4</span><br><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">10 0</span><br><span class="line">10 10</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case 1: 0</span><br><span class="line">Case 2: 45.0000000</span><br></pre></td></tr></table></figure>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>Dataset is huge. Use faster I/O methods.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定若干个点的坐标，求凸包最小顶角。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>凸包</strong></p>
<p>先求凸包，然后枚举所有顶角求最小值。</p>
<p>顶角求法：用两个向量的夹角求</p>
<p>$\angle BAC$ 为向量 $\overrightarrow {AB}$ 与 $\overrightarrow {AC}$ 的夹角：</p>
<script type="math/tex; mode=display">cos<\overrightarrow {AB}, \overrightarrow {AC}> = \frac{\overrightarrow {AB} ⋅ \overrightarrow {AC}}{|\overrightarrow {AB}| |\overrightarrow {AC}|}</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> a, <span class="keyword">double</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; b.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; b.x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[maxn], stk[maxn];</span><br><span class="line"><span class="keyword">typedef</span> Point Vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vec a, Vec b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; k &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">(Point p, Point q, Point s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1 = q.x - p.x, y1 = q.y - p.y;</span><br><span class="line">    <span class="keyword">double</span> x2 = s.x - p.x, y2 = s.y - p.y;</span><br><span class="line">    <span class="keyword">double</span> ans = (x1 * x2 + y1 * y2) / (<span class="built_in">sqrt</span>(x1 * x1 + y1 * y1) * <span class="built_in">sqrt</span>(x2 * x2 + y2 * y2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(mp[make_pair(x, y)] == <span class="number">0</span>) &#123;</span><br><span class="line">                mp[make_pair(x, y)] = <span class="number">1</span>;</span><br><span class="line">                p[++n].x = x;</span><br><span class="line">                p[n].y = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: 0\n"</span>, ++kase);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = Andrew();</span><br><span class="line">        <span class="keyword">double</span> min_angle = angle(stk[<span class="number">1</span>], stk[t - <span class="number">1</span>], stk[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; t; i++) &#123;</span><br><span class="line">            min_angle = min(min_angle, angle(stk[i], stk[i - <span class="number">1</span>], stk[i + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.6lf\n"</span>, ++kase, min_angle * <span class="number">180.0</span> / pi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1418 Trees on My Island (Pick定理)</title>
    <url>/2019/11/12/LightOJ-1418-Trees-on-My-Island-Pick%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/LightOJ-1418" target="_blank" rel="noopener">LightOJ 1418</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>I have bought an island where I want to plant trees in rows and columns. So, the trees will form a rectangular grid and each of them can be thought of having integer coordinates by taking a suitable grid point as the origin.</p>
<p>But, the problem is that the island itself is not rectangular. So, I have identified a simple polygonal area inside the island with vertices on the grid points and have decided to plant trees on grid points lying strictly inside the polygon.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/12/1573572162954-1573572163167.png" alt=""></p>
<p>Figure: A sample of my island</p>
<p>For example, in the above figure, the green circles form the polygon, and the blue circles show the position of the trees.</p>
<p>Now, I seek your help for calculating the number of trees that can be planted on my island.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input starts with an integer $T (≤ 100)$, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer $N (3 ≤ N ≤ 10000)$ denoting the number of vertices of the polygon.</p>
<p>Each of the next $N$ lines contains two integers $x_i y_i (-10^6 ≤ x_i, y_i ≤ 10^6)$ denoting the co-ordinate of a vertex. The vertices will be given in clockwise or anti-clockwise order. And they will form a simple polygon.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, print the case number and the total number of trees that can be planted inside the polygon.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">4 1</span><br><span class="line"></span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">6 2</span><br><span class="line"></span><br><span class="line">6 4</span><br><span class="line"></span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">1 5</span><br><span class="line"></span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case 1: 8</span><br></pre></td></tr></table></figure>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote>
<p>Dataset is huge, use faster I/O methods.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个多边形，顶点都在格点上，求多边形内部的格点个数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://oi-wiki.org/geometry/pick/" target="_blank" rel="noopener">Pick 定理</a> 裸题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll x, y;</span><br><span class="line">    Point(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        ll on = <span class="number">0</span>;</span><br><span class="line">        ll s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        p[n] = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s += (p[i + <span class="number">1</span>] - p[<span class="number">0</span>]).cross(p[i] - p[<span class="number">0</span>]);</span><br><span class="line">            on += gcd(<span class="built_in">abs</span>(p[i].x - p[i + <span class="number">1</span>].x), <span class="built_in">abs</span>(p[i].y - p[i + <span class="number">1</span>].y));</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">abs</span>(s);</span><br><span class="line">        ll in = s / <span class="number">2</span> - on / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, _);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>Pick定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1248 Dice (III) (期望DP / 几何分布)</title>
    <url>/2019/10/21/LightOJ-1248-Dice-III-%E6%9C%9F%E6%9C%9BDP-%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p>题目链接：<a href="http://lightoj.com/volume_showproblem.php?problem=1248" target="_blank" rel="noopener">LightOJ - 1248</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Given a dice with <strong>n</strong> sides, you have to find the expected number of times you have to throw that dice to see all its faces at least once. Assume that the dice is fair, that means when you throw the dice, the probability of occurring any face is equal.</p>
<p>For example, for a fair two sided coin, the result is 3. Because when you first throw the coin, you will definitely see a new face. If you throw the coin again, the chance of getting the opposite side is 0.5, and the chance of getting the same side is 0.5. So, the result is</p>
<p>$1 + (1 + 0.5 <em> (1 + 0.5 </em> …))$</p>
<p>$= 2 + 0.5 + 0.5^2 + 0.5^3 + …$</p>
<p>$= 2 + 1 = 3$</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input starts with an integer $T (≤ 100)$, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer $n (1 ≤ n ≤ 10^5)$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each case, print the case number and the expected number of times you have to throw the dice to see all its faces at least once. Errors less than $10^{-6}$ will be ignored.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 3</span><br><span class="line">Case 3: 5.5</span><br><span class="line">Case 4: 14.7</span><br><span class="line">Case 5: 518.7377517640</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n$ 面的骰子，每个面出现的概率相同，现在要所有的面都至少出现一次，求投掷次数的期望。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>期望DP</strong></p>
<p>期望DP一般是倒推的。</p>
<p>设 $dp[i]$ 为已经出现了 $i$ 个面，还需要投掷次数的期望值。</p>
<p>那么每次投掷只有两种情况：出现已经出现过的面、出现未出现的面。前者概率为 $\frac{i}{n}$，后者概率为 $\frac{n - i}{n}$。</p>
<p>则状态转移方程为 $dp[i] = (dp[i] + 1) <em> \frac{i}{n} + (dp[i + 1] + 1) </em> \frac{n - i}{n}$</p>
<p>化简得 $dp[i] = dp[i + 1] + \frac{n}{n - i}$</p>
<p>$dp[n] = 0$，倒推即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>] + <span class="number">1.0</span> * n / (n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.10lf\n"</span>, ++kase, dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实是满足<a href="https://en.wikipedia.org/wiki/Geometric_distribution" target="_blank" rel="noopener">几何分布</a>的。</p>
<p>第一个出现的面可以是 $1, 2, 3, …, n$，有 $n$ 个。</p>
<p>如果第一个出现的面是 $1$，那么第二个出现的面可以是 $2, 3, …, n$，有 $n - 1$ 个。</p>
<p>…</p>
<p>第一个面第一次出现的概率为 $p_1 = \frac{n}{n}$</p>
<p>第二个面第一次出现的概率为 $p_2 = \frac{n - 1}{n}$</p>
<p>第三个面第一次出现的概率为 $p_3 = \frac{n - 2}{n}$</p>
<p>…</p>
<p>第 $i$ 个面第一次出现的概率为 $p_i = \frac{n - i + 1}{n}$</p>
<p>几何分布的期望 $E(X) = \frac{1}{p}$</p>
<p>所以所有面至少出现一次的期望为 $\sum_{i=1}^n \frac{1}{p_i} = \sum_{i=1}^n \frac{n}{n - i + 1}$。</p>
<p>注：几何分布指在 $n$ 次伯努利试验中，试验 $k$ 次才得到第一次成功的机率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans += n * <span class="number">1.0</span> / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.10lf\n"</span>, ++kase, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="https://blog.csdn.net/lidengdengter/article/details/82527426" target="_blank" rel="noopener">LightOJ - 1248 Dice (III) （概率期望+几何分布）
</a></p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>期望DP</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1066 Treasure Hunt (线段相交)</title>
    <url>/2019/10/17/POJ-1066-Treasure-Hunt-%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1066" target="_blank" rel="noopener">POJ 1066</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Archeologists from the Antiquities and Curios Museum (ACM) have flown to Egypt to examine the great pyramid of Key-Ops. Using state-of-the-art technology they are able to determine that the lower floor of the pyramid is constructed from a series of straightline walls, which intersect to form numerous enclosed chambers. </p>
<p>Currently, no doors exist to allow access to any chamber. This state-of-the-art technology has also pinpointed the location of the treasure room. What these dedicated (and greedy) archeologists want to do is blast doors through the walls to get to the treasure room. However, to minimize the damage to the artwork in the intervening chambers (and stay under their government grant for dynamite) they want to blast through the minimum number of doors. For structural integrity purposes, doors should only be blasted at the midpoint of the wall of the room being entered. You are to write a program which determines this minimum number of doors.</p>
<p>An example is shown below:<br><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/17/1571312763972-1571312764176.png" alt=""></p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input will consist of one case. The first line will be an integer n (0 &lt;= n &lt;= 30) specifying number of interior walls, followed by n lines containing integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are not included in the list of walls. The interior walls always span from one exterior wall to another exterior wall and are arranged such that no more than two walls intersect at any point. You may assume that no two given walls coincide. After the listing of the interior walls there will be one final line containing the floating point coordinates of the treasure in the treasure room (guaranteed not to lie on a wall).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Print a single line listing the minimum number of doors which need to be created, in the format shown below.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">7 </span><br><span class="line">20 0 37 100 </span><br><span class="line">40 0 76 100 </span><br><span class="line">85 0 0 75 </span><br><span class="line">100 90 0 90 </span><br><span class="line">0 71 100 61 </span><br><span class="line">0 14 100 38 </span><br><span class="line">100 47 47 100 </span><br><span class="line">54.5 55.4</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Number of doors = 2</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=East+Central+North+America+1999" target="_blank" rel="noopener">East Central North America 1999</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 条线段，代表围墙，最外层为 $100 \times 100$ 的正方形围墙。给定宝藏的坐标，求从外面进去拿到宝藏最少要穿过几堵墙。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举正方形边上的所有端点与宝藏构成的线段，与多少堵墙相交，相交最少的即为答案。</p>
<p>线段 $A$ 与线段 $B$ 相交的判断：$A$ 的两个端点在线段 $B$ 的两边且线段 $B$ 的两个端点在线段 $A$ 的两边。 </p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        Line l = a;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(angle - l.angle) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l.toLeftTest(s) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> angle &lt; l.angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">segcrossseg</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l.toLeftTest(s) * l.toLeftTest(e) == <span class="number">-1</span> &amp;&amp; toLeftTest(l.s) * toLeftTest(l.e) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		<span class="keyword">double</span> a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        <span class="keyword">double</span> x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">double</span> y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[<span class="number">100</span>];</span><br><span class="line">Point tar;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Line l1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i].segcrossseg(l1)) &#123;</span><br><span class="line">            ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        l[i].input();</span><br><span class="line">    &#125;</span><br><span class="line">    tar.input();</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Line l1 = Line(l[i].s, tar);</span><br><span class="line">        Line l2 = Line(l[i].e, tar);</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(l[j].segcrossseg(l1)) &#123;</span><br><span class="line">                ++cnt1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l[j].segcrossseg(l2)) &#123;</span><br><span class="line">                ++cnt2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = min(ans, min(cnt1, cnt2));</span><br><span class="line">    &#125;</span><br><span class="line">    Point tmp = Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ans = min(ans, f(Line(tmp, tar)));</span><br><span class="line">    tmp = Point(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    ans = min(ans, f(Line(tmp, tar)));</span><br><span class="line">    tmp = Point(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    ans = min(ans, f(Line(tmp, tar)));</span><br><span class="line">    tmp = Point(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    ans = min(ans, f(Line(tmp, tar)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Number of doors = %d\n"</span>, ans + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1113 Wall (凸包)</title>
    <url>/2019/08/17/POJ-1113-Wall-%E5%87%B8%E5%8C%85/</url>
    <content><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/POJ-1113" target="_blank" rel="noopener">POJ 1113</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Once upon a time there was a greedy King who ordered his chief Architect to build a wall around the King’s castle. The King was so greedy, that he would not listen to his Architect’s proposals to build a beautiful brick wall with a perfect shape and nice tall towers. Instead, he ordered to build the wall around the whole castle using the least amount of stone and labor, but demanded that the wall should not come closer to the castle than a certain distance. If the King finds that the Architect has used more resources to build the wall than it was absolutely necessary to satisfy those requirements, then the Architect will loose his head. Moreover, he demanded Architect to introduce at once a plan of the wall listing the exact amount of resources that are needed to build the wall. </p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/17/1566026079827-1566026080317.png" alt=""></p>
<p>Your task is to help poor Architect to save his head, by writing a program that will find the minimum possible length of the wall that he could build around the castle to satisfy King’s requirements. </p>
<p>The task is somewhat simplified by the fact, that the King’s castle has a polygonal shape and is situated on a flat ground. The Architect has already established a Cartesian coordinate system and has precisely measured the coordinates of all castle’s vertices in feet.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input file contains two integer numbers N and L separated by a space. N (3 &lt;= N &lt;= 1000) is the number of vertices in the King’s castle, and L (1 &lt;= L &lt;= 1000) is the minimal number of feet that King allows for the wall to come close to the castle. </p>
<p>Next N lines describe coordinates of castle’s vertices in a clockwise order. Each line contains two integer numbers Xi and Yi separated by a space (-10000 &lt;= Xi, Yi &lt;= 10000) that represent the coordinates of ith vertex. All vertices are different and the sides of the castle do not intersect anywhere except for vertices.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Write to the output file the single number that represents the minimal possible length of the wall in feet that could be built around the castle to satisfy King’s requirements. You must present the integer number of feet to the King, because the floating numbers are not invented yet. However, you must round the result in such a way, that it is accurate to 8 inches (1 foot is equal to 12 inches), since the King will not tolerate larger error in the estimates.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">9 100</span><br><span class="line">200 400</span><br><span class="line">300 400</span><br><span class="line">300 300</span><br><span class="line">400 300</span><br><span class="line">400 400</span><br><span class="line">500 400</span><br><span class="line">500 200</span><br><span class="line">350 200</span><br><span class="line">200 200</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1628</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>结果四舍五入就可以了</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个有 $N$ 个顶点的城堡，现在要造墙将城堡围起来，且墙必须离城堡的边至少 $L$ 单位远，并且墙的总长度尽量小。求此长度。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>凸包</strong></p>
<p>凸包的周长加上以 $L$ 为半径的圆的周长即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> a, <span class="keyword">double</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; b.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; b.x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[maxn], stk[maxn];</span><br><span class="line"><span class="keyword">typedef</span> Point Vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vec a, Vec b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; k &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = Andrew();</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t; i++) &#123;</span><br><span class="line">            ans += dist(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">2</span> * pi * l;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(ans + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>P2216 [HAOI2007]理想的正方形 (单调队列)</title>
    <url>/2019/09/09/P2216-HAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P2216" target="_blank" rel="noopener">P2216 [HAOI2007]理想的正方形</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>有一个 $a\times b$的整数组成的矩阵，现请你从中找出一个 $n\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>
</blockquote>
<a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><blockquote>
<p>第一行为3个整数，分别表示a,b,n的值</p>
<p>第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。</p>
</blockquote>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><blockquote>
<p>仅一个整数，为 $a\times b$矩阵中所有“ $n\times n$正方形区域中的最大整数和最小整数的差值”的最小值。</p>
</blockquote>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 4 2</span><br><span class="line">1 2 5 6</span><br><span class="line">0 17 16 0</span><br><span class="line">16 17 2 1</span><br><span class="line">2 10 2 1</span><br><span class="line">1 2 2 2</span><br></pre></td></tr></table></figure><br>输出 #1<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><blockquote>
<p>问题规模</p>
<p>（1）矩阵中的所有数都不超过1,000,000,000</p>
<p>（2）20%的数据2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10</p>
<p>（3）100%的数据2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>单调队列</strong></p>
<p>二维 RMQ 问题。</p>
<p>设原矩阵为 m[][]，用单调队列求每行的最大/最小值，分别存入两个矩阵 maxr[][] 和 minr[][]。maxr[i][j] 代表 m[i][j] 到 m[i][j + n - 1] 的最大值，minr[i][j] 代表 m[i][j] 到 m[i][j + n - 1] 的最小值。</p>
<p>接下来对这两个矩阵用单调队列求每列的最大/最小值，分别存入两个矩阵 maxc[][] 和 minc[][]。maxr[i][j] 代表 m[i][j] 到 m[i + n - 1][j + n - 1] 的最大值，minr[i][j] 代表 m[i][j] 到 m[i + n - 1][j + n - 1] 的最小值。</p>
<p>最后遍历 maxc[][] 和 minc[][] 即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxr[maxn][maxn], maxc[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> minr[maxn][maxn], minc[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> q1[maxn] = &#123;<span class="number">0</span>, l&#125;, q2[maxn] = &#123;<span class="number">0</span>, L&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; j - q1[l] &gt;= n) ++l;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; m[i][j] &lt;= m[i][q1[r]]) --r;</span><br><span class="line">            q1[++r] = j;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= n) minr[i][j - n + <span class="number">1</span>] = m[i][q1[l]];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(R &gt;= L &amp;&amp; j - q2[L] &gt;= n) ++L;</span><br><span class="line">            <span class="keyword">while</span>(R &gt;= L &amp;&amp; m[i][j] &gt;= m[i][q2[R]]) --R;</span><br><span class="line">            q2[++R] = j;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= n) maxr[i][j - n + <span class="number">1</span>] = m[i][q2[L]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> q1[maxn] = &#123;<span class="number">0</span>, l&#125;, q2[maxn] = &#123;<span class="number">0</span>, L&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= a; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; j - q1[l] &gt;= n) ++l;</span><br><span class="line">            <span class="keyword">while</span>(r &gt;= l &amp;&amp; minr[j][i] &lt;= minr[q1[r]][i]) --r;</span><br><span class="line">            q1[++r] = j;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= n) minc[j - n + <span class="number">1</span>][i] = minr[q1[l]][i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(R &gt;= L &amp;&amp; j - q2[L] &gt;= n) ++L;</span><br><span class="line">            <span class="keyword">while</span>(R &gt;= L &amp;&amp; maxr[j][i] &gt;= maxr[q2[R]][i]) --R;</span><br><span class="line">            q2[++R] = j;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= n) maxc[j - n + <span class="number">1</span>][i] = maxr[q2[L]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b - n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            ans = min(ans, maxc[i][j] - minc[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>单调队列</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1265 Area (Pick定理 &amp; 多边形面积)</title>
    <url>/2019/09/05/POJ-1265-Area-Pick%E5%AE%9A%E7%90%86-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1265" target="_blank" rel="noopener">POJ 1265</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Being well known for its highly innovative products, Merck would definitely be a good target for industrial espionage. To protect its brand-new research and development facility the company has installed the latest system of surveillance robots patrolling the area. These robots move along the walls of the facility and report suspicious observations to the central security office. The only flaw in the system a competitor抯 agent could find is the fact that the robots radio their movements unencrypted. Not being able to find out more, the agent wants to use that information to calculate the exact size of the area occupied by the new facility. It is public knowledge that all the corners of the building are situated on a rectangular grid and that only straight walls are used. Figure 1 shows the course of a robot around an example area.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/05/1567683990140-1567683990334.png" alt=""><br>Figure 1: Example area.</p>
<p>You are hired to write a program that calculates the area occupied by the new facility from the movements of a robot along its walls. You can assume that this area is a polygon with corners on a rectangular grid. However, your boss insists that you use a formula he is so proud to have found somewhere. The formula relates the number I of grid points inside the polygon, the number E of grid points on the edges, and the total area A of the polygon. Unfortunately, you have lost the sheet on which he had written down that simple formula for you, so your first task is to find the formula yourself.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains the number of scenarios.</p>
<p>For each scenario, you are given the number m, 3 &lt;= m &lt; 100, of movements of the robot in the first line. The following m lines contain pairs 揹x dy�of integers, separated by a single blank, satisfying .-100 &lt;= dx, dy &lt;= 100 and (dx, dy) != (0, 0). Such a pair means that the robot moves on to a grid point dx units to the right and dy units upwards on the grid (with respect to the current position). You can assume that the curve along which the robot moves is closed and that it does not intersect or even touch itself except for the start and end points. The robot moves anti-clockwise around the building, so the area to be calculated lies to the left of the curve. It is known in advance that the whole polygon would fit into a square on the grid with a side length of 100 units.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The output for every scenario begins with a line containing 揝cenario #i:� where i is the number of the scenario starting at 1. Then print a single line containing I, E, and A, the area A rounded to one digit after the decimal point. Separate the three numbers by two single blanks. Terminate the output for the scenario with a blank line.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">-1 0</span><br><span class="line">0 -1</span><br><span class="line">7</span><br><span class="line">5 0</span><br><span class="line">1 3</span><br><span class="line">-2 2</span><br><span class="line">-1 0</span><br><span class="line">0 -3</span><br><span class="line">-3 1</span><br><span class="line">0 -3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">0 4 1.0</span><br><span class="line"></span><br><span class="line">Scenario #2:</span><br><span class="line">12 16 19.0</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Northwestern+Europe+2001" target="_blank" rel="noopener">Northwestern Europe 2001</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个多边形，所有点都在格点上，求多边形内部的点，边上的点和多边形的面积。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>Pick定理</strong></p>
<p>Pick 定理：多边形面积 $A$ 和内部格点数目 $i$，边上格点数目 $b$ 的关系为 $A = i + \frac{b}{2} - 1$ 。</p>
<p>相关证明见 <a href="https://en.wikipedia.org/wiki/Pick%27s_theorem" target="_blank" rel="noopener">Pick’s theorem</a></p>
<p>多边形面积：按顺序求相邻两点与原点组成的向量的向量的叉积之和。</p>
<p>多边形边上的点：若一条边的两个点都在格点上，则该边上的格点数为 $gcd(dx, dy)$，$dx$ 和 $dy$ 分别为线段横向占的点数和纵向占的点数。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; ++_) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> on = <span class="number">0</span>;</span><br><span class="line">        db s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] + Point(x, y);</span><br><span class="line">            on += gcd(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">            s += (p[i - <span class="number">1</span>]).cross(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        s *= <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">int</span> in = (<span class="keyword">int</span>)s - on / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>, _);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %.1lf\n\n"</span>, in, on, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>Pick定理</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1269 Intersecting Lines (判断直线位置关系)</title>
    <url>/2019/08/27/POJ-1269-Intersecting-Lines-%E5%88%A4%E6%96%AD%E7%9B%B4%E7%BA%BF%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1269" target="_blank" rel="noopener">POJ 1269</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>We all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways: 1) no intersection because they are parallel, 2) intersect in a line because they are on top of one another (i.e. they are the same line), 3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect. </p>
<p>Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>There should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read “END OF OUTPUT”.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0 0 4 4 0 4 4 0</span><br><span class="line">5 0 7 6 1 0 2 3</span><br><span class="line">5 0 7 6 3 -6 4 -3</span><br><span class="line">2 0 2 27 1 5 18 5</span><br><span class="line">0 3 4 0 1 2 2 5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">INTERSECTING LINES OUTPUT</span><br><span class="line">POINT 2.00 2.00</span><br><span class="line">NONE</span><br><span class="line">LINE</span><br><span class="line">POINT 2.00 5.00</span><br><span class="line">POINT 1.07 2.20</span><br><span class="line">END OF OUTPUT</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 组样例。每组样例给定两条直线，判断直线是平行，重合还是相交。若相交求交点。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>叉积</strong></p>
<ul>
<li>判断共线：</li>
</ul>
<p>若 $\boldsymbol{ab}$ 与 $\boldsymbol{cd}$ 共线，则 $\boldsymbol{ab} \times \boldsymbol{cd} = 0$。</p>
<ul>
<li>判断重合：</li>
</ul>
<p>若 $\boldsymbol{ab}$ 与 $\boldsymbol{cd}$ 重合，则 $\boldsymbol{bc} \times \boldsymbol{ad} = 0$。</p>
<ul>
<li>判断平行：</li>
</ul>
<p>共线且不重合。</p>
<ul>
<li>求交点：</li>
</ul>
<p>首先要满足相交。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/27/1566893992918-1566893993136.png" alt=""></p>
<p>如上图，求 $\boldsymbol{AB}$ 与 $\boldsymbol{CD}$ 的交点 $E$。</p>
<script type="math/tex; mode=display">\frac{AE}{BE} = \frac{S_{\triangle ACD}}{S_{\triangle BCD}} = \frac{|\boldsymbol{CA} \times \boldsymbol{CD}|}{|\boldsymbol{CB} \times \boldsymbol{CD}|}</script><script type="math/tex; mode=display">\boldsymbol{AE} = \frac{|\boldsymbol{AE}|}{|\boldsymbol{AB}|} \boldsymbol{AB} = \frac{|\boldsymbol{AE}|}{|\boldsymbol{AE}| + |\boldsymbol{EB}|} \boldsymbol{AB} = \frac{S_{\triangle ACD}}{S_{\triangle ACD} + S_{\triangle BCD}} \boldsymbol{AB}</script><p>设原点为 $O$，则</p>
<script type="math/tex; mode=display">\boldsymbol{OE} = \boldsymbol{OA} + \boldsymbol{AE}</script><p>$\boldsymbol{OE}$ 即为点 $E$ 的坐标。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共线</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">collinear</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同线</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平行</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parallel</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> collinear(l) &amp;&amp; (!same(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直线与直线交点</span></span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		<span class="keyword">double</span> a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        Point ans = s + (e - s) * (-a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(ans.x) == <span class="number">0</span>) ans.x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(ans.y) == <span class="number">0</span>) ans.y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直线与直线位置关系 0-重合 1-平行 2-相交</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span> <span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l1, l2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INTERSECTING LINES OUTPUT\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        l1.input();</span><br><span class="line">        l2.input();</span><br><span class="line">        <span class="keyword">if</span>(l1.linecrossline(l2) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"LINE\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l1.linecrossline(l2) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NONE\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Point ans = l1.crosspoint(l2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"POINT %.2lf %.2lf\n"</span>, ans.x, ans.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"END OF OUTPUT\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1279 Art Gallery (半平面交)</title>
    <url>/2019/09/11/POJ-1279-Art-Gallery-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1279" target="_blank" rel="noopener">POJ 1279</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>The art galleries of the new and very futuristic building of the Center for Balkan Cooperation have the form of polygons (not necessarily convex). When a big exhibition is organized, watching over all of the pictures is a big security concern. Your task is that for a given gallery to write a program which finds the surface of the area of the floor, from which each point on the walls of the gallery is visible. On the figure 1. a map of a gallery is given in some co-ordinate system. The area wanted is shaded on the figure 2.<br><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/11/1568195853781-1568195853783.png" alt=""></p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The number of tasks T that your program have to solve will be on the first row of the input file. Input data for each task start with an integer N, 5 &lt;= N &lt;= 1500. Each of the next N rows of the input will contain the co-ordinates of a vertex of the polygon ? two integers that fit in 16-bit integer type, separated by a single space. Following the row with the co-ordinates of the last vertex for the task comes the line with the number of vertices for the next test and so on.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test you must write on one line the required surface - a number with exactly two digits after the decimal point (the number should be rounded to the second digit after the decimal point).   </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">7</span><br><span class="line">0 0</span><br><span class="line">4 4</span><br><span class="line">4 7</span><br><span class="line">9 7</span><br><span class="line">13 -1</span><br><span class="line">8 -6</span><br><span class="line">4 -4</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">80.00</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Southeastern+Europe+2002" target="_blank" rel="noopener">Southeastern Europe 2002</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点的多边形，求多边形的核的面积。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>半平面交</strong></p>
<p>半平面交求多边形的核的模板题。注意给出点的顺序是顺时针的，要处理一下。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>((a.dis() * dis()) / dot(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Point p[maxn], ip[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        Line l = a;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(angle - l.angle) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l.toLeftTest(s) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> angle &lt; l.angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_angle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        angle = <span class="built_in">atan2</span>(e.y - s.y, e.x - s.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		db a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		db a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        db x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        db y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(l[i].angle - l[tmp].angle) == <span class="number">1</span>) l[++tmp] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = tmp;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    q[<span class="number">1</span>] = l[<span class="number">1</span>], q[<span class="number">2</span>] = l[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            --tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[head].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        --tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[tail].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ++head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tail - head + <span class="number">1</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">        ip[++tmp] = q[i].crosspoint(q[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ip[++tmp] = q[head].crosspoint(q[tail]);</span><br><span class="line">    db ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= tmp; ++i) &#123;</span><br><span class="line">        ans += (ip[i - <span class="number">1</span>] - ip[<span class="number">1</span>]).cross(ip[i] - ip[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            l[++cnt].e = p[i];</span><br><span class="line">            l[cnt].s = p[i + <span class="number">1</span>];</span><br><span class="line">            l[cnt].get_angle();</span><br><span class="line">        &#125;</span><br><span class="line">        l[++cnt].e = p[n];</span><br><span class="line">        l[cnt].s = p[<span class="number">1</span>];</span><br><span class="line">        l[cnt].get_angle();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, half_plane(cnt));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1410 Intersection (计算几何)</title>
    <url>/2019/11/11/POJ-1410-Intersection-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1410" target="_blank" rel="noopener">POJ 1410</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>You are to write a program that has to decide whether a given line segment intersects a given rectangle. </p>
<p>An example: </p>
<p>line: start point: (4,9) </p>
<p>end point: (11,2) </p>
<p>rectangle: left-top: (1,5) </p>
<p>right-bottom: (7,1) </p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/11/1573482242971-1573482243153.png" alt=""></p>
<p>Figure 1: Line segment does not intersect rectangle </p>
<p>The line is said to intersect the rectangle if the line and the rectangle have at least one point in common. The rectangle consists of four straight lines and the area in between. Although all input values are integer numbers, valid intersection points do not have to lay on the integer grid. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of n test cases. The first line of the input file contains the number n. Each following line contains one test case of the format: </p>
<p>xstart ystart xend yend xleft ytop xright ybottom </p>
<p>where (xstart, ystart) is the start and (xend, yend) the end point of the line and (xleft, ytop) the top left and (xright, ybottom) the bottom right corner of the rectangle. The eight numbers are separated by a blank. The terms top left and bottom right do not imply any ordering of coordinates. </p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case in the input file, the output file should contain a line consisting either of the letter “T” if the line segment intersects the rectangle or the letter “F” if the line segment does not intersect the rectangle. </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4 9 11 2 1 5 7 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">F</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Southwestern+European+Regional+Contest+1995" target="_blank" rel="noopener">Southwestern European Regional Contest 1995</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个矩形和一条线段，判断线段是否与矩形相交或者在矩形内部。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断线段是否与矩形每条边相交。至于线段是否在矩形内，判断是否线段两个端点在矩形内即可。</p>
<p>计算几何模板来在 kuangbin 的模板。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sgn(x-b.x) == <span class="number">0</span> &amp;&amp; sgn(y-b.y) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//叉积</span></span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.y - y*b.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//点积</span></span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.x + y*b.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//`两线段相交判断`</span></span><br><span class="line">	<span class="comment">//`2 规范相交`</span></span><br><span class="line">	<span class="comment">//`1 非规范相交`</span></span><br><span class="line">	<span class="comment">//`0 不相交`</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">segcrossseg</span><span class="params">(Line v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d1 = sgn((e - s) ^ (v.s - s));</span><br><span class="line">		<span class="keyword">int</span> d2 = sgn((e - s) ^ (v.e - s));</span><br><span class="line">		<span class="keyword">int</span> d3 = sgn((v.e - v.s) ^ (s - v.s));</span><br><span class="line">		<span class="keyword">int</span> d4 = sgn((v.e - v.s) ^ (e - v.s));</span><br><span class="line">		<span class="keyword">if</span>( (d1 ^ d2) == <span class="number">-2</span> &amp;&amp; (d3 ^ d4) == <span class="number">-2</span> ) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> (d1 == <span class="number">0</span> &amp;&amp; sgn((v.s - s)*(v.s - e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">			    (d2 == <span class="number">0</span> &amp;&amp; sgn((v.e - s)*(v.e - e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">			    (d3 == <span class="number">0</span> &amp;&amp; sgn((s - v.s) * (s - v.e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">			    (d4 == <span class="number">0</span> &amp;&amp; sgn((e - v.s) * (e - v.e)) &lt;= <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 点在线段上的判断</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">pointonseg</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sgn((p - s) ^ (e - s)) == <span class="number">0</span> &amp;&amp; sgn((p - s) * (p - e)) &lt;= <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">    Point p[<span class="number">4</span>];</span><br><span class="line">    Line l[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getline</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			l[i] = Line(p[i], p[(i + <span class="number">1</span>) % n]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//`判断点和任意多边形的关系`</span></span><br><span class="line">    <span class="comment">//` 3 点上`</span></span><br><span class="line">    <span class="comment">//` 2 边上`</span></span><br><span class="line">    <span class="comment">//` 1 内部`</span></span><br><span class="line">    <span class="comment">//` 0 外部`</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationpoint</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i] == q) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getline();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i].pointonseg(q)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (i + <span class="number">1</span>) % n;</span><br><span class="line">            <span class="keyword">int</span> k = sgn((q - p[j])^(p[i] - p[j]));</span><br><span class="line">            <span class="keyword">int</span> u = sgn(p[i].y - q.y);</span><br><span class="line">            <span class="keyword">int</span> v = sgn(p[j].y - q.y);</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; u &lt; <span class="number">0</span> &amp;&amp; v &gt;= <span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span> &amp;&amp; v &lt; <span class="number">0</span> &amp;&amp; u &gt;= <span class="number">0</span>) cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Point a, b;</span><br><span class="line">        a.input(), b.input();</span><br><span class="line">        Line l = Line(a, b);</span><br><span class="line">        Rec rec;</span><br><span class="line">        a.input(), b.input();</span><br><span class="line">        rec.p[<span class="number">0</span>] = Point(min(a.x, b.x), min(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">1</span>] = Point(max(a.x, b.x), min(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">2</span>] = Point(max(a.x, b.x), max(a.y, b.y));</span><br><span class="line">        rec.p[<span class="number">3</span>] = Point(min(a.x, b.x), max(a.y, b.y));</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">0</span>], rec.p[<span class="number">1</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">1</span>], rec.p[<span class="number">2</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">2</span>], rec.p[<span class="number">3</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l.segcrossseg(Line(rec.p[<span class="number">3</span>], rec.p[<span class="number">0</span>]))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rec.relationpoint(l.s) || rec.relationpoint(l.e)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1679 The Unique MST (次小生成树)</title>
    <url>/2019/10/14/POJ-1679-The-Unique-MST-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1679" target="_blank" rel="noopener">POJ 1679</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Given a connected undirected graph, tell if its minimum spanning tree is unique.</p>
<p>Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties:</p>
<ol>
<li>V’ = V.</li>
<li>T is connected and acyclic.</li>
</ol>
<p>Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">3 1 3</span><br><span class="line">4 4</span><br><span class="line">1 2 2</span><br><span class="line">2 3 2</span><br><span class="line">3 4 2</span><br><span class="line">4 1 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Not Unique!</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Monthly--2004.06.27+srbga%40POJ" target="_blank" rel="noopener">POJ Monthly—2004.06.27 srbga@POJ</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个连通的无向图 (没有重边)，求最小生成树是否唯一。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>Kruskal</strong></p>
<p>求出次小生成树，如果次小生成树的边权和与最小生成树的边权和相等，则最小生成树不唯一。</p>
<p>次小生成树的求法有很多，这里给出其中一种。</p>
<p>次小生成树与最小生成树仅有一条边不同。先用 Kruskal 求出最小生成树，然后枚举最小生成树的每一条边，求删去该边后的最小生成树，所有情况中的最小的生成树就是次小生成树。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mst[M];  <span class="comment">// 最小生成树所有边的下标</span></span><br><span class="line"><span class="keyword">int</span> mst_size;  <span class="comment">// 最小生成树的边权和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    mst_size = <span class="number">0</span>;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(edge[i].x);</span><br><span class="line">        <span class="keyword">int</span> y = get(edge[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">            ans += edge[i].z;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            mst[++mst_size] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sec_mst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mst_size; ++i) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j != mst[i]) &#123;  <span class="comment">// 删去最小生成树中的一条边</span></span><br><span class="line">                <span class="keyword">int</span> x = get(edge[j].x);</span><br><span class="line">                <span class="keyword">int</span> y = get(edge[j].y);</span><br><span class="line">                <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">                    sum += edge[j].z;</span><br><span class="line">                    fa[x] = y;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt != mst_size) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp1 = kruskal();</span><br><span class="line">        <span class="keyword">int</span> tmp2 = sec_mst();</span><br><span class="line">        <span class="keyword">if</span>(tmp1 == tmp2) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1753 Flip Game (DFS)</title>
    <url>/2019/08/14/POJ-1753-Flip-Game-DFS/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1753" target="_blank" rel="noopener">POJ 1753</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules: </p>
<p>Choose any one of the 16 pieces. </p>
<p>Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</p>
<p>Consider the following position as an example: </p>
<p>bwbw</p>
<p>wwww </p>
<p>bbwb</p>
<p>bwwb</p>
<p>Here “b” denotes pieces lying their black side up and “w” denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become: </p>
<p>bwbw</p>
<p>bwww</p>
<p>wwwb</p>
<p>wwwb </p>
<p>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal. </p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/14/1565786207845-1565786207847.png" alt=""></p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of 4 lines with 4 characters “w” or “b” each that denote game field position.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Write to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it’s impossible to achieve the goal, then write the word “Impossible” (without quotes).</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">bwwb</span><br><span class="line">bbwb</span><br><span class="line">bwwb</span><br><span class="line">bwww</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定 4 * 4 的正方形，每个格子要么是黑色，要么是白色，可以改变任意的格子的颜色，其上下左右的格子也会改变，问至少改变几个格子可以使正方形变为全黑或者全白。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>DFS</strong></p>
<ol>
<li>每个格子要么不翻，要么翻 1 次。（翻奇数次和翻 1 次效果相同，翻偶数次和不翻效果一样）</li>
<li>可以选择翻转 0 个、1 个、2 个、3 个 … 16 个</li>
<li>每次翻完后判断是否为纯色，如果为纯色就输出相应的格子个数，如果 16 个翻转了还不是纯色，就输出“impossible”。</li>
</ol>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> mp[<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">//存储棋子</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">//判断是否成功</span></span><br><span class="line"><span class="keyword">int</span> step; <span class="comment">//步数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前状态是否全是白在上或是黑在上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j] != mp[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转棋子，同时翻转四周相邻的棋子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    mp[x][y] =! mp[x][y];</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= <span class="number">2</span>) mp[x][y + <span class="number">1</span>] =! mp[x][y + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(y != <span class="number">0</span>) mp[x][y - <span class="number">1</span>] =! mp[x][y - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">2</span>) mp[x + <span class="number">1</span>][y] =! mp[x + <span class="number">1</span>][y];</span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">0</span>) mp[x - <span class="number">1</span>][y] =! mp[x - <span class="number">1</span>][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 搜索深度与步数相同时就回溯</span></span><br><span class="line">    <span class="keyword">if</span>(step == dep) &#123;</span><br><span class="line">        <span class="keyword">if</span>(judge()) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经满足条件就可以返回</span></span><br><span class="line">    <span class="keyword">if</span>(flag || x == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//翻转棋子</span></span><br><span class="line">    flip(x, y);</span><br><span class="line">    <span class="comment">//进行下一状态的搜索</span></span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">3</span>) dfs(x, y + <span class="number">1</span>, dep + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> dfs(x + <span class="number">1</span>, <span class="number">0</span>, dep + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将该棋子再翻回，即当前棋子不翻</span></span><br><span class="line">    flip(x, y);</span><br><span class="line">    <span class="comment">//进行下一状态的搜索</span></span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">3</span>) dfs(x, y + <span class="number">1</span>, dep);</span><br><span class="line">    <span class="keyword">else</span> dfs(x + <span class="number">1</span>, <span class="number">0</span>, dep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="literal">false</span>; <span class="comment">//初始化flag为false</span></span><br><span class="line">    <span class="comment">//初始化棋盘每个位置为false</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            mp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'b'</span>) mp[i][j] = <span class="literal">true</span>; <span class="comment">//设定b为true</span></span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对0-16的每个步长进行搜索</span></span><br><span class="line">    <span class="keyword">for</span>(step = <span class="number">0</span>; step &lt;= <span class="number">16</span>; step++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>; <span class="comment">//如果成功了，该步长就是最小值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功就输出步长，失败就输出impossible</span></span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, step);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1797 Heavy Transportation (Dijkstra)</title>
    <url>/2019/10/12/POJ-1797-Heavy-Transportation-Dijkstra/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener">POJ 1797</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Background</p>
<p>Hugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight.</p>
<p>Fortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know.</p>
<p>Problem</p>
<p>You are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo’s place) to crossing n (the customer’s place). You may assume that there is at least one path. All streets can be travelled in both directions.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=TUD+Programming+Contest+2004" target="_blank" rel="noopener">TUD Programming Contest 2004, Darmstadt, Germany</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 N 个城市，M 条道路，Hugo Heavy 要从城市 1 到城市 N 运输货物，每条道路都有它的最大载重量，求从城市 1 到城市 N 运送最多的重量是多少。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>Dijkstra</strong></p>
<p>与 <a href="https://wutao18.github.io/2019/10/11/POJ-2253-Frogger/">POJ 2253 Frogger</a> 类似，修改一下 $Dijkstra$ 的松弛方程：$if d[v] &lt; min(d[u], w[u][v]) then d[v] = min(d[u], w[u][v])$。注意 $d$ 数组初始化成无穷大。</p>
<p>这题有点坑，输出两个换行。</p>
<p>此题还可以用最大生成树解决。<a href="https://wutao18.github.io/2019/10/12/POJ-1797-Heavy-Transportation-%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91/">戳这里</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> w): to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> d[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    G[x].push_back(Edge(y, z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q;</span></span><br><span class="line">    priority_queue&lt;P&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    d[s] = inf;</span><br><span class="line">    q.push(P(inf, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        P p = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge e = G[x][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &lt; min(d[x], e.w)) &#123;</span><br><span class="line">                d[e.to] = min(d[x], e.w);</span><br><span class="line">                q.push(P(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp; y, &amp;z);</span><br><span class="line">            add(x, y, z);</span><br><span class="line">            add(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(kase) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>, ++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1474 Video Surveillance (半平面交)</title>
    <url>/2019/09/14/POJ-1474-Video-Surveillance-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1474" target="_blank" rel="noopener">POJ 1474</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>A friend of yours has taken the job of security officer at the Star-Buy Company, a famous depart- ment store. One of his tasks is to install a video surveillance system to guarantee the security of the customers (and the security of the merchandise of course) on all of the store’s countless floors. As the company has only a limited budget, there will be only one camera on every floor. But these cameras may turn around to look in every direction.</p>
<p>The first problem is to choose where to install the camera for every floor. The only requirement is that every part of the room must be visible from there. In the following figure the left floor can be completely surveyed from the position indicated by a dot, while for the right floor, there is no such position, the given position failing to see the lower left part of the floor.</p>
<p>Before trying to install the cameras, your friend first wants to know whether there is indeed a suitable position for them. He therefore asks you to write a program that, given a ground plan, de- termines whether there is a position from which the whole floor is visible. All floor ground plans form rectangular polygons, whose edges do not intersect each other and touch each other only at the corners.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains several floor descriptions. Every description starts with the number $n$ of vertices that bound the floor $(4 \le n \le 100)$. The next $n$ lines contain two integers each, the $x$ and $y$ coordinates for the $n$ vertices, given in clockwise order. All vertices will be distinct and at corners of the polygon. Thus the edges alternate between horizontal and vertical.</p>
<p>A zero value for $n$ indicates the end of the input.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For every test case first output a line with the number of the floor, as shown in the sample output. Then print a line stating “Surveillance is possible.” if there exists a position from which the entire floor can be observed, or print “Surveillance is impossible.” if there is no such position.</p>
<p>Print a blank line after each test case.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">1 0</span><br><span class="line">8</span><br><span class="line">0 0</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br><span class="line">3 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Floor #1</span><br><span class="line">Surveillance is possible.</span><br><span class="line"></span><br><span class="line">Floor #2</span><br><span class="line">Surveillance is impossible.</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Southwestern+European+Regional+Contest+1997" target="_blank" rel="noopener">Southwestern European Regional Contest 1997</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>要在房间内安装一个可以 360° 旋转的监控，问是否存在一个位置使得监控能看到整个房间。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>半平面交</strong></p>
<p>半平面交求多边形是否有核。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Point p[maxn], ip[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        Line l = a;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(angle - l.angle) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l.toLeftTest(s) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> angle &lt; l.angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_angle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        angle = <span class="built_in">atan2</span>(e.y - s.y, e.x - s.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		db a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		db a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        db x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        db y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(l[i].angle - l[tmp].angle) == <span class="number">1</span>) l[++tmp] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = tmp;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    q[<span class="number">1</span>] = l[<span class="number">1</span>], q[<span class="number">2</span>] = l[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            --tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[head].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        --tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[tail].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ++head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail - head + <span class="number">1</span> &gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> _ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Floor #%d\n"</span>, ++_);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        db s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            l[++cnt].e = p[i];</span><br><span class="line">            l[cnt].s = p[i + <span class="number">1</span>];</span><br><span class="line">            l[cnt].get_angle();</span><br><span class="line">        &#125;</span><br><span class="line">        l[++cnt].e = p[n];</span><br><span class="line">        l[cnt].s = p[<span class="number">1</span>];</span><br><span class="line">        l[cnt].get_angle();</span><br><span class="line">        <span class="keyword">if</span>(half_plane(cnt) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Surveillance is impossible.\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Surveillance is possible.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1789 Truck History (Kruskal)</title>
    <url>/2019/10/15/POJ-1789-Truck-History-Kruskal/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1789" target="_blank" rel="noopener">POJ 1789</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Advanced Cargo Movement, Ltd. uses trucks of different types. Some trucks are used for vegetable delivery, other for furniture, or for bricks. The company has its own code describing each type of a truck. The code is simply a string of exactly seven lowercase letters (each letter on each position has a very special meaning but that is unimportant for this task). At the beginning of company’s history, just a single truck type was used but later other types were derived from it, then from the new types another types were derived, and so on.</p>
<p>Today, ACM is rich enough to pay historians to study its history. One thing historians tried to find out is so called derivation plan — i.e. how the truck types were derived. They defined the distance of truck types as the number of positions with different letters in truck type codes. They also assumed that each truck type was derived from exactly one other truck type (except for the first truck type which was not derived from any other type). The quality of a derivation plan was then defined as</p>
<p>$1/Σ_{(t_o,t_d)}d(t_o,t_d)$</p>
<p>where the sum goes over all pairs of types in the derivation plan such that $t_o$ is the original type and $t_d$ the type derived from it and d($t_o$,$t_d$) is the distance of the types.<br>Since historians failed, you are to write a program to help them. Given the codes of truck types, your program should find the highest possible quality of a derivation plan.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of several test cases. Each test case begins with a line containing the number of truck types, N, 2 &lt;= N &lt;= 2 000. Each of the following N lines of input contains one truck type code (a string of seven lowercase letters). You may assume that the codes uniquely describe the trucks, i.e., no two of these N lines are the same. The input is terminated with zero at the place of number of truck types.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, your program should output the text “The highest possible quality is 1/Q.”, where 1/Q is the quality of the best derivation plan.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">aaaaaaa</span><br><span class="line">baaaaaa</span><br><span class="line">abaaaaa</span><br><span class="line">aabaaaa</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">The highest possible quality is 1/3.</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=CTU+Open+2003" target="_blank" rel="noopener">CTU Open 2003</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>用一个 $7$ 位的字符串代表一个编号，两个编号之间的距离等于这两个编号之间不同字母的个数。</p>
<p>给定 $n$ 个编号，求连接所有编号的最短距离。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>Kruskal</strong></p>
<p>把每个字符串看成结点，用无向边连接任意两个结点，边权为两个字符串之间的距离，对构成的无向图求最小生成树就是答案。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, M = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(edge[i].x);</span><br><span class="line">        <span class="keyword">int</span> y = get(edge[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">            ans += edge[i].z;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[x][i] != str[y][i]) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                edge[++m].x = i;</span><br><span class="line">                edge[m].y = j;</span><br><span class="line">                edge[m].z = dis(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kruskal();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The highest possible quality is 1/%d.\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1860 Currency Exchange (Bellman-Ford)</title>
    <url>/2019/11/09/POJ-1860-Currency-Exchange-Bellman-Ford/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1860" target="_blank" rel="noopener">POJ 1860</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Several currency exchange points are working in our city. Let us suppose that each point specializes in two particular currencies and performs exchange operations only with these currencies. There can be several points specializing in the same pair of currencies. Each point has its own exchange rates, exchange rate of A to B is the quantity of B you get for 1A. Also each exchange point has some commission, the sum you have to pay for your exchange operation. Commission is always collected in source currency.</p>
<p>For example, if you want to exchange 100 US Dollars into Russian Rubles at the exchange point, where the exchange rate is 29.75, and the commission is 0.39 you will get (100 - 0.39) * 29.75 = 2963.3975RUR.</p>
<p>You surely know that there are N different currencies you can deal with in our city. Let us assign unique integer number from 1 to N to each currency. Then each exchange point can be described with 6 numbers: integer A and B - numbers of currencies it exchanges, and real RAB, CAB, RBA and CBA - exchange rates and commissions when exchanging A to B and B to A respectively.</p>
<p>Nick has some money in currency S and wonders if he can somehow, after some exchange operations, increase his capital. Of course, he wants to have his money in currency S in the end. Help him to answer this difficult question. Nick must always have non-negative sum of money while making his operations.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of the input contains four numbers: N - the number of currencies, M - the number of exchange points, S - the number of currency Nick has and V - the quantity of currency units he has. The following M lines contain 6 numbers each - the description of the corresponding exchange point - in specified above order. Numbers are separated by one or more spaces. 1&lt;=S&lt;=N&lt;=100, 1&lt;=M&lt;=100, V is real number, 0&lt;=V&lt;=103.</p>
<p>For each point exchange rates and commissions are real, given with at most two digits after the decimal point, 10-2&lt;=rate&lt;=102, 0&lt;=commission&lt;=102.</p>
<p>Let us call some sequence of the exchange operations simple if no exchange point is used more than once in this sequence. You may assume that ratio of the numeric values of the sums at the end and at the beginning of any simple sequence of the exchange operations will be less than 104.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>If Nick can increase his wealth, output YES, in other case output NO to the output file.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 2 1 20.0</span><br><span class="line">1 2 1.00 1.00 1.00 1.00</span><br><span class="line">2 3 1.10 1.00 1.10 1.00</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2001" target="_blank" rel="noopener">Northeastern Europe 2001, Northern Subregion</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 种货币，给出一些两种货币之间的汇率及税价。</p>
<p>求原来持有的货币能否通过一些兑换过程使得价值增加。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把货币看成结点，兑换的过程看成有向边，那么其实问题就是判断图中是否存在正环。</p>
<p>使用 $Bellman-Ford$ 算法，与判断负环的方法类似，改变一下松弛的条件即可。注意初始化也需要修改。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">double</span> v;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">double</span> dis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="keyword">double</span> r, c;</span><br><span class="line">    Edge(<span class="keyword">int</span> f = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>, <span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> c = <span class="number">0</span>): from(f), to(t), r(r), c(c) &#123;&#125;</span><br><span class="line">&#125; edges[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">double</span> r, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    edges[tot++] = Edge(f, t, r, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = edges[j].from, t = edges[j].to;</span><br><span class="line">            <span class="keyword">double</span> r = edges[j].r, c = edges[j].c;</span><br><span class="line">            <span class="keyword">double</span> tmp = (dis[f] - c) * r;</span><br><span class="line">            <span class="keyword">if</span>(dis[t] &lt; tmp) &#123;</span><br><span class="line">                dis[t] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[edges[i].to] &lt; (dis[edges[i].from] - edges[i].c) * edges[i].r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf"</span>, &amp;n, &amp;m, &amp;s, &amp;v)) &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f, t;</span><br><span class="line">        <span class="keyword">double</span> r1, c1, r2, c2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf%lf%lf"</span>, &amp;f, &amp;t, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">            add(f, t, r1, c1);</span><br><span class="line">            add(t, f, r2, c2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Bellman_Ford()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Bellman-Ford</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1797 Heavy Transportation (最大生成树)</title>
    <url>/2019/10/12/POJ-1797-Heavy-Transportation-%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener">POJ 1797</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Background</p>
<p>Hugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight.</p>
<p>Fortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know.</p>
<p>Problem</p>
<p>You are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo’s place) to crossing n (the customer’s place). You may assume that there is at least one path. All streets can be travelled in both directions.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=TUD+Programming+Contest+2004" target="_blank" rel="noopener">TUD Programming Contest 2004, Darmstadt, Germany</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 N 个城市，M 条道路，Hugo Heavy 要从城市 1 到城市 N 运输货物，每条道路都有它的最大载重量，求从城市 1 到城市 N 运送最多的重量是多少。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>最大生成树</strong></p>
<p>题目要求点 1 到 N 的所有路径的所有边权的最小值中的最大值。维护一个最大生成树，不断将最大权值的边加入，如果遇到点 N 就结束。</p>
<p>这题有点坑，输出两个换行。</p>
<p>此题还可以用 $Dijkstra$ 解决。<a href="https://wutao18.github.io/2019/10/12/POJ-1797-Heavy-Transportation-Dijkstra/">戳这里</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Prim</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> w): to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> d[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    ans = inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    G[x].push_back(Edge(y, z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;P&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    d[s] = inf;</span><br><span class="line">    q.push(P(inf, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        P p = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        ans = min(ans, p.first);</span><br><span class="line">        <span class="keyword">if</span>(x == n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge e = G[x][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &lt; e.w &amp;&amp; !v[e.to]) &#123;</span><br><span class="line">                d[e.to] = e.w;</span><br><span class="line">                q.push(P(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp; y, &amp;z);</span><br><span class="line">            add(x, y, z);</span><br><span class="line">            add(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">        prim(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(kase) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>, ++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kruskal</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &gt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(edge[i].x);</span><br><span class="line">        <span class="keyword">int</span> y = get(edge[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">            ans = min(ans, edge[i].z);</span><br><span class="line">            fa[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        x = get(<span class="number">1</span>);</span><br><span class="line">        y = get(n);</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        kruskal();</span><br><span class="line">        <span class="keyword">if</span>(kase) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>, ++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>最小生成树</tag>
        <tag>Prim</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1873 UVA 811 The Fortified Forest (凸包 + 状态压缩枚举)</title>
    <url>/2019/08/18/POJ-1873-UVA-811-The-Fortified-Forest-%E5%87%B8%E5%8C%85-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=752" target="_blank" rel="noopener">UVA 811</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Once upon a time, in a faraway land, there lived a king. This king owned a small collection of rare and valuable trees, which had been gathered by his ancestors on their travels. To protect his trees from thieves, the king ordered that a high fence be built around them. His wizard was put in charge of the operation. </p>
<p>Alas, the wizard quickly noticed that the only suitable material available to build the fence was the wood from the trees themselves. In other words, it was necessary to cut down some trees in order to build a fence around the remaining trees. Of course, to prevent his head from being chopped off, the wizard wanted to minimize the value of the trees that had to be cut. The wizard went to his tower and stayed there until he had found the best possible solution to the problem. The fence was then built and everyone lived happily ever after. </p>
<p>You are to write a program that solves the problem the wizard faced. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains several test cases, each of which describes a hypothetical forest. Each test case begins with a line containing a single integer $n$, $2\le n\le 15$, the number of trees in the forest. The trees are identied by consecutive integers $1$ to $n$. Each of the subsequent lines contains $4$ integers $x_i,y_i,v_i,l_i$ that describe a single tree. $(x_i,y_i)$ is the position of the tree in the plane, $v_i$ is its value, and $l_i$ is the length of fence that can be built using the wood of the tree. $vi$ and $li$ are between $0$ and $10,000$.</p>
<p>The input ends with an empty test case (n= 0).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, compute a subset of the trees such that, using the wood from that subset, the remaining trees can be enclosed in a single fence. Find the subset with minimum value. If more than one such minimum-value subset exists, choose one with the smallest number of trees. For simplicity, regard the trees as having zero diameter. </p>
<p>Display, as shown below, the test case numbers (1, 2, …), the identity of each tree to be cut, and the length of the excess fencing (accurate to two fractional digits). </p>
<p>Display a blank line between test cases. </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line"> 0  0  8  3</span><br><span class="line"> 1  4  3  2</span><br><span class="line"> 2  1  7  1</span><br><span class="line"> 4  1  2  3</span><br><span class="line"> 3  5  4  6</span><br><span class="line"> 2  3  9  8</span><br><span class="line">3</span><br><span class="line"> 3  0 10  2</span><br><span class="line"> 5  5 20 25</span><br><span class="line"> 7 -3 30 32</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Forest 1</span><br><span class="line">Cut these trees: 2 4 5 </span><br><span class="line">Extra wood: 3.16</span><br><span class="line"></span><br><span class="line">Forest 2</span><br><span class="line">Cut these trees: 2 </span><br><span class="line">Extra wood: 15.00</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 颗树，每颗树的坐标为 $x, y$ ，价值为 $v_i$ 长度为 $l_i$。现在要用篱笆将其中一些树围起来，但篱笆制作来源于这些树，即要求砍掉的树能构成篱笆的长度 $&gt;=$ 剩余树的凸包周长。现在要使得砍掉树的价值之和最小，问需要砍掉哪些树(如果有价值相同的解，就输出砍的树最少的解)。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>凸包周长 状态压缩枚举</strong></p>
<p>树的规模比较小，用二进制枚举所有情况即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> v, l;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> a, <span class="keyword">double</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; b.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; b.x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == b.x &amp;&amp; y == b.y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[maxn], stk[maxn], tmp[maxn];</span><br><span class="line"><span class="keyword">typedef</span> Point Vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vec a, Vec b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Andrew</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + <span class="number">1</span> + l);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; tmp[i] == tmp[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 会有重复的点, WA了好几次</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], tmp[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; tmp[i] == tmp[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; k &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], tmp[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> &amp;min_val, <span class="keyword">int</span> &amp;cur_num, <span class="keyword">double</span> &amp;re_len, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> bit = <span class="number">0</span>; bit &lt; size; ++bit) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>, cur_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> cur_len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bit &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                cur_len += p[i].l;</span><br><span class="line">                cur_val += p[i].v;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[++t] = p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_val &gt; min_val) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = Andrew(t);</span><br><span class="line">        <span class="keyword">double</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            c += dist(stk[i], stk[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur_len &gt;= c) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur_val &lt; min_val || (cur_val == min_val &amp;&amp;  n - t &lt; cur_num)) &#123;</span><br><span class="line">                min_val = cur_val;</span><br><span class="line">                cur_num = n - t;</span><br><span class="line">                re_len = cur_len - c;</span><br><span class="line">                ans = bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(kase) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%d%d"</span>, &amp;p[i].x, &amp;p[i].y, &amp;p[i].v, &amp;p[i].l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_val = inf;</span><br><span class="line">        <span class="keyword">int</span> cur_num = inf;</span><br><span class="line">        <span class="keyword">double</span> re_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        solve(min_val, cur_num, re_len, ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Forest %d\n"</span>, ++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cut these trees:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nExtra wood: %.2lf\n"</span>, re_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>枚举</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2001 Shortest Prefixes (Trie)</title>
    <url>/2019/10/03/POJ-2001-Shortest-Prefixes-Trie/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2001" target="_blank" rel="noopener">POJ 2001</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>A prefix of a string is a substring starting at the beginning of the given string. The prefixes of “carbon” are: “c”, “ca”, “car”, “carb”, “carbo”, and “carbon”. Note that the empty string is not considered a prefix in this problem, but every non-empty string is considered to be a prefix of itself. In everyday language, we tend to abbreviate words by prefixes. For example, “carbohydrate” is commonly abbreviated by “carb”. In this problem, given a set of words, you will find for each word the shortest prefix that uniquely identifies the word it represents.</p>
<p>In the sample input below, “carbohydrate” can be abbreviated to “carboh”, but it cannot be abbreviated to “carbo” (or anything shorter) because there are other words in the list that begin with “carbo”.</p>
<p>An exact match will override a prefix match. For example, the prefix “car” matches the given word “car” exactly. Therefore, it is understood without ambiguity that “car” is an abbreviation for “car” , not for “carriage” or any of the other words in the list that begins with “car”.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input contains at least two, but no more than 1000 lines. Each line contains one word consisting of 1 to 20 lower case letters.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The output contains the same number of lines as the input. Each line of the output contains the word from the corresponding line of the input, followed by one blank space, and the shortest prefix that uniquely (without ambiguity) identifies this word.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">carbohydrate</span><br><span class="line">cart</span><br><span class="line">carburetor</span><br><span class="line">caramel</span><br><span class="line">caribou</span><br><span class="line">carbonic</span><br><span class="line">cartilage</span><br><span class="line">carbon</span><br><span class="line">carriage</span><br><span class="line">carton</span><br><span class="line">car</span><br><span class="line">carbonate</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">carbohydrate carboh</span><br><span class="line">cart cart</span><br><span class="line">carburetor carbu</span><br><span class="line">caramel cara</span><br><span class="line">caribou cari</span><br><span class="line">carbonic carboni</span><br><span class="line">cartilage carti</span><br><span class="line">carbon carbon</span><br><span class="line">carriage carr</span><br><span class="line">carton carto</span><br><span class="line">car car</span><br><span class="line">carbonate carbona</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Rocky+Mountain+2004" target="_blank" rel="noopener">Rocky Mountain 2004</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出若干个由小写字母组成的单词，对每个单词找出最短的前缀，使得该前缀不是其他任何字符串的前缀。</p>
<p>如果整个单词都是其他单词的前缀就输出整个单词。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>Trie</strong></p>
<p>标记每个结点结束的前缀是多少个单词的前缀，查找时只要找到某个唯一的前缀就输出。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> val[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = index(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (!nxt[p][c]) &#123;</span><br><span class="line">            nxt[p][c] = tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = nxt[p][c];</span><br><span class="line">        ++val[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = index(s[i]);</span><br><span class="line">        p = nxt[p][c];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">        <span class="keyword">if</span>(val[p] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s[n]) &#123;</span><br><span class="line">        insert(s[n]);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        query(s[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>Trie/字典树/前缀树</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1995 Raising Modulo Numbers (快速幂)</title>
    <url>/2019/08/06/POJ-1995-Raising-Modulo-Numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1995" target="_blank" rel="noopener">POJ 1995</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>People are different. Some secretly read magazines full of interesting girls’ pictures, others create an A-bomb in their cellar, others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow: </p>
<p>Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions AiBi from all players including oneself and determine the remainder after division by a given number M. The winner is the one who first determines the correct result. According to the players’ experience it is possible to increase the difficulty by choosing higher numbers. </p>
<p>You should write a program that calculates the result and is able to find out who won the game. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input. Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number. Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line, there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each assingnement there is the only one line of output. On this line, there is a number, the result of expression </p>
<p>$(A_1 ^ {B_1} + A_2 ^ {B_2} + … + A_H ^ {B_H}) mod M$</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">16</span><br><span class="line">4</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">36123</span><br><span class="line">1</span><br><span class="line">2374859 3029382</span><br><span class="line">17</span><br><span class="line">1</span><br><span class="line">3 18132</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">13195</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出 $Z$ 组数据，每组数据包含 $H$ 个 $A$ 和 $H$ 个 $B$，求 $(A_1 ^ {B_1} + A_2 ^ {B_2} + … + A_H ^ {B_H}) mod M$。 </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>快速幂模板题</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (a * ans) % m;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll m;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;m, &amp;h);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; ++i) &#123;</span><br><span class="line">            ll a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">            ans += qmod(a, b, m);</span><br><span class="line">            ans %= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2187 Beauty Contest (凸包 旋转卡壳)</title>
    <url>/2019/08/20/POJ-2187-Beauty-Contest-%E5%87%B8%E5%8C%85-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2187" target="_blank" rel="noopener">POJ 2187</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Bessie, Farmer John’s prize cow, has just won first place in a bovine beauty contest, earning the title ‘Miss Cow World’. As a result, Bessie will make a tour of N (2 &lt;= N &lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane, where each farm is located at a pair of integer coordinates (x,y), each having a value in the range -10,000 … 10,000. No two farms share the same pair of coordinates. </p>
<p>Even though Bessie travels directly in a straight line between pairs of farms, the distance between some farms can be quite large, so she wants to bring a suitcase full of hay with her so she has enough food to eat on each leg of her journey. Since Bessie refills her suitcase at every farm she visits, she wants to determine the maximum possible distance she might need to travel so she knows the size of suitcase she must bring.Help Bessie by computing the maximum distance among all pairs of farms. </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>$*$ Line 1: A single integer, N </p>
<p>$*$ Lines 2..N+1: Two space-separated integers x and y specifying coordinate of each farm</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>$*$ Line 1: A single integer that is the squared distance between the pair of farms that are farthest apart from each other. </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>Farm 1 (0, 0) and farm 3 (1, 1) have the longest distance (square root of 2) </p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点的坐标，求这些点构成的凸包的直径的平方。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>凸包 旋转卡壳</strong></p>
<p>旋转卡壳求凸包直径的模板题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x &amp;&amp; y == a.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叉积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 p2 是否在向量 p0p1 的顺时针方向</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (cross(a, b) &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点a 点b的距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="comment">// 凸包</span></span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span> </span>&#123;</span><br><span class="line">    Polygon u, l;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; s.size() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = u.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(u[n - <span class="number">2</span>], u[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(l[n - <span class="number">2</span>], l[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点 x到直线 ab 的距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Point a, Point b, Point x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(dot((a - x), (b - x)) / getDistance(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转卡壳求凸包直径</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rotating_caliper</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> max_dis = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = v.size();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> getDistance(v[<span class="number">0</span>], v[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    v.push_back(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (dis(v[i], v[i + <span class="number">1</span>], v[j]) &lt; dis(v[i], v[i + <span class="number">1</span>], v[j + <span class="number">1</span>])) &#123;</span><br><span class="line">            j = (j + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        max_dis = max(max_dis, max(getDistance(v[j], v[i]), getDistance(v[j], v[i + <span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> max_dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    Polygon s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point p;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        s.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Polygon p = Andrew(s);</span><br><span class="line">    <span class="keyword">double</span> d = rotating_caliper(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2251 Dungeon Master (BFS)</title>
    <url>/2019/08/14/POJ-2251-Dungeon-Master-BFS/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2251" target="_blank" rel="noopener">POJ 2251</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. </p>
<p>Is an escape possible? If yes, how long will it take?  </p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers $L$, $R$ and $C$ (all limited to $30$ in size). </p>
<p>$L$$ is the number of levels making up the dungeon. </p>
<p>$R$ and $C$ are the number of rows and columns making up the plan of each level. </p>
<p>Then there will follow $L$ blocks of $R$ lines each containing $C$ characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘$#$’ and empty cells are represented by a ‘$.$’. Your starting position is indicated by ‘$S$’ and the exit by the letter ‘$E$’. There’s a single blank line after each level. Input is terminated by three zeroes for $L$, $R$ and $C$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Each maze generates one line of output. If it is possible to reach the exit, print a line of the form</p>
<p>Escaped in x minute(s).</p>
<p>where x is replaced by the shortest time it takes to escape. </p>
<p>If it is not possible to escape, print the line </p>
<p>Trapped!</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line"><span class="section">###.#</span></span><br><span class="line"></span><br><span class="line"><span class="section">#####</span></span><br><span class="line"><span class="section">#####</span></span><br><span class="line"><span class="section">##.##</span></span><br><span class="line"><span class="section">##...</span></span><br><span class="line"></span><br><span class="line"><span class="section">#####</span></span><br><span class="line"><span class="section">#####</span></span><br><span class="line"><span class="section">#.###</span></span><br><span class="line"><span class="section">####E</span></span><br><span class="line"></span><br><span class="line">1 3 3</span><br><span class="line">S##</span><br><span class="line"><span class="section">#E#</span></span><br><span class="line"><span class="section">###</span></span><br><span class="line"></span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Escaped in 11 minute(s).</span><br><span class="line">Trapped!</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>给定三维的迷宫，求 S 到 E 的最近距离</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>BFS</strong></p>
<p>三维迷宫的 $BFS$，与二维迷宫的 $BFS$ 类似，每次往 $6$ 个方向搜索，第一次到达 $E$ 点的距离就是最短距离。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r, n, m;</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;  <span class="comment">// 坐标</span></span><br><span class="line">    <span class="keyword">int</span> t;  <span class="comment">// 时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node Begin, End;  <span class="comment">// 起点和终点</span></span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; que;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    que.push(Begin);  <span class="comment">// 加入起点</span></span><br><span class="line">    vis[Begin.x][Begin.y][Begin.z] = <span class="number">1</span>;  <span class="comment">// 起点已访问</span></span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        <span class="comment">// 取出队首</span></span><br><span class="line">        node front = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="comment">// 判断是否到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (front.x == End.x &amp;&amp; front.y == End.y &amp;&amp; front.z == End.z) &#123;</span><br><span class="line">            <span class="keyword">return</span> front.t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索六个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            node tmp;</span><br><span class="line">            tmp.x = front.x + dx[i];</span><br><span class="line">            tmp.y = front.y + dy[i];</span><br><span class="line">            tmp.z = front.z + dz[i];</span><br><span class="line">            tmp.t = front.t + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp.x &gt;= <span class="number">0</span> &amp;&amp; tmp.x &lt; r &amp;&amp; tmp.y &gt;= <span class="number">0</span> &amp;&amp; tmp.y &lt; n &amp;&amp; tmp.z &gt;= <span class="number">0</span> &amp;&amp; tmp.z &lt; m &amp;&amp; !vis[tmp.x][tmp.y][tmp.z] &amp;&amp; s[tmp.x][tmp.y][tmp.z] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                que.push(tmp);</span><br><span class="line">                vis[tmp.x][tmp.y][tmp.z] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 无法到达</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s[i][j];</span><br><span class="line">                <span class="comment">// 寻找起点和终点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i][j][k] == <span class="string">'S'</span>) &#123;</span><br><span class="line">                        Begin.x = i;</span><br><span class="line">                        Begin.y = j;</span><br><span class="line">                        Begin.z = k;</span><br><span class="line">                        Begin.t = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j][k] == <span class="string">'E'</span>) &#123;</span><br><span class="line">                        End.x = i;</span><br><span class="line">                        End.y = j;</span><br><span class="line">                        End.z = k;</span><br><span class="line">                        End.t = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = bfs(); <span class="comment">// 搜索</span></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Trapped!\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2253 Frogger</title>
    <url>/2019/10/11/POJ-2253-Frogger/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener">POJ 2253</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.</p>
<p>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.</p>
<p>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.</p>
<p>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.</p>
<p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">17 4</span><br><span class="line">19 4</span><br><span class="line">18 5</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Scenario #1</span><br><span class="line">Frog Distance = 5.000</span><br><span class="line"></span><br><span class="line">Scenario #2</span><br><span class="line">Frog Distance = 1.414</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Ulm+Local+1997" target="_blank" rel="noopener">Ulm Local 1997</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点的坐标，求从点 $1$ 到点 $2$ 的所有路径的最大边权的最小值。</p>
<p>比如有三条路的边权如下:</p>
<p>2-&gt;5-&gt;3-&gt;4 最大边权为 5</p>
<p>1-&gt;8 最大边权为 8</p>
<p>4-&gt;4-&gt;4-&gt;4-&gt;4 最大边权为 4</p>
<p>所以答案为 4。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>Dijkstra 或 Floyd</strong></p>
<p>只需修改一下 $Dijkstra$ 的松弛方程：$if d[v] &gt; max(d[u], w[u][v]) then d[v] = max(d[u], w[u][v])$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> d[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">double</span> mp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        d[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][x] &lt; inf &amp;&amp; d[i] &gt; max(d[x], mp[i][x])) &#123;</span><br><span class="line">                d[i] = max(d[x], mp[i][x]);</span><br><span class="line">                q.push(make_pair(-d[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            mp[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">double</span> z = p[i].dis(p[j]);</span><br><span class="line">                mp[i][j] = mp[j][i] = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d\n"</span>, ++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Frog Distance = %.3lf\n\n"</span>, d[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，修改一下 $Floyd$ 的状态转移方程：$w[i][j] = min(w[i][j], max(w[i][k], w[k][j]))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">double</span> mp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                mp[i][j] = min(mp[i][j], max(mp[i][k], mp[k][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            mp[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">double</span> z = p[i].dis(p[j]);</span><br><span class="line">                mp[i][j] = mp[j][i] = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d\n"</span>, ++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Frog Distance = %.3lf\n\n"</span>, mp[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2254 Globetrotter (计算几何 - 球面最短距离)</title>
    <url>/2019/10/19/POJ-2254-Globetrotter-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E7%90%83%E9%9D%A2%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2254" target="_blank" rel="noopener">POJ 2254</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>As a member of an ACM programming team you’ll soon find yourself always traveling around the world: Zürich, Philadelphia, San José, Atlanta,… from 1999 on the Contest Finals even will be on a different continent each year, so one day you might get to Japan or Australia.</p>
<p>At the contest site it would be interesting to know how many miles you are away from home. For this sake, your job is to write a program to compute the geographical distance between two given locations on the Earth’s surface.</p>
<p>We assume that the Earth is a perfect sphere with a radius of exactly 6378 km. The geographical distance between A and B is the length of the geodetic line segment connecting A and B.</p>
<p>The geodetic line segment between two points on a sphere is the shortest connecting curve lying entirely in the surface of the sphere.</p>
<p>The value of pi is approximately 3.141592653589793.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input will consist of two parts: a list of cities and a list of queries.</p>
<p><strong>City List</strong></p>
<p>The city list consists of up to 100 lines, one line per city. Each line will contain a string ci and two real numbers lati and longi, representing the city name, its latitude and its longitude, respectively.</p>
<p>The city name will be shorter than 30 characters and will not contain white-space characters.</p>
<p>The latitude will be between -90 (South Pole) and +90 (North Pole). The longitude will be between -180 and +180 where negative numbers denote locations west of the meridian and positive numbers denote locations east of the meridian. (The meridian passes through Greenwich, London.)</p>
<p>The city list will be terminated by a line consisting of a single “#”.</p>
<p><strong>Query List</strong></p>
<p>Each line will contain two city names A and B.</p>
<p>The query list will be terminated by the line “# #”.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each query, print a line saying “A - B” where A and B are replaced by the city names. Then print a line saying x km” where x is replaced by the geographical distance (in km) between the two cities, rounded to the nearest integer.</p>
<p>If one of the cities in the query didn’t occur in the city list, print a line saying “Unknown” instead. Print a blank line after each query.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Ulm		48.700	10.500</span><br><span class="line">Freiburg		47.700	9.500	</span><br><span class="line">Philadelphia	39.883	-75.250</span><br><span class="line">SanJose		37.366	-121.933</span><br><span class="line">NorthPole		90	0</span><br><span class="line">SouthPole		-90	0</span><br><span class="line"><span class="section">#</span></span><br><span class="line">Ulm Philadelphia</span><br><span class="line">Ulm SanJose</span><br><span class="line">Freiburg Philadelphia</span><br><span class="line">Freiburg SanJose</span><br><span class="line">Ulm Freiburg</span><br><span class="line">SanJose Philadelphia</span><br><span class="line">Ulm LasVegas</span><br><span class="line">Ulm Ulm</span><br><span class="line">Ulm NorthPole</span><br><span class="line">Ulm SouthPole</span><br><span class="line">NorthPole SouthPole</span><br><span class="line"><span class="section"># #</span></span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Ulm - Philadelphia</span><br><span class="line">6536 km</span><br><span class="line"></span><br><span class="line">Ulm - SanJose</span><br><span class="line">9367 km</span><br><span class="line"></span><br><span class="line">Freiburg - Philadelphia</span><br><span class="line">6519 km</span><br><span class="line"></span><br><span class="line">Freiburg - SanJose</span><br><span class="line">9412 km</span><br><span class="line"></span><br><span class="line">Ulm - Freiburg</span><br><span class="line">134 km</span><br><span class="line"></span><br><span class="line">SanJose - Philadelphia</span><br><span class="line">4023 km</span><br><span class="line"></span><br><span class="line">Ulm - LasVegas</span><br><span class="line">Unknown</span><br><span class="line"></span><br><span class="line">Ulm - Ulm</span><br><span class="line">0 km</span><br><span class="line"></span><br><span class="line">Ulm - NorthPole</span><br><span class="line">4597 km</span><br><span class="line"></span><br><span class="line">Ulm - SouthPole</span><br><span class="line">15440 km</span><br><span class="line"></span><br><span class="line">NorthPole - SouthPole</span><br><span class="line">20037 km</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Ulm+Local+1997" target="_blank" rel="noopener">Ulm Local 1997</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一些城市的经纬度，然后给出若干个询问，每个询问包含两个城市，求这两个城市的球面最短距离。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>已知两点经纬度求球面最短距离的公式：</p>
<p>$AB = R\cdot arccos(cos(wA)cos(wB)cos(jB-jA)+sin(wA)sin(wB))$</p>
<p>其中 $wA$ 和 $jA$ 代表 $A$ 的纬度和经度，$wB$ 和 $jB$ 代表 $B$ 的纬度和经度。</p>
<p>证明见：<a href="https://blog.csdn.net/liminlu0314/article/details/8553926" target="_blank" rel="noopener">关于已知两点经纬度求球面最短距离的公式推导</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="number">3.141592653589793</span>;  </span><br><span class="line"><span class="keyword">const</span> db r = <span class="number">6378.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> j, w;</span><br><span class="line">    Point(<span class="keyword">double</span> j = <span class="number">0</span>, <span class="keyword">double</span> w = <span class="number">0</span>) : j(j), w(w) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;w, &amp;j);</span><br><span class="line">        w = w * pi / <span class="number">180.0</span>;</span><br><span class="line">        j = j * pi / <span class="number">180.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r * <span class="built_in">acos</span>(<span class="built_in">cos</span>(w) * <span class="built_in">cos</span>(a.w) * <span class="built_in">cos</span>(a.j - j) + <span class="built_in">sin</span>(w) * <span class="built_in">sin</span>(a.w));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, Point&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">cin</span> &gt;&gt; s1) &amp;&amp; s1[<span class="number">0</span>] != <span class="string">'#'</span>) &#123;</span><br><span class="line">        Point tmp;</span><br><span class="line">        tmp.input();</span><br><span class="line">        mp[s1] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Point p1, p2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; s2[<span class="number">0</span>] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">" - "</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp.find(s1) != mp.end() &amp;&amp; mp.find(s2) != mp.end()) &#123;</span><br><span class="line">            p1 = mp[s1], p2 = mp[s2];</span><br><span class="line">            <span class="keyword">double</span> ans = p1.dis(p2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.0lf km\n\n"</span>, ans);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Unknown\n\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2287 Tian Ji -- The Horse Racing (贪心)</title>
    <url>/2019/11/06/POJ-2287-Tian-Ji-The-Horse-Racing-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2287" target="_blank" rel="noopener">POJ 2287</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Here is a famous story in Chinese history.</p>
<p>That was about 2300 years ago. General Tian Ji was a high official in the country Qi. He likes to play horse racing with the king and others.</p>
<p>Both of Tian and the king have three horses in different classes, namely, regular, plus, and super. The rule is to have three rounds in a match; each of the horses must be used in one round. The winner of a single round takes two hundred silver dollars from the loser.</p>
<p>Being the most powerful man in the country, the king has so nice horses that in each class his horse is better than Tian’s. As a result, each time the king takes six hundred silver dollars from Tian.</p>
<p>Tian Ji was not happy about that, until he met Sun Bin, one of the most famous generals in Chinese history. Using a little trick due to Sun, Tian Ji brought home two hundred silver dollars and such a grace in the next match.</p>
<p>It was a rather simple trick. Using his regular class horse race against the super class from the king, they will certainly lose that round. But then his plus beat the king’s regular, and his super beat the king’s plus. What a simple trick. And how do you think of Tian Ji, the high ranked official in China?</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/06/1573050687823-1573050688065.png" alt=""></p>
<p>Were Tian Ji lives in nowadays, he will certainly laugh at himself. Even more, were he sitting in the ACM contest right now, he may discover that the horse racing problem can be simply viewed as finding the maximum matching in a bipartite graph. Draw Tian’s horses on one side, and the king’s horses on the other. Whenever one of Tian’s horses can beat one from the king, we draw an edge between them, meaning we wish to establish this pair. Then, the problem of winning as many rounds as possible is just to find the maximum matching in this graph. If there are ties, the problem becomes more complicated, he needs to assign weights 0, 1, or -1 to all the possible edges, and find a maximum weighted perfect matching…</p>
<p>However, the horse racing problem is a very special case of bipartite matching. The graph is decided by the speed of the horses — a vertex of higher speed always beat a vertex of lower speed. In this case, the weighted bipartite matching algorithm is a too advanced tool to deal with the problem.</p>
<p>In this problem, you are asked to write a program to solve this special case of matching problem.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of up to 50 test cases. Each case starts with a positive integer n ( n&lt;=1000) on the first line, which is the number of horses on each side. The next n integers on the second line are the speeds of Tian’s horses. Then the next n integers on the third line are the speeds of the king’s horses. The input ends with a line that has a single `0’ after the last test case.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each input case, output a line containing a single number, which is the maximum money Tian Ji will get, in silver dollars.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">92 83 71</span><br><span class="line">95 87 74</span><br><span class="line">2</span><br><span class="line">20 20</span><br><span class="line">20 20</span><br><span class="line">2</span><br><span class="line">20 19</span><br><span class="line">22 18</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">200</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Shanghai+2004" target="_blank" rel="noopener">Shanghai 2004</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>田忌赛马，田忌和齐王都有 $n$ 匹马，赢一局得 $200$，输一局失 $200$，平局财产不动。求田忌最多能赢多少钱。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>贪心</strong></p>
<p>首先拿田忌最快的马与齐王最快的马比。</p>
<p>如果田忌的马快就赢一场，否则用最慢的马去比，输一场。</p>
<p>如果田忌最快的马与齐王最快的马一样快，则拿田忌最慢的马与齐王最慢的马比。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>], b[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        sort(b, b + n);</span><br><span class="line">        <span class="keyword">int</span> min1 = <span class="number">0</span>, min2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = n - <span class="number">1</span>, max2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[max1] &gt; b[max2]) &#123;  <span class="comment">// 田忌最快的马比齐王最快的马快</span></span><br><span class="line">                ++ans;</span><br><span class="line">                max1--;</span><br><span class="line">                max2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[max1] &lt; b[max2]) &#123;  <span class="comment">// 田忌最快的马比齐王最快的马慢</span></span><br><span class="line">                --ans;</span><br><span class="line">                min1++;</span><br><span class="line">                max2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 田忌最快的马与齐王最快的马一样快</span></span><br><span class="line">                <span class="keyword">if</span>(a[min1] &gt; b[min2]) &#123;  <span class="comment">// 田忌最慢的马比齐王最慢的马快</span></span><br><span class="line">                    ++ans;</span><br><span class="line">                    min1++;</span><br><span class="line">                    min2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[min1] &lt; b[max2]) &#123;  <span class="comment">// 田忌最慢的马比齐王最慢的马慢</span></span><br><span class="line">                        --ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    min1++;</span><br><span class="line">                    max2--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans * <span class="number">200</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2318 TOYS (二分 叉积)</title>
    <url>/2019/08/25/POJ-2318-TOYS-%E4%BA%8C%E5%88%86-%E5%8F%89%E7%A7%AF/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2318" target="_blank" rel="noopener">POJ 2318</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Calculate the number of toys that land in each bin of a partitioned toy box. </p>
<p>Mom and dad have a problem - their child John never puts his toys away when he is finished playing with them. They gave John a rectangular box to put his toys in, but John is rebellious and obeys his parents by simply throwing his toys into the box. All the toys get mixed up, and it is impossible for John to find his favorite toys. </p>
<p>John’s parents came up with the following idea. They put cardboard partitions into the box. Even if John keeps throwing his toys into the box, at least toys that get thrown into different bins stay separated. The following diagram shows a top view of an example toy box. </p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/25/1566739388887-1566739388889.png" alt=""></p>
<p>For this problem, you are asked to determine how many toys fall into each partition as John throws them into the toy box.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input file contains one or more problems. The first line of a problem consists of six integers, n m x1 y1 x2 y2. The number of cardboard partitions is n (0 &lt; n &lt;= 5000) and the number of toys is m (0 &lt; m &lt;= 5000). The coordinates of the upper-left corner and the lower-right corner of the box are (x1,y1) and (x2,y2), respectively. The following n lines contain two integers per line, Ui Li, indicating that the ends of the i-th cardboard partition is at the coordinates (Ui,y1) and (Li,y2). You may assume that the cardboard partitions do not intersect each other and that they are specified in sorted order from left to right. The next m lines contain two integers per line, Xj Yj specifying where the j-th toy has landed in the box. The order of the toy locations is random. You may assume that no toy will land exactly on a cardboard partition or outside the boundary of the box. The input is terminated by a line consisting of a single 0.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The output for each problem will be one line for each separate bin in the toy box. For each bin, print its bin number, followed by a colon and one space, followed by the number of toys thrown into that bin. Bins are numbered from 0 (the leftmost bin) to n (the rightmost bin). Separate the output of different problems by a single blank line.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 6 0 10 60 0</span><br><span class="line">3 1</span><br><span class="line">4 3</span><br><span class="line">6 8</span><br><span class="line">10 10</span><br><span class="line">15 30</span><br><span class="line">1 5</span><br><span class="line">2 1</span><br><span class="line">2 8</span><br><span class="line">5 5</span><br><span class="line">40 10</span><br><span class="line">7 9</span><br><span class="line">4 10 0 10 100 0</span><br><span class="line">20 20</span><br><span class="line">40 40</span><br><span class="line">60 60</span><br><span class="line">80 80</span><br><span class="line"> 5 10</span><br><span class="line">15 10</span><br><span class="line">25 10</span><br><span class="line">35 10</span><br><span class="line">45 10</span><br><span class="line">55 10</span><br><span class="line">65 10</span><br><span class="line">75 10</span><br><span class="line">85 10</span><br><span class="line">95 10</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0: 2</span><br><span class="line">1: 1</span><br><span class="line">2: 1</span><br><span class="line">3: 1</span><br><span class="line">4: 0</span><br><span class="line">5: 1</span><br><span class="line"></span><br><span class="line">0: 2</span><br><span class="line">1: 2</span><br><span class="line">2: 2</span><br><span class="line">3: 2</span><br><span class="line">4: 2</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>As the example illustrates, toys that fall on the boundary of the box are “in” the box.</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Rocky+Mountain+2003" target="_blank" rel="noopener">Rocky Mountain 2003</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 条线段将一个矩形分成 $n + 1$ 个区域，现在给定 $m$ 个点的坐标，求每个区域包含多少个点。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>二分 叉积</strong></p>
<p>用叉积判断某个点 $p$ 在有向线段 $se$ 的左边还是右边。若 $\boldsymbol{sp}\times \boldsymbol{se} &gt; 0$，则点 $p$ 在坐厕，小于 $0$ 在右侧。</p>
<p>给定的线段是从左到右的，因此每个点所在的区域可以用二分求解。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) : x(xx), y(yy) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point s, e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Line line[maxn];</span><br><span class="line">Point point[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(line[mid].toLeftTest(point[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[l]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, i, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        db xl, yl, xr, yr;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;xl, &amp;yl, &amp;xr, &amp;yr);</span><br><span class="line">        line[<span class="number">0</span>].s = Point(xl, yr);</span><br><span class="line">        line[<span class="number">0</span>].e = Point(xl, yl);</span><br><span class="line">        line[n + <span class="number">1</span>].s = Point(xr, yr);</span><br><span class="line">        line[n + <span class="number">1</span>].e = Point(xr, yl);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            db u, l;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;u, &amp;l);</span><br><span class="line">            line[i].s = Point(l, yr);</span><br><span class="line">            line[i].e = Point(u, yl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>ToLeftTest</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2451 Uyuw&#39;s Concert (半平面交)</title>
    <url>/2019/09/11/POJ-2451-Uyuw-s-Concert-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2451" target="_blank" rel="noopener">POJ 2451</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Prince Remmarguts solved the CHESS puzzle successfully. As an award, Uyuw planned to hold a concert in a huge piazza named after its great designer Ihsnayish.</p>
<p>The piazza in UDF - United Delta of Freedom’s downtown was a square of [0, 10000] * [0, 10000]. Some basket chairs had been standing there for years, but in a terrible mess. Look at the following graph.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/11/1568195289648-1568195289846.png" alt=""></p>
<p>In this case we have three chairs, and the audiences face the direction as what arrows have pointed out. The chairs were old-aged and too heavy to be moved. Princess Remmarguts told the piazza’s current owner Mr. UW, to build a large stage inside it. The stage must be as large as possible, but he should also make sure the audience in every position of every chair would be able to see the stage without turning aside (that means the stage is in the forward direction of their own).</p>
<p>To make it simple, the stage could be set highly enough to make sure even thousands of chairs were in front of you, as long as you were facing the stage, you would be able to see the singer / pianist – Uyuw.</p>
<p>Being a mad idolater, can you tell them the maximal size of the stage?</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>In the first line, there’s a single non-negative integer N (N &lt;= 20000), denoting the number of basket chairs. Each of the following lines contains four floating numbers x1, y1, x2, y2, which means there’s a basket chair on the line segment of (x1, y1) – (x2, y2), and facing to its LEFT (That a point (x, y) is at the LEFT side of this segment means that (x – x1) <em> (y – y2) – (x – x2) </em> (y – y1) &gt;= 0).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Output a single floating number, rounded to 1 digit after the decimal point. This is the maximal area of the stage.    </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10000 10000 0 5000</span><br><span class="line">10000 5000 5000 10000</span><br><span class="line">0 5000 5000 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">54166666.7</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Monthly" target="_blank" rel="noopener">POJ Monthly</a>, Zeyuan Zhu</p>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>Sample input is the same as the graph above, while the correct solution for it is as below:</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/11/1568195306165-1568195306167.png" alt=""></p>
<p>I suggest that you use Extended in pascal and long double in C / C++ to avoid precision error. But the standard program only uses double.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个正方形的边界和 $n$ 个向量，求围出的多边形的核的面积。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>半平面交</strong></p>
<p>半平面交求多边形的核的模板题。</p>
<p>POJ 的 g++ 好像经常用 <code>long double</code> 才能过。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>((a.dis() * dis()) / dot(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Point p[maxn], ip[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        Line l = a;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(angle - l.angle) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l.toLeftTest(s) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> angle &lt; l.angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_angle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        angle = <span class="built_in">atan2</span>(e.y - s.y, e.x - s.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		db a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		db a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        db x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        db y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(l[i].angle - l[tmp].angle) == <span class="number">1</span>) l[++tmp] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = tmp;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    q[<span class="number">1</span>] = l[<span class="number">1</span>], q[<span class="number">2</span>] = l[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            --tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[head].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        --tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[tail].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ++head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tail - head + <span class="number">1</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">        ip[++tmp] = q[i].crosspoint(q[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ip[++tmp] = q[head].crosspoint(q[tail]);</span><br><span class="line">    db ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= tmp; ++i) &#123;</span><br><span class="line">        ans += (ip[i - <span class="number">1</span>] - ip[<span class="number">1</span>]).cross(ip[i] - ip[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(ans) == <span class="number">0</span>) ans = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> _ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        l[<span class="number">1</span>] = Line(Point(<span class="number">0</span>, <span class="number">0</span>), Point(<span class="number">10000</span>, <span class="number">0</span>)); l[<span class="number">1</span>].get_angle();</span><br><span class="line">        l[<span class="number">2</span>] = Line(Point(<span class="number">10000</span>, <span class="number">0</span>), Point(<span class="number">10000</span>, <span class="number">10000</span>)); l[<span class="number">2</span>].get_angle();</span><br><span class="line">        l[<span class="number">3</span>] = Line(Point(<span class="number">10000</span>, <span class="number">10000</span>), Point(<span class="number">0</span>, <span class="number">10000</span>)); l[<span class="number">3</span>].get_angle();</span><br><span class="line">        l[<span class="number">4</span>] = Line(Point(<span class="number">0</span>, <span class="number">10000</span>), Point(<span class="number">0</span>, <span class="number">0</span>)); l[<span class="number">4</span>].get_angle();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            l[<span class="number">4</span> + i].input();</span><br><span class="line">            l[<span class="number">4</span> + i].get_angle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; ++_ &lt;&lt; " ";</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, half_plane(n + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2398 Toy Storage (二分 叉积)</title>
    <url>/2019/08/25/POJ-2398-Toy-Storage-%E4%BA%8C%E5%88%86-%E5%8F%89%E7%A7%AF/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2398" target="_blank" rel="noopener">POJ 2398</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Mom and dad have a problem: their child, Reza, never puts his toys away when he is finished playing with them. They gave Reza a rectangular box to put his toys in. Unfortunately, Reza is rebellious and obeys his parents by simply throwing his toys into the box. All the toys get mixed up, and it is impossible for Reza to find his favorite toys anymore. </p>
<p>Reza’s parents came up with the following idea. They put cardboard partitions into the box. Even if Reza keeps throwing his toys into the box, at least toys that get thrown into different partitions stay separate. The box looks like this from the top: </p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/25/1566739388887-1566739388889.png" alt=""></p>
<p>We want for each positive integer t, such that there exists a partition with t toys, determine how many partitions have t, toys.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of a number of cases. The first line consists of six integers n, m, x1, y1, x2, y2. The number of cardboards to form the partitions is n (0 &lt; n &lt;= 1000) and the number of toys is given in m (0 &lt; m &lt;= 1000). The coordinates of the upper-left corner and the lower-right corner of the box are (x1, y1) and (x2, y2), respectively. The following n lines each consists of two integers Ui Li, indicating that the ends of the ith cardboard is at the coordinates (Ui, y1) and (Li, y2). You may assume that the cardboards do not intersect with each other. The next m lines each consists of two integers Xi Yi specifying where the ith toy has landed in the box. You may assume that no toy will land on a cardboard. </p>
<p>A line consisting of a single 0 terminates the input.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each box, first provide a header stating “Box” on a line of its own. After that, there will be one line of output per count (t &gt; 0) of toys in a partition. The value t will be followed by a colon and a space, followed the number of partitions containing t toys. Output will be sorted in ascending order of t for each box.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 10 0 10 100 0</span><br><span class="line">20 20</span><br><span class="line">80 80</span><br><span class="line">60 60</span><br><span class="line">40 40</span><br><span class="line">5 10</span><br><span class="line">15 10</span><br><span class="line">95 10</span><br><span class="line">25 10</span><br><span class="line">65 10</span><br><span class="line">75 10</span><br><span class="line">35 10</span><br><span class="line">45 10</span><br><span class="line">55 10</span><br><span class="line">85 10</span><br><span class="line">5 6 0 10 60 0</span><br><span class="line">4 3</span><br><span class="line">15 30</span><br><span class="line">3 1</span><br><span class="line">6 8</span><br><span class="line">10 10</span><br><span class="line">2 1</span><br><span class="line">2 8</span><br><span class="line">1 5</span><br><span class="line">5 5</span><br><span class="line">40 10</span><br><span class="line">7 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Box</span><br><span class="line">2: 5</span><br><span class="line">Box</span><br><span class="line">1: 4</span><br><span class="line">2: 1</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Tehran+2003+Preliminary" target="_blank" rel="noopener">Tehran 2003 Preliminary</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 条线段将一个矩形分成 $n + 1$ 个区域，现在给定 $m$ 个点的坐标，统计每个区域内点的数量，求每种数量有几个区域。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>二分 叉积</strong></p>
<p>与 <a href="https://wutao18.github.io/2019/08/25/POJ-2318-TOYS-%E4%BA%8C%E5%88%86-%E5%8F%89%E7%A7%AF/">POJ 2318</a> 类似，不同的是这次给定的线段是乱序的，因此先要排序。输出也不同，改一下即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) : x(xx), y(yy) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point s, e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s &lt; a.s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.s &lt; b.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Line line[maxn];</span><br><span class="line">Point point[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(line[mid].toLeftTest(point[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[l]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]) &#123;</span><br><span class="line">            cnt[ans[i]]++;</span><br><span class="line">            max_size = max(max_size, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Box\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max_size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, i, cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        db xl, yl, xr, yr;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;xl, &amp;yl, &amp;xr, &amp;yr);</span><br><span class="line">        line[<span class="number">0</span>].s = Point(xl, yr);</span><br><span class="line">        line[<span class="number">0</span>].e = Point(xl, yl);</span><br><span class="line">        line[n + <span class="number">1</span>].s  = Point(xr, yr);</span><br><span class="line">        line[n + <span class="number">1</span>].e = Point(xr, yl);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            db u, l;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;u, &amp;l);</span><br><span class="line">            line[i].s = Point(l, yr);</span><br><span class="line">            line[i].e = Point(u, yl);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(line + <span class="number">1</span>, line + <span class="number">1</span> + n); <span class="comment">// 要对线段排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>ToLeftTest</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2387 Til the Cows Come Home (Dijkstra)</title>
    <url>/2019/10/11/POJ-2387-Til-the-Cows-Come-Home-Dijkstra/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2387" target="_blank" rel="noopener">POJ 2387</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible.</p>
<p>Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.</p>
<p>Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<ul>
<li><p>Line 1: Two integers: T and N</p>
</li>
<li><p>Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100.</p>
</li>
</ul>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<ul>
<li>Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1.</li>
</ul>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 20</span><br><span class="line">2 3 30</span><br><span class="line">3 4 20</span><br><span class="line">4 5 20</span><br><span class="line">1 5 100</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>INPUT DETAILS:</p>
<p>There are five landmarks.</p>
<p>OUTPUT DETAILS:</p>
<p>Bessie can get home by following trails 4, 3, 2, and 1.</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2004+November" target="_blank" rel="noopener">USACO 2004 November</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定无向图，求点 $1$ 到 $n$ 的最短路。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>Dijkstra</strong></p>
<p>$Dijkstra$ 的模板题，注意有重边。</p>
<p>写了一下堆优化的 $Dijkstra$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[x][i] != inf) &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i] &gt; d[x] + g[x][i]) &#123;</span><br><span class="line">                    d[i] = d[x] + g[x][i];</span><br><span class="line">                    q.push(make_pair(-d[i], i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            g[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; t &gt;&gt; n) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="keyword">if</span>(z &lt; g[x][y]) &#123;</span><br><span class="line">                g[x][y] = g[y][x] = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2823 Sliding Window (单调队列)</title>
    <url>/2019/09/07/POJ-2823-Sliding-Window-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2823" target="_blank" rel="noopener">POJ 2823</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>An array of size n ≤ 10 6 is given to you. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example:</p>
<p>The array is [1 3 -1 -3 5 3 6 7], and k is 3.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Window position</th>
<th style="text-align:right">Minimum value</th>
<th style="text-align:right">Maximum value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[1  3  -1] -3  5  3  6  7</td>
<td style="text-align:right">-1</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td style="text-align:center">1 [3  -1  -3] 5  3  6  7</td>
<td style="text-align:right">-3</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td style="text-align:center">1  3 [-1  -3  5] 3  6  7</td>
<td style="text-align:right">-3</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1 [-3  5  3] 6  7</td>
<td style="text-align:right">-3</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1  -3 [5  3  6] 7</td>
<td style="text-align:right">3</td>
<td style="text-align:right">6</td>
</tr>
<tr>
<td style="text-align:center">1  3  -1  -3  5 [3  6  7]</td>
<td style="text-align:right">3</td>
<td style="text-align:right">7</td>
</tr>
</tbody>
</table>
</div>
<p>Your task is to determine the maximum and minimum values in the sliding window at each position.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input consists of two lines. The first line contains two integers n and k which are the lengths of the array and the sliding window. There are n integers in the second line.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>There are two lines in the output. The first line gives the minimum values in the window at each position, from left to right, respectively. The second line gives the maximum values.    </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Monthly--2006.04.28" target="_blank" rel="noopener">POJ Monthly—2006.04.28</a>, Ikki</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数和一个长度为 $k$ 的滑动窗口，求滑动窗口从左滑到右每次的最大值和最小值。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>单调队列</strong></p>
<p>单调队列模板题。</p>
<p>首先记录每个数的下标。</p>
<p>求最大值和最小值分别维护一个单调队列，如果当前插入的数的下标减去队首元素的下标超过了窗口长度 $k$，就弹出队首。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">&#125; node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;Node&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!d.empty() &amp;&amp; node[i].val &gt; d.back().val) d.pop_back();</span><br><span class="line">        d.push_back(node[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.front().val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!d.empty() &amp;&amp; node[i].id - d.front().id &gt;= k) &#123;</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.empty() &amp;&amp; node[i].val &gt; d.back().val) d.pop_back();</span><br><span class="line">        d.push_back(node[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; d.front().val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;Node&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!d.empty() &amp;&amp; node[i].val &lt; d.back().val) d.pop_back();</span><br><span class="line">        d.push_back(node[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.front().val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!d.empty() &amp;&amp; node[i].id - d.front().id &gt;= k) &#123;</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!d.empty() &amp;&amp; node[i].val &lt; d.back().val) d.pop_back();</span><br><span class="line">        d.push_back(node[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; d.front().val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].val;</span><br><span class="line">        node[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    getMin();</span><br><span class="line">    getMax();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>STL</tag>
        <tag>单调队列</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3070 Fibonacci  (矩阵快速幂)</title>
    <url>/2019/08/27/POJ-3070-Fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3070" target="_blank" rel="noopener">POJ 3070</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>In the Fibonacci integer sequence, $F_0 = 0$, $F_1 = 1$, and $F_n = F_{n − 1} + F_{n − 2}$ for $n \ge 2$. For example, the first ten terms of the Fibonacci sequence are:</p>
<script type="math/tex; mode=display">0,\ 1,\ 1,\ 2,\ 3,\ 5,\ 8,\ 13,\ 21,\ 34,\ ...</script><p>An alternative formula for the Fibonacci sequence is</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/27/1566896523034-1566896523038.png" alt="">.</p>
<p>Given an integer $n$, your goal is to compute the last $4$ digits of $F_n$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input test file will contain multiple test cases. Each test case consists of a single line containing $n$ (where $0 \le n \le 1,000,000,000$). The end-of-file is denoted by a single line containing the number $−1$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, print the last four digits of $F_n$. If the last four digits of $F_n$ are all zeros, print $‘0’$; otherwise, omit any leading zeros (i.e., print $F_n$ mod $10000$).</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">9</span><br><span class="line">999999999</span><br><span class="line">1000000000</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">34</span><br><span class="line">626</span><br><span class="line">6875</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定正整数 $n$，求斐波那契数列第 $n$ 项。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>矩阵快速幂</strong></p>
<p>矩阵快速幂模板题。</p>
<script type="math/tex; mode=display">
 \left[
 \begin{matrix}
   F_{n + 1} & F_n \\
   F_n & F_{n - 1}
  \end{matrix}
  \right] =
  \left[
 \begin{matrix}
   1 & 1 \\
   1 & 0
  \end{matrix}
  \right] ^ n</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">    Matrix(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>) : n(n), m(m) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld"</span>, a[i][j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, j == m? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            a[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix b) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">c</span><span class="params">(n, b.m)</span></span>;</span><br><span class="line">        c.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c.n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c.m; ++j) &#123;</span><br><span class="line">                    c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">qmod</span><span class="params">(ll b)</span> </span>&#123;</span><br><span class="line">        Matrix ans = Matrix(n, n);</span><br><span class="line">        ans.unit();</span><br><span class="line">        <span class="keyword">if</span>(!b) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(b) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * (*<span class="keyword">this</span>);</span><br><span class="line">            *<span class="keyword">this</span> = (*<span class="keyword">this</span>) * (*<span class="keyword">this</span>);</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n) &#123;</span><br><span class="line">            <span class="function">Matrix <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">            m.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            m = m.qmod(n - <span class="number">1</span>);</span><br><span class="line">            ans = m.a[<span class="number">1</span>][<span class="number">1</span>] % mod;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3264 Balanced Lineup (ST算法)</title>
    <url>/2019/09/04/POJ-3264-Balanced-Lineup-ST%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3264" target="_blank" rel="noopener">POJ 3264</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>For the daily milking, Farmer John’s $N$ cows $(1 \le N \le 50,000)$ always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.</p>
<p>Farmer John has made a list of $Q (1 \le Q \le 200,000)$ potential groups of cows and their $heights (1 \le height \le 1,000,000)$. For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Line $1$: Two space-separated integers, $N$ and $Q$. </p>
<p>Lines $2..N+1$: Line $i+1$ contains a single integer that is the height of cow $i $</p>
<p>Lines $N+2..N+Q+1$: Two integers $A$ and $B (1 ≤ A ≤ B ≤ N)$, representing the range of cows from $A$ to $B$ inclusive.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Lines $1.. Q$: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 5</span><br><span class="line">4 6</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2007+January+Silver" target="_blank" rel="noopener">USACO 2007 January Silver</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数，$q$ 个询问。每个询问包含 $l$ 和 $r$，求区间 $[l, r]$ 内的最大值减最小值的差值。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>ST算法</strong></p>
<p>ST 算法模板题。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">50</span>], g[maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            g[i][j] = min(g[i][j - <span class="number">1</span>], g[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">st_query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) - min(g[l][k], g[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    st_prework();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, st_query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>RMQ</tag>
        <tag>ST算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3130 How I Mathematician Wonder What You Are! (半平面交)</title>
    <url>/2019/09/11/POJ-3130-How-I-Mathematician-Wonder-What-You-Are-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3130" target="_blank" rel="noopener">POJ 3130</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>After counting so many stars in the sky in his childhood, Isaac, now an astronomer and a mathematician uses a big astronomical telescope and lets his image processing program count stars. The hardest part of the program is to judge if shining object in the sky is really a star. As a mathematician, the only way he knows is to apply a mathematical definition of stars.</p>
<p>The mathematical definition of a star shape is as follows: A planar shape $F$ is star-shaped if and only if there is a point $C \in F$ such that, for any point $P \in F$, the line segment $CP$ is contained in $F$. Such a point $C$ is called a center of $F$. To get accustomed to the definition let’s see some examples below.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/11/1568197222877-1568197222880.png" alt=""></p>
<p>The first two are what you would normally call stars. According to the above definition, however, all shapes in the first row are star-shaped. The two in the second row are not. For each star shape, a center is indicated with a dot. Note that a star shape in general has infinitely many centers. Fore Example, for the third quadrangular shape, all points in it are centers.</p>
<p>Your job is to write a program that tells whether a given polygonal shape is star-shaped or not.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input is a sequence of datasets followed by a line containing a single zero. Each dataset specifies a polygon, and is formatted as follows.</p>
<blockquote>
<pre><code>n    
x1    y1
x2    y2

…

xn    yn
</code></pre></blockquote>
<p>The first line is the number of vertices, $n$, which satisfies $4 \le n \le 50$. Subsequent $n$ lines are the $x$- and $y$-coordinates of the $n$ vertices. They are integers and satisfy $0 \le x_i \le 10000$ and $0 \le yi \le 10000 (i = 1, …, n)$. Line segments $(x_i, y_i)–(x_{i + 1}, y_{i + 1}) (i = 1, …, n − 1)$ and the line segment $(x_n, y_n)–(x_1, y_1)$ form the border of the polygon in the counterclockwise order. That is, these line segments see the inside of the polygon in the left of their directions.</p>
<p>You may assume that the polygon is simple, that is, its border never crosses or touches itself. You may assume assume that no three edges of the polygon meet at a single point even when they are infinitely extended.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each dataset, output “1” if the polygon is star-shaped and “0” otherwise. Each number must be in a separate line and the line should not contain any other characters.   </p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6 </span><br><span class="line">66 13 </span><br><span class="line">96 61 </span><br><span class="line">76 98 </span><br><span class="line">13 94 </span><br><span class="line">4 0 </span><br><span class="line">45 68 </span><br><span class="line">8 </span><br><span class="line">27 21 </span><br><span class="line">55 14 </span><br><span class="line">93 12 </span><br><span class="line">56 95 </span><br><span class="line">15 48 </span><br><span class="line">38 46 </span><br><span class="line">51 65 </span><br><span class="line">64 31 </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Japan+2006" target="_blank" rel="noopener">Japan 2006</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点的多边形，求多边形是否有核。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>半平面交</strong></p>
<p>半平面交求多边形的核的面积，如果面积为 0，就没有核。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>((a.dis() * dis()) / dot(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Point p[maxn], ip[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        Line l = a;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(angle - l.angle) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l.toLeftTest(s) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> angle &lt; l.angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_angle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        angle = <span class="built_in">atan2</span>(e.y - s.y, e.x - s.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		db a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		db a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        db x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        db y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(l[i].angle - l[tmp].angle) == <span class="number">1</span>) l[++tmp] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = tmp;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    q[<span class="number">1</span>] = l[<span class="number">1</span>], q[<span class="number">2</span>] = l[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            --tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[head].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        --tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[tail].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ++head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tail - head + <span class="number">1</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">        ip[++tmp] = q[i].crosspoint(q[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ip[++tmp] = q[head].crosspoint(q[tail]);</span><br><span class="line">    db ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= tmp; ++i) &#123;</span><br><span class="line">        ans += (ip[i - <span class="number">1</span>] - ip[<span class="number">1</span>]).cross(ip[i] - ip[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                l[++cnt].e = p[i];</span><br><span class="line">                l[cnt].s = p[i - <span class="number">1</span>];</span><br><span class="line">                l[cnt].get_angle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l[++cnt].e = p[<span class="number">1</span>];</span><br><span class="line">        l[cnt].s = p[n];</span><br><span class="line">        l[cnt].get_angle();</span><br><span class="line">        <span class="keyword">if</span>(dcmp(half_plane(cnt)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3090 Visible Lattice Points (欧拉函数)</title>
    <url>/2019/09/19/POJ-3090-Visible-Lattice-Points-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3090" target="_blank" rel="noopener">POJ 3090</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>A lattice point $(x, y)$ in the first quadrant ($x$ and $y$ are integers greater than or equal to $0$), other than the origin, is visible from the origin if the line from $(0, 0)$ to $(x, y)$ does not pass through any other lattice point. For example, the point $(4, 2)$ is not visible since the line from the origin passes through $(2, 1)$. The figure below shows the points $(x, y)$ with $0 \le x, y \le 5$ with lines from the origin to the visible points.</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/19/1568893002934-1568893003180.png" alt=""></p>
<p>Write a program which, given a value for the size, $N$, computes the number of visible points $(x, y)$ with $0 \le x, y \le N$.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input contains a single integer $C (1 \le C \le 1000)$ which is the number of datasets that follow.</p>
<p>Each dataset consists of a single line of input containing a single integer $N (1 \le N \le 1000)$, which is the size.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each dataset, there is to be one line of output consisting of: the dataset number starting at $1$, a single space, the size, a single space and the number of visible points for that size.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">231</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 2 5</span><br><span class="line">2 4 13</span><br><span class="line">3 5 21</span><br><span class="line">4 231 32549</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Greater+New+York+2006" target="_blank" rel="noopener">Greater New York 2006</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个大小为 $N * N$ 的矩形，每个格点插着钉子，问从 $(0, 0)$ 点能看到多少钉子。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>欧拉函数</strong></p>
<p>容易发现除了 $(0, 1)$ $(1, 0)$ $(1, 1)$，如果一个钉子 $(x, y)$ 能被看到，那么 $gcd(x, y) = 1, x \neq y$。由于能看到的钉子关于过 $(0, 0)$ 和 $(N, N)$ 的直线对称，因此只考虑一半即可。对于每个 $x \in [2, N]$，需要求出多少个 $y$ 满足 $gcd(x, y) = 1, 1 \le y &lt; x$，也就是求 $x$ 的欧拉函数。</p>
<p>因此答案为 $3 + 2 * \sum_{i=2}^N \varphi(i)$，其中 $\varphi(i)$ 为欧拉函数。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt;</span><br><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="keyword">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            v[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[primes[j] * i] = primes[j] * phi[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    get_eulers(<span class="number">1001</span>);</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum += phi[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ++kase &lt;&lt; <span class="string">" "</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> + <span class="number">2</span> * sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3268 Silver Cow Party (Dijkstra)</title>
    <url>/2019/10/13/POJ-3268-Silver-Cow-Party-Dijkstra/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3268" target="_blank" rel="noopener">POJ 3268</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>One cow from each of $N$ farms $(1 ≤ N ≤ 1000)$ conveniently numbered $1..N$ is going to attend the big cow party to be held at farm #$X (1 ≤ X ≤ N)$. A total of $M (1 ≤ M ≤ 100,000)$ unidirectional (one-way roads connects pairs of farms; road $i$ requires $T_i (1 ≤ T_i ≤ 100)$ units of time to traverse.</p>
<p>Each cow must walk to the party and, when the party is over, return to her farm. Each cow is lazy and thus picks an optimal route with the shortest time. A cow’s return route might be different from her original route to the party since roads are one-way.</p>
<p>Of all the cows, what is the longest amount of time a cow must spend walking to the party and back?</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Line $1$: Three space-separated integers, respectively: $N$, $M$, and $X$</p>
<p>Lines $2.. M+1$: Line $i+1$ describes road $i$ with three space-separated integers: $A_i$, $B_i$, and $T_i$. The described road runs from farm $A_i$ to farm $B_i$, requiring $T_i$ time units to traverse.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>Line 1: One integer: the maximum of time any one cow must walk.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 8 2</span><br><span class="line">1 2 4</span><br><span class="line">1 3 2</span><br><span class="line">1 4 7</span><br><span class="line">2 1 1</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">3 4 4</span><br><span class="line">4 2 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>Cow 4 proceeds directly to the party (3 units) and returns via farms 1 and 3 (7 units), for a total of 10 time units.</p>
</blockquote>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2007+February+Silver" target="_blank" rel="noopener">USACO 2007 February Silver</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点和 $m$ 条边的有向图，每个点有一头牛，牛 $a$ 到牛 $b$ 需花费的时间为 $t$，现在所有的牛要到牛 $x$ 所在的点去，求所有牛去牛 $x$ 处再返回的最短时间中的最大值。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>Dijkstra</strong></p>
<p>对原图和反向建边的图各跑一次 $Dijkstra$，两次的 $d$ 数组的和就是每头牛的往返的最短时间，然后找出其中的最大值即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> s[M], e[M], w[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> w): to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> d[N], vis[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    G[x].push_back(Edge(y, z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(P(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        P p = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); ++i) &#123;</span><br><span class="line">            Edge e = G[x][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &gt; d[x] + e.w) &#123;</span><br><span class="line">                d[e.to] = d[x] + e.w;</span><br><span class="line">                q.push(P(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s[i], &amp;e[i], &amp;w[i]);</span><br><span class="line">        add(s[i], e[i], w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cnt[i] = d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        add(e[i], s[i], w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(x);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = max(ans, cnt[i] + d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3304 Segments (判断直线与线段相交)</title>
    <url>/2019/08/26/POJ-3304-Segments-%E5%88%A4%E6%96%AD%E7%9B%B4%E7%BA%BF%E4%B8%8E%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3304" target="_blank" rel="noopener">POJ 3304</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Given n segments in the two dimensional space, write a program, which determines if there exists a line such that after projecting these segments on it, all projected segments have at least one point in common.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input begins with a number T showing the number of test cases and then, T test cases follow. Each test case begins with a line containing a positive integer n ≤ 100 showing the number of segments. After that, n lines containing four real numbers x1 y1 x2 y2 follow, in which (x1, y1) and (x2, y2) are the coordinates of the two endpoints for one of the segments.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, your program must output “Yes!”, if a line with desired property exists and must output “No!” otherwise. You must assume that two floating point numbers a and b are equal if |a - b| &lt; 10-8.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1.0 2.0 3.0 4.0</span><br><span class="line">4.0 5.0 6.0 7.0</span><br><span class="line">3</span><br><span class="line">0.0 0.0 0.0 1.0</span><br><span class="line">0.0 1.0 0.0 2.0</span><br><span class="line">1.0 1.0 2.0 1.0</span><br><span class="line">3</span><br><span class="line">0.0 0.0 0.0 1.0</span><br><span class="line">0.0 2.0 0.0 3.0</span><br><span class="line">1.0 1.0 2.0 1.0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Yes!</span><br><span class="line">Yes!</span><br><span class="line">No!</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 条线段，判断是否存在一条直线，使得所有线段在这条直线上的投影有公共部分。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>枚举 ToLeftTest</strong></p>
<p>如果存在满足条件的一条直线，那么该直线的一条垂线一定与所有线段相交。</p>
<p>如果 $n \le 2$ 时一定存在。</p>
<p>枚举所有线段的端点中任意两点构造的直线，判断是否所有线段都与之相交。</p>
<p>判断线段与直线相交的方法：判断线段的两个端点是否在直线的同一侧。</p>
<p>注意不要枚举两个相同的端点。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line line[maxn];</span><br><span class="line">Point point[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            line[i].input();</span><br><span class="line">            point[i * <span class="number">2</span>] = line[i].s;</span><br><span class="line">            point[i * <span class="number">2</span> + <span class="number">1</span>] = line[i].e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">2</span> * n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(point[i] == point[j]) <span class="keyword">continue</span>;</span><br><span class="line">                Line l = Line(point[i], point[j]);</span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(l.toLeftTest(line[k].s) + l.toLeftTest(line[k].e) &amp;&amp; l.toLeftTest(line[k].s) == l.toLeftTest(line[k].e)) &#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Yes!\n"</span>);</span><br><span class="line">                    fg = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fg == <span class="number">1</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fg) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>ToLeftTest</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3348 Cows (凸包面积)</title>
    <url>/2019/08/17/POJ-3348-Cows-%E5%87%B8%E5%8C%85%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/POJ-1113" target="_blank" rel="noopener">POJ 1113</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Your friend to the south is interested in building fences and turning plowshares into swords. In order to help with his overseas adventure, they are forced to save money on buying fence posts by using trees as fence posts wherever possible. Given the locations of some trees, you are to help farmers try to create the largest pasture that is possible. Not all the trees will need to be used.</p>
<p>However, because you will oversee the construction of the pasture yourself, all the farmers want to know is how many cows they can put in the pasture. It is well known that a cow needs at least 50 square metres of pasture to survive.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line of input contains a single integer, $n (1 \le n \le 10000)$, containing the number of trees that grow on the available land. The next $n$ lines contain the integer coordinates of each tree given as two integers $x$ and $y$ separated by one space (where $-1000 \le x, y \le 1000$). The integer coordinates correlate exactly to distance in metres (e.g., the distance between coordinate $(10; 11)$ and $(11; 11)$ is one metre).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>You are to output a single integer value, the number of cows that can survive on the largest field you can construct using the available trees.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">0 101</span><br><span class="line">75 0</span><br><span class="line">75 101</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">151</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一些点，圈出一个最大面积，问每 50 平方养一头牛最多能养多少牛。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>凸包面积</strong></p>
<p>先求出凸包，然后选择其中一个点，将凸包分割成若干个三角形，求这些三角形面积的和即可。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/17/1566050553724-1566050553750.png" alt=""></p>
<p>三角形的面积可以用向量的叉积求。</p>
<script type="math/tex; mode=display">S_{\triangle ABC} = \frac{|\overrightarrow{AB} \times \overrightarrow{AC}|}{2}</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> a, <span class="keyword">double</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; b.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; b.x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; p[maxn], stk[maxn];</span><br><span class="line"><span class="keyword">typedef</span> Point Vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vec a, Vec b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; k &amp;&amp; sgn(cross(stk[len] - stk[len - <span class="number">1</span>], p[i] - stk[len - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++len] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = Andrew();</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; t - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            ans += <span class="number">0.5</span> * <span class="built_in">abs</span>(cross(stk[i] - stk[<span class="number">1</span>], stk[i + <span class="number">1</span>] - stk[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(ans / (<span class="number">50.0</span>))); <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3641 Pseudoprime numbers (数论+快速幂)</title>
    <url>/2019/08/06/POJ-3641-Pseudoprime-numbers-%E6%95%B0%E8%AE%BA-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3641" target="_blank" rel="noopener">POJ 3641</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Fermat’s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)</p>
<p>Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Input contains several test cases followed by a line containing “0 0”. Each test case consists of a line containing p and a.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case, output “yes” if p is a base-a pseudoprime; otherwise output “no”.</p>
</blockquote>
<h2 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">10 3</span><br><span class="line">341 2</span><br><span class="line">341 3</span><br><span class="line">1105 2</span><br><span class="line">1105 3</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $p$ 和 $a$，判断 $p$ 是否为合数且满足 $a^p\equiv a(mod p)$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>水题 快速幂 + 素数判断</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= a / i; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmod</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span> % p;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, p;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;p, &amp;a) &amp;&amp; a + p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime(p) == <span class="number">0</span> &amp;&amp; qmod(a, p, p) == a) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数论</tag>
        <tag>素数</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3468 A Simple Problem with Integers (分块)</title>
    <url>/2019/08/12/POJ-3468-A-Simple-Problem-with-Integers-%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ 3468</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>You have $N$ integers, $A_1, A_2, … , A_N$. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first line contains two numbers $N$ and $Q$. $1 ≤ N,Q ≤ 100000$.</p>
<p>The second line contains $N$ numbers, the initial values of $A_1, A_2, … , A_N$. $-1000000000 \le A_i \le 1000000000$.</p>
<p>Each of the next $Q$ lines represents an operation.</p>
<p>“$C a b c$” means adding c to each of $A_a, A_{a+1},  … , A_b$. $-10000 \le c \le 10000$.</p>
<p>“$Q a b$” means querying the sum of $A_a, A_{a+1},  … , A_b$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>You need to answer all $Q$ commands in order. One answer in a line.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p>The sums may exceed the range of 32-bit integers.</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个数和 $q$ 个询问，询问包含两种：$C a b c$ 代表区间 $[a, b]$ 的每个数加上 $c$，$Q a b$ 输出区间 $[a, b]$ 的和。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>分块</strong></p>
<p>区间更新模板题，本题可以使用树状数组、线段树和分块解决，这里使用的是分块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn], sum[maxn], add[maxn]; <span class="comment">// add[] 是增量标记</span></span><br><span class="line"><span class="keyword">int</span> L[maxn], R[maxn]; <span class="comment">// 存放每个块的左右边界</span></span><br><span class="line"><span class="keyword">int</span> block[maxn]; <span class="comment">// 存放下标为 i 的元素的块号</span></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> block_size; <span class="comment">// 块的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分块 + 预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    block_size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= block_size; ++i) &#123;</span><br><span class="line">        L[i] = (i - <span class="number">1</span>) * block_size + <span class="number">1</span>;</span><br><span class="line">        R[i] = i * block_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后一块</span></span><br><span class="line">    <span class="keyword">if</span>(R[block_size] &lt; n) &#123;</span><br><span class="line">        ++block_size;</span><br><span class="line">        L[block_size] = R[block_size - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        R[block_size] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理每个块的区间和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= block_size; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = L[i]; j &lt;= R[i]; ++j) &#123;</span><br><span class="line">            block[j] = i;</span><br><span class="line">            sum[i] += a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将区间 [l, r] 内的所有元素加 c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = block[l], q = block[r]; <span class="comment">// 取出左右区间所在的块号</span></span><br><span class="line">    <span class="keyword">if</span>(p == q) &#123;</span><br><span class="line">        <span class="comment">// 在同一块直接块内暴力</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            a[i] += c;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[p] += c * (r - l + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不在同一块，块内暴力，块间整块处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt;= q - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            add[i] += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 块内暴力</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= R[p]; ++i) &#123;</span><br><span class="line">            a[i] += c;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[p] += c * (R[p] - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L[q]; i &lt;= r; ++i) &#123;</span><br><span class="line">            a[i] += c;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[q] += c * (r - L[q] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = block[l], q = block[r]; <span class="comment">// 取出左右区间所在的块号</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == q) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            ans += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += add[p] * (r - l + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 块间暴力</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt;= q - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            ans += sum[i] + add[i] * (R[i] - L[i] + <span class="number">1</span>); <span class="comment">// 注意不是乘以 block_size</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 块内暴力</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= R[p]; ++i) &#123;</span><br><span class="line">            ans += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += add[p] * (R[p] - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L[q]; i &lt;= r; ++i) &#123;</span><br><span class="line">            ans += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += add[q] * (r - L[q] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        getchar(); <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">'C'</span>) &#123;</span><br><span class="line">            ll c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;c);</span><br><span class="line">            change(l, r, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="https://book.douban.com/subject/30136932/" target="_blank" rel="noopener">《算法竞赛进阶指南》</a> 李煜东 著</p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3805 Separate Points (判断凸包相交)</title>
    <url>/2019/08/21/POJ-3805-Separate-Points-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3805" target="_blank" rel="noopener">POJ 3805</a></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Numbers of black and white points are placed on a plane. Let’s imagine that a straight line of inﬁnite length is drawn on the plane. When the line does not meet any of the points, the line divides these points into two groups. If the division by such a line results in one group consisting only of black points and the other consisting only of white points, we say that theline “separates black and white points”. </p>
<p>Let’s see examples in Figure 3. In the leftmost example, you can easily ﬁnd that the black and white points can be perfectly separated by the dashed line according to their colors. In the remaining three examples, there exists no such straight line that gives such a separation. </p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/21/1566398980189-1566398980439.png" alt=""></p>
<p>In this problem, given a set of points with their colors and positions, you are requested to decide whether there exists a straight line that separates black and white points.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The input is a sequence of datasets, each of which is formatted as follows. </p>
<pre><code>  n m 
  x1 y1 
  . 
  . 
  . 
  xn yn 
  xn+1 yn+1 
  . 
  . 
  . 
  xn+m yn+m 
</code></pre><p>The ﬁrst line contains two positive integers separated by a single space; n is the number of black points, and m is the number of white points. They are less than or equal to 100. Then n + m lines representing the coordinates of points follow. Each line contains two integers xi and yi separated by a space, where (xi, yi) represents the x-coordinate and the y-coordinate of the i-th point. The color of the i-th point is black for 1 &lt;= i &lt;= n, and is white for n + 1 &lt;= i &lt;= n + m. </p>
<p>All the points have integral x- and y-coordinate values between 0 and 10000 inclusive. You can also assume that no two points have the same position. </p>
<p>The end of the input is indicated by a line containing two zeros separated by a space.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each dataset, output “YES” if there exists a line satisfying the condition. If not, output “NO”. In either case, print it in one line for each input dataset.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">100 700</span><br><span class="line">200 200</span><br><span class="line">600 600</span><br><span class="line">500 100</span><br><span class="line">500 300</span><br><span class="line">800 500</span><br><span class="line">3 3</span><br><span class="line">100 300</span><br><span class="line">400 600</span><br><span class="line">400 100</span><br><span class="line">600 400</span><br><span class="line">500 900</span><br><span class="line">300 300</span><br><span class="line">3 4</span><br><span class="line">300 300</span><br><span class="line">500 300</span><br><span class="line">400 600</span><br><span class="line">100 100</span><br><span class="line">200 900</span><br><span class="line">500 900</span><br><span class="line">800 100</span><br><span class="line">1 2</span><br><span class="line">300 300</span><br><span class="line">100 100</span><br><span class="line">500 500</span><br><span class="line">1 1</span><br><span class="line">100 100</span><br><span class="line">200 100</span><br><span class="line">2 2</span><br><span class="line">0 0</span><br><span class="line">500 700</span><br><span class="line">1000 1400</span><br><span class="line">1500 2100</span><br><span class="line">2 2</span><br><span class="line">0 0</span><br><span class="line">1000 1000</span><br><span class="line">1000 0</span><br><span class="line">0 1000</span><br><span class="line">3 3</span><br><span class="line">0 100</span><br><span class="line">4999 102</span><br><span class="line">10000 103</span><br><span class="line">5001 102</span><br><span class="line">10000 102</span><br><span class="line">0 101</span><br><span class="line">3 3</span><br><span class="line">100 100</span><br><span class="line">200 100</span><br><span class="line">100 200</span><br><span class="line">0 0</span><br><span class="line">400 0</span><br><span class="line">0 400</span><br><span class="line">3 3</span><br><span class="line">2813 1640</span><br><span class="line">2583 2892</span><br><span class="line">2967 1916</span><br><span class="line">541 3562</span><br><span class="line">9298 3686</span><br><span class="line">7443 7921</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>平面上有一些白点和黑点，问是否存在一条直线能把两类点分开。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>模板题。</p>
<p>详见 <a href="https://wutao18.github.io/2019/08/21/UVA-10256-The-Great-Divide-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/">UVA 10256 The Great Divide (判断凸包相交)</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (cross(a, b) &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span> </span>&#123;</span><br><span class="line">    Polygon u, l;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; s.size() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = u.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(u[n - <span class="number">2</span>], u[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.size() ; n &gt;=<span class="number">2</span> &amp;&amp; !isclock(l[n<span class="number">-2</span>],l[n<span class="number">-1</span>],s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线段相交</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),</span><br><span class="line">            c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(cross(p2 - p1, p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Polygon s1, Polygon s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = s1.size(), c2 = s2.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s1[i], s2)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c2; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s2[i], s1)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Intersection(s1[i], s1[(i + <span class="number">1</span>) % c1], s2[j], s2[(j + <span class="number">1</span>) % c2])) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        Polygon s1, s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x1, &amp;x2);</span><br><span class="line">            s1.push_back(Point(x1, x2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x1, &amp;x2);</span><br><span class="line">            s2.push_back(Point(x1, x2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.size()) s1 = Andrew(s1);</span><br><span class="line">        <span class="keyword">if</span>(s2.size()) s2 = Andrew(s2);</span><br><span class="line">        solve(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 1121 Damn Single</title>
    <url>/2019/11/22/PTA-1121-Damn-Single/</url>
    <content><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805352359378944" target="_blank" rel="noopener">1121 Damn Single (25 分)</a></p>
<blockquote>
<p>“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID’s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (≤ 10,000) followed by M ID’s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (重婚) or dangling with more than one companion.</p>
</blockquote>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote>
<p>First print in a line the total number of lonely guests. Then in the next line, print their ID’s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">11111 22222</span><br><span class="line">33333 44444</span><br><span class="line">55555 66666</span><br><span class="line">7</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10000 23333 44444 55555 88888</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定情侣关系，然后给出一次宴会上出席的人，问这些人中有多少单身狗 (伴侣没来的也算)。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>记录情侣关系，然后找出出席的人中不在情侣关系中的人以及伴侣没有来的人即可。</p>
<p>注意输出要补零，最后一行不用换行。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> couple[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        couple[x] = y;</span><br><span class="line">        couple[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; party;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        party.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = couple[party[i]];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="number">-1</span>) &#123;</span><br><span class="line">            ans.insert(party[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(party.begin(), party.end(), tmp) == party.end()) &#123;</span><br><span class="line">                ans.insert(party[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.begin(); it != ans.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it != ans.begin()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, *it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3974 Palindrome (Manacher)</title>
    <url>/2019/11/14/POJ-3974-Palindrome-Manacher/</url>
    <content><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3974" target="_blank" rel="noopener">POJ 3974</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?”</p>
<p>A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not.</p>
<p>The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”.</p>
<p>If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>Your program will be tested on at most 30 test cases, each test case is given as a string of at most 1000000 lowercase characters on a line by itself. The input is terminated by a line that starts with the string “END” (quotes for clarity).</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>For each test case in the input print the test case number and the length of the largest palindrome.</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Seventh+ACM+Egyptian+National+Programming+Contest" target="_blank" rel="noopener">Seventh ACM Egyptian National Programming Contest</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串，求最长回文子串。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Manacher 模板题。</p>
<p>有关 Manacher 算法的讲解见<a href="https://wutao18.github.io/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/">这里</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;</span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"END"</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp = init(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; (++kase) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher(tmp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 1067 Sort with Swap(0, i) (贪心)</title>
    <url>/2019/11/16/PTA-1067-Sort-with-Swap-0-i-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h1 id="PTA-1067-Sort-with-Swap-0-i-贪心"><a href="#PTA-1067-Sort-with-Swap-0-i-贪心" class="headerlink" title="PTA 1067 Sort with Swap(0, i) (贪心)"></a>PTA 1067 Sort with Swap(0, i) (贪心)</h1><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805403651522560" target="_blank" rel="noopener">1067 Sort with Swap(0, i) (25 分)</a></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/16/1573916930346-1573916930573.png" alt=""></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $n$ 的排列，如果每次只能把某个数和第 $0$ 个数交换，那么要使排列是升序的最少需要交换几次。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>贪心</strong></p>
<p>由于是排列，所以排序后第 $i$ 个位置上的数就是 $i$。所以当 $a[0] \neq 0$ 时，把 $a[0]$ 位置上的元素交换到相应位置。如果 $a[0] = 0$，就找到第一个不在正确位置上的数，把它与第 $0$ 个数交换，那么下一次又是第一种情况了，也就是下一次交换可以换到正确的位置。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            swap(arr[<span class="number">0</span>], arr[arr[<span class="number">0</span>]]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; c &lt; n &amp;&amp; arr[c] == c; ++c);</span><br><span class="line">            <span class="keyword">if</span> (c == n) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr[<span class="number">0</span>], arr[c]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 1154 Vertex Coloring</title>
    <url>/2019/11/20/PTA-1154-Vertex-Coloring/</url>
    <content><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552" target="_blank" rel="noopener">1154 Vertex Coloring</a></p>
<blockquote>
<p>A <strong>proper vertex coloring</strong> is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most $k$ colors is called a (proper) $k$-<strong>coloring</strong>.</p>
<p>Now you are supposed to tell if a given coloring is a proper $k$-coloring.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote>
<p>Each input file contains one test case. For each case, the first line gives two positive integers $N$ and $M$ (both no more than $10​^4$), being the total numbers of vertices and edges, respectively. Then $M$ lines follow, each describes an edge by giving the indices (from $0$ to $N−1$) of the two ends of the edge.</p>
<p>After the graph, a positive integer $K (≤ 100)$ is given, which is the number of colorings you are supposed to check. Then $K$ lines follow, each contains $N$ colors which are represented by non-negative integers in the range of <strong>int</strong>. The $i$-th color is the color of the $i$-th vertex.</p>
</blockquote>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote>
<p>For each coloring, print in a line <code>k-coloring</code> if it is a proper <code>k</code>-coloring for some positive <code>k</code>, or <code>No</code> if not.</p>
</blockquote>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 11</span><br><span class="line">8 7</span><br><span class="line">6 8</span><br><span class="line">4 5</span><br><span class="line">8 4</span><br><span class="line">8 1</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">9 8</span><br><span class="line">9 1</span><br><span class="line">1 0</span><br><span class="line">2 4</span><br><span class="line">4</span><br><span class="line">0 1 0 1 4 1 0 1 3 0</span><br><span class="line">0 1 0 1 4 1 0 1 0 0</span><br><span class="line">8 1 0 1 4 1 0 5 3 0</span><br><span class="line">1 2 3 4 5 6 7 8 8 9</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4-coloring</span><br><span class="line">No</span><br><span class="line">6-coloring</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个图，以及每个顶点的颜色，问是否所有边连接的两个顶点颜色不同。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举每一条边即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edges[maxn];</span><br><span class="line"><span class="keyword">int</span> colors[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        edges[i] = &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; colors[i];</span><br><span class="line">            mp[colors[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = edges[i].first, y = edges[i].second;</span><br><span class="line">            <span class="keyword">if</span>(colors[x] == colors[y]) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mp.size() &lt;&lt; <span class="string">"-coloring"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>STL</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA 1155 Heap Paths (DFS)</title>
    <url>/2019/11/19/PTA-1155-Heap-Paths-DFS/</url>
    <content><![CDATA[<p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552" target="_blank" rel="noopener">1155 Heap Paths (30 分)</a></p>
<blockquote>
<p>In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure</a>))</p>
<p>One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.</p>
<p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><blockquote>
<p>Each input file contains one test case. For each case, the first line gives a positive integer $N (1&lt;N≤1,000)$, the number of keys in the tree. Then the next line contains $N$ distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.</p>
</blockquote>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><blockquote>
<p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p>
<p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p>
</blockquote>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">98 72 86 60 65 12 23 50</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">98 86 23</span><br><span class="line">98 86 12</span><br><span class="line">98 72 65</span><br><span class="line">98 72 60 50</span><br><span class="line">Max Heap</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">8 38 25 58 52 82 70 60</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8 25 70</span><br><span class="line">8 25 82</span><br><span class="line">8 38 52</span><br><span class="line">8 38 58 60</span><br><span class="line">Min Heap</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">10 28 15 12 34 9 8 56</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10 15 8</span><br><span class="line">10 15 9</span><br><span class="line">10 28 34</span><br><span class="line">10 28 12 56</span><br><span class="line">Not Heap</span><br></pre></td></tr></table></figure>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为 $N$ 的数组，输出从根节点到叶子结点的每一条路径，并且判断是否是堆。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接 dfs 输出路径。设立两个变量 Max 和 Min 统计父节点比子节点大的个数和父节点比子节点小的个数。如果两者都不为 0，说明不是堆；如果 Max 为 0，说明是小顶堆，如果 Min 为 0，说明是大顶堆。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">11</span>];  <span class="comment">// 保存路径</span></span><br><span class="line"><span class="keyword">int</span> Max = <span class="number">0</span>, Min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    path[step] = arr[id];</span><br><span class="line">    <span class="keyword">if</span>(id * <span class="number">2</span> &gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; step; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; path[step] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = id * <span class="number">2</span>, r = id * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 左右儿子结点</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &lt; arr[r]) ++Min;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &gt; arr[r]) ++Max;</span><br><span class="line">        dfs(step + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &lt; arr[l]) ++Min;</span><br><span class="line">        <span class="keyword">if</span>(path[step] &gt; arr[l]) ++Max;</span><br><span class="line">        dfs(step + <span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(Min == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Max == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Min Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>DFS</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 11178 Morley&#39;s Theorem (坐标旋转)</title>
    <url>/2019/09/29/UVA-11178-Morley-s-Theorem-%E5%9D%90%E6%A0%87%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2119" target="_blank" rel="noopener">UVA 11178</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/29/1569766714859-1569766715112.png" alt=""></p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/29/1569766740964-1569766740967.png" alt=""></p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/29/1569766756808-1569766756811.png" alt=""></p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/29/1569766784719-1569766784723.png" alt=""></p>
</blockquote>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/09/29/1569766801693-1569766801695.png" alt=""></p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$Morley’s theorem$ 指任意三角形的每个内角的三等分线相交的三角形为等边三角形。</p>
<p>给出三角形的每个点的坐标，求根据 $Morley’s theorem$ 构造的等边三角形的三个点的坐标。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于点 $D$，只需求直线 $BC$ 绕点 $B$ 旋转 $\frac{1}{3} \angle ABC$ 的直线与直线 $CB$ 绕点 $C$ 旋转 $\frac{1}{3} \angle ACB$ 的直线的交点。其他两点类似。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(y - a.y))? dcmp(x - a.x) &lt; <span class="number">0</span>: y &lt; a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>(dot(a) / (a.dis() * dis()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * <span class="built_in">cos</span>(rad) - y * <span class="built_in">sin</span>(rad), x * <span class="built_in">sin</span>(rad) + y * <span class="built_in">cos</span>(rad));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;s.x, &amp;s.y, &amp;e.x, &amp;e.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		<span class="keyword">double</span> a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        <span class="keyword">double</span> x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">double</span> y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_crosspoint</span><span class="params">(Point A, Point B, Point C)</span> </span>&#123;</span><br><span class="line">    Vector v1 = C - B;</span><br><span class="line">    db a1 = v1.ang(A - B);</span><br><span class="line">    v1 = v1.Rotate(a1 / <span class="number">3.0</span>);</span><br><span class="line">    v1 = v1 + B;</span><br><span class="line">    Vector v2 = B - C;</span><br><span class="line">    db a2 = v2.ang(A - C);</span><br><span class="line">    v2 = v2.Rotate(-a2 / <span class="number">3.0</span>);</span><br><span class="line">    v2 = v2 + C;</span><br><span class="line">    Line l1 = Line(B, v1);</span><br><span class="line">    Line l2 = Line(C, v2);</span><br><span class="line">    <span class="keyword">return</span> l1.crosspoint(l2); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        Point a, b, c;</span><br><span class="line">        a.input(); b.input(); c.input();</span><br><span class="line">        Point d, e, f;</span><br><span class="line">        d = get_crosspoint(a, b, c);</span><br><span class="line">        e = get_crosspoint(b, c, a);</span><br><span class="line">        f = get_crosspoint(c, a, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.6lf %.6lf %.6lf %.6lf %.6lf %.6lf\n"</span>, d.x, d.y, e.x, e.y, f.x, f.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>坐标旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 10256 The Great Divide (判断凸包相交)</title>
    <url>/2019/08/21/UVA-10256-The-Great-Divide-%E5%88%A4%E6%96%AD%E5%87%B8%E5%8C%85%E7%9B%B8%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1197" target="_blank" rel="noopener">UVA 10256</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个红点和m个蓝点,问是否存在一条直线能够分开红点和蓝点。</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>分别求出红点和蓝点的凸包，判断两个凸包是否相交。</p>
<p>凸包不相交的条件：</p>
<ul>
<li>凸包上的任意点都在另一个凸包的外面</li>
<li>凸包的任意线段都与另一个凸包不相交</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (cross(a, b) &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span> </span>&#123;</span><br><span class="line">    Polygon u, l;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.size() - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; s.size() ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = u.size() ; n &gt;= <span class="number">2</span> &amp;&amp; !isclock(u[n - <span class="number">2</span>], u[n - <span class="number">1</span>], s[i]); --n) &#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.size() ; n &gt;=<span class="number">2</span> &amp;&amp; !isclock(l[n<span class="number">-2</span>],l[n<span class="number">-1</span>],s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.size() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线段相交</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),</span><br><span class="line">            c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(cross(p2 - p1, p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Polygon s1, Polygon s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = s1.size(), c2 = s2.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s1[i], s2)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c2; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s2[i], s1)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Intersection(s1[i], s1[(i + <span class="number">1</span>) % c1], s2[j], s2[(j + <span class="number">1</span>) % c2])) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        Polygon s1, s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x1, &amp;x2);</span><br><span class="line">            s1.push_back(Point(x1, x2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x1, &amp;x2);</span><br><span class="line">            s2.push_back(Point(x1, x2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.size()) s1 = Andrew(s1);</span><br><span class="line">        <span class="keyword">if</span>(s2.size()) s2 = Andrew(s2);</span><br><span class="line">        solve(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://book.douban.com/subject/20254543/" target="_blank" rel="noopener">《算法竞赛入门经典》 刘汝佳 / 陈锋 </a></p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ VFMUL - Very Fast Multiplication (FFT)</title>
    <url>/2019/09/18/SPOJ-VFMUL-Very-Fast-Multiplication-FFT/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.spoj.com/problems/VFMUL/en/" target="_blank" rel="noopener">VFMUL - Very Fast Multiplication</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Multiply the given numbers.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>n [the number of multiplications &lt;= 101]</p>
<p>l1 l2 [numbers to multiply (at most 300000 decimal digits each)]</p>
<p>Text grouped in [ ] does not appear in the input file.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The results of multiplications.</p>
</blockquote>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">5</span><br><span class="line">4 2</span><br><span class="line">123 43</span><br><span class="line">324 342</span><br><span class="line">0 12</span><br><span class="line">9999 12345</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">8</span><br><span class="line">5289</span><br><span class="line">110808</span><br><span class="line">0</span><br><span class="line">123437655</span><br></pre></td></tr></table></figure>
<p><strong>Warning: large Input/Output data, be careful with certain languages</strong></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求两数的乘积</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>FFT</strong></p>
<p>FFT 求高精度乘法的模板题。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; Complex;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Complex a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">2</span>, rev[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rev, <span class="number">0</span>, <span class="keyword">sizeof</span>(rev));</span><br><span class="line">    <span class="keyword">while</span>(bit &lt;= n + m) bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | (bit &gt;&gt; <span class="number">1</span>) * (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; bit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(PI / mid), op * <span class="built_in">sin</span>(PI / mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit; j += mid&lt;&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k, w = w * wn) &#123;</span><br><span class="line">                Complex x = a[j + k], y = w * a[j + k + mid];</span><br><span class="line">                a[j + k] = x + y, a[j + k + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">        <span class="built_in">string</span> s1, s2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        n = s1.size(), m = s2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a[i] = s1[n - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            b[i] = s2[m - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        get_rev();</span><br><span class="line">        FFT(a, <span class="number">1</span>);</span><br><span class="line">        FFT(b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) &#123;</span><br><span class="line">            a[i] *= b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        FFT(a, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; ++i) &#123;</span><br><span class="line">            ans[i] = (<span class="keyword">int</span>)(a[i].real() / bit + <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + m; ++i) &#123;</span><br><span class="line">            ans[i] = ans[i] + ans[i - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">            ans[i - <span class="number">1</span>] = ans[i - <span class="number">1</span>] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = n + m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; s &gt;= <span class="number">0</span>; --s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[s]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>模板题</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ MAXMATCH - Maximum Self-Matching (FFT)</title>
    <url>/2019/09/24/SPOJ-MAXMATCH-Maximum-Self-Matching-FFT/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.spoj.com/problems/MAXMATCH/en/" target="_blank" rel="noopener">MAXMATCH - Maximum Self-Matching</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>You’re given a string <strong>s</strong> consisting of letters ‘a’, ‘b’ and ‘c’.</p>
<p>The matching function $m_s( i )$ is defined as the number of matching characters of <strong>s</strong> and its i-shift. In other words, $m_s( i )$ is the number of characters that are matched when you align the 0-th character of <strong>s</strong> with the i-th character of its copy.</p>
<p>You are asked to compute the maximum of $m_s( i )$ for all i ( 1 &lt;= i &lt;= |<strong>s</strong>| ). To make it a bit harder, you should also output all the optimal i’s in increasing order.</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>The first and only line of input contains the string <strong>s</strong>. $2 \le |s| \le 10^5$.</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>The first line of output contains the maximal $m_s( i )$ over all i.</p>
<p>The second line of output contains all the i’s for which $m_s( i )$ reaches maximum.</p>
</blockquote>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">caccacaa</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">caccacaa</span><br><span class="line">   caccacaa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> The bold characters indicate the ones that match when shift = 3.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串 $s$ (下标从 $0$ 开始，只包含 ‘a’, ‘b’, ‘c’)，让 $s$ 与 $s$ 匹配，下标从 $1$ 移动到 $|s|$，每次匹配时的相同的字符个数记为 $m_s( i )$，求 $m_s( i )$ 的最大值，以及最大值所匹配的所有位置。</p>
<p>比如 ababa</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ababa</span><br><span class="line"> ababa</span><br><span class="line">  ababa</span><br><span class="line">   ababa</span><br><span class="line">    ababa</span><br></pre></td></tr></table></figure>
<p>$m_s( i )$ 分别为 $0, 3, 0, 1$，最大值为 $3$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>FFT</strong></p>
<p>字符串匹配问题。</p>
<p>设模式串为 $p$，目标串为 $t$，$f[k]$ 为模式串从目标串第 $k$ 位开始匹配的结果。</p>
<p>对 $a$，$b$，$c$ 分开求。</p>
<p>首先判断 $a$ 的情况，将字符串转化为 01 串，比如 ababa 转为 10101。</p>
<p>那么</p>
<script type="math/tex; mode=display">f[k] = \sum_{i=0}^{|s|-k-1} p[i] \cdot t[k + i]</script><script type="math/tex; mode=display">f[k] = \sum_{i=k}^{|s|-1} p[i - k] \cdot t[i]</script><p>将模式串倒置，有</p>
<script type="math/tex; mode=display">f[k] = \sum_{i=k}^{|s|-1} p[|s| - 1 - i + k] \cdot t[i]</script><p>令 $j = |s| - 1 - i + k$，有</p>
<script type="math/tex; mode=display">f[k] = \sum_{i+j=|s|-1+k} p[j] \cdot t[i]</script><p>用 $FFT$ 求一下卷积即可。</p>
<p>对于 $b$ 和 $c$ 的求法相同。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; Complex;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Complex p[maxn], t[maxn];</span><br><span class="line">Complex a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">2</span>, rev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rev, <span class="number">0</span>, <span class="keyword">sizeof</span>(rev));</span><br><span class="line">    <span class="keyword">while</span>(bit &lt;= n + n) bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | (bit &gt;&gt; <span class="number">1</span>) * (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *arr, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) swap(arr[i], arr[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; bit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(PI / mid), op * <span class="built_in">sin</span>(PI / mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit; j += mid&lt;&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k, w = w * wn) &#123;</span><br><span class="line">                Complex x = arr[j + k], y = w * arr[j + k + mid];</span><br><span class="line">                arr[j + k] = x + y, arr[j + k + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    n = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        p[n - i - <span class="number">1</span>] = str[i] == <span class="string">'a'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        t[i] = p[n - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    get_rev();</span><br><span class="line">    FFT(p, <span class="number">1</span>); FFT(t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        a[i] = p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        p[n - i - <span class="number">1</span>] = str[i] == <span class="string">'b'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        t[i] = p[n - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; bit; ++i) &#123;</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">        t[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(p, <span class="number">1</span>); FFT(t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        b[i] = p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(b, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        p[n - i - <span class="number">1</span>] = str[i] == <span class="string">'c'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        t[i] = p[n - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; bit; ++i) &#123;</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">        t[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(p, <span class="number">1</span>); FFT(t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        c[i] = p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(c, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans[i] = (<span class="keyword">int</span>)(a[n - <span class="number">1</span> + i].real() / bit + <span class="number">0.5</span>) + (<span class="keyword">int</span>)(b[n - <span class="number">1</span> + i].real() / bit + <span class="number">0.5</span>) + (<span class="keyword">int</span>)(c[n - <span class="number">1</span> + i].real() / bit + <span class="number">0.5</span>); </span><br><span class="line">        maxa = max(maxa, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] == maxa) &#123;</span><br><span class="line">            pos.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxa &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pos[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用过程与栈帧结构</title>
    <url>/2020/10/29/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="进程内存布局"><a href="#进程内存布局" class="headerlink" title="进程内存布局"></a>进程内存布局</h2><p>32 位保护模式下 Linux 中进程的内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0xFFFFFFFF  ------&gt; +----------------------+ &lt;--+ </span><br><span class="line">                    |                      |    | </span><br><span class="line">                    |       OS Kernel      |    | 1GB</span><br><span class="line">                    |                      |    |</span><br><span class="line">0xC0000000  ------&gt; +----------------------+ &lt;--+ </span><br><span class="line">                |   |                      |    |</span><br><span class="line">                |   |         stack        |    |</span><br><span class="line">                v   |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    | Memory Mapping Region|    |</span><br><span class="line">0x40000000  ------&gt; +----------------------+    |</span><br><span class="line">                    |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                ^   |                      |    |</span><br><span class="line">                |   |         heap         |    | 3GB</span><br><span class="line">                |   |                      |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    |  Read&#x2F;Write Segments |    |</span><br><span class="line">                    |        .bss          |    |</span><br><span class="line">                    |        .data         |    |</span><br><span class="line">                    +----------------------+    |</span><br><span class="line">                    |  Read-only Segments  |    |</span><br><span class="line">                    | .init .text .rodata  |    |</span><br><span class="line">                    |                      |    |</span><br><span class="line">0x08048000  ------&gt; +----------------------+    |</span><br><span class="line">                    |       reserved       |    |</span><br><span class="line">0x00000000  ------&gt; +----------------------+ &lt;--+</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>32 位下寻址空间为 4GB，其中高地址的 1GB 是给操作系统内核使用的（Windows 中默认为 2GB），称为<strong>内核空间</strong>（Kernel Space），剩余的 3GB 分配给应用程序使用，称为<strong>用户空间</strong>（User Space）。当进程运行在内核空间时就处于<strong>内核态</strong>（Kernel Mode），当进程运行在用户空间时就处于<strong>用户态</strong>（User Mode）。</p>
<p>区分用户态和内核态是为了提高系统的稳定性和安全性，使操作系统能够控制资源的访问，能够防止应用程序执行一些危险的指令。计算机体系结构中，在硬件上提供不同的特权态，即 Rings Protection，如 Intel CPU 有 4 个特权级：Ring0、Ring1、Ring2、Ring3，一般操作系统只使用 Ring0 和 Ring3，Ring0 具有最高权限，能够访问任何资源，Ring3 访问受限，需要陷入（trap）到内核态才能访问特权资源。</p>
<p><strong>栈</strong>（stack）从虚拟地址 <code>0xC0000000</code> 往低地址增长。<strong>堆</strong>（heap）正好相反，从低地址往高地址增长。栈用于函数调用以及存放局部变量等，堆用于动态内存分配，如 C 语言中的 malloc() 函数。栈与操作系统内核之间有一个随机的 offset，堆与读/写段之间也有一个随机的 offset。</p>
<p><strong>内存映射段</strong>（Memory Mapping Segment）用于将文件内容映射到内存，用于加载动态链接库，可以通过 mmap() 系统调用实现内存映射。</p>
<p><strong>bss 段</strong>放的是未初始化的全局变量和静态变量，默认都初始化为 0，<strong>data 段</strong>存放的是初始化的全局变量和静态变量。</p>
<p><strong>text 段</strong>存放的是程序代码，除了可读还具有可执行权限。</p>
<h2 id="栈及其操作"><a href="#栈及其操作" class="headerlink" title="栈及其操作"></a>栈及其操作</h2><p>栈是一种先进后出的结构，包含两种操作：<code>push</code> 和 <code>pop</code>。</p>
<p>在 IA-32 体系结构中，通常用 <code>ESP</code> 和 <code>EBP</code> 维护一个栈，<code>EBP</code> 指向栈底，<code>ESP</code> 指向栈顶。</p>
<p>IA-32 中 <code>PUSH</code> 指令先减少 <code>ESP</code> 的值，再将源操作数复制到堆中。</p>
<p>如 <code>PUSH EAX</code> 等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SUB ESP, 4</span><br><span class="line">MOV [ESP], EAX</span><br></pre></td></tr></table></figure>
<p><code>POP</code> 指令正好相反，如 <code>POP EBX</code> 等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV EBX, [ESP]</span><br><span class="line">ADD ESP, 4</span><br></pre></td></tr></table></figure>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈帧</strong>（stack frame）用于函数调用，每一次函数调用都会有一个独立的栈帧，包含了返回地址、局部变量、上下文等信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address        </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">   +------&gt; |    previous EBP    |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |  saved registers   |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |  local variables   |    | caller&#39;s frame</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |   callee&#39;s args    |    |</span><br><span class="line">   |        +--------------------+    |</span><br><span class="line">   |        |   return address   |    |</span><br><span class="line">   |        +--------------------+ &lt;--+</span><br><span class="line">   +------- |    previous EBP    |    |</span><br><span class="line">            +--------------------+    | </span><br><span class="line">            |  local variables   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |                    |    | callee&#39;s frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p><strong>调用者</strong>（Caller） 调用 <strong>被调用者</strong>（Callee），每次调用都会有新的栈帧压栈，所以一般深度优先搜索可以用栈来代替递归，以达到更深的搜索深度。</p>
<p><code>ESP</code> 和 <code>EBP</code> 只维护当前的栈帧，因此之前的栈帧都要保存下来，栈帧的顶部保存了上一个栈帧的 <code>EBP</code> 指向的位置，函数返回时 <code>EBP</code> 能够恢复到上一个栈帧的 <code>EBP</code>。</p>
<h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>调用者 调用 被调用者 前，先保存返回地址，即下一条指令的地址，用于返回后继续执行，然后进入被调用者函数。</p>
<p>被调用者开辟了新的栈帧，因此需要保存调用者的栈帧，通常使用以下两条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP, ESP</span><br></pre></td></tr></table></figure>
<p>先把旧的 <code>EBP</code> 入栈，然后让 <code>EBP</code> 指向旧的 <code>EBP</code>，此时 <code>EBP</code> 已经作为新的栈帧的栈底了。</p>
<p>函数调用时，为了防止寄存器被覆盖，有时需要将寄存器内容也保存到栈中。</p>
<h3 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h3><p>IA-32 下，在调用者函数中，参数从右往左入栈。进入被调用者函数时，参数以及局部变量的访问以 <code>EBP</code> 为基址，通过 <code>EBP</code> 加上偏移量访问。</p>
<p>x86-64 下参数传递略有不同。如果函数调用参数少于 7 个，则用寄存器传递参数，参数从左到右依次放入寄存器 <code>RDI</code>，<code>RSI</code>，<code>RDX</code>，<code>RCX</code>，<code>R8</code>，<code>R9</code>。参数超过 7 个时，前 6 个参数同样通过寄存器传参，之后的参数与 32 位一样从右往左压入栈中。</p>
<h3 id="返回过程"><a href="#返回过程" class="headerlink" title="返回过程"></a>返回过程</h3><p>返回值保存在 EAX 寄存器中。</p>
<p>返回时先将 <code>EBP</code> 恢复至上一个栈帧的栈底，通常使用以下两条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV ESP, EBP</span><br><span class="line">POP EBP</span><br></pre></td></tr></table></figure>
<p>然后将保存的返回地址放入 <code>EIP</code> 寄存器。</p>
<p>最后将保存的参数出栈。</p>
<h3 id="涉及的指令"><a href="#涉及的指令" class="headerlink" title="涉及的指令"></a>涉及的指令</h3><ul>
<li><code>CALL</code> 指令</li>
</ul>
<p>先将当前 EIP（即下一条指令的地址作为返回地址）压入栈中，然后 EIP 转移到被调用者的入口地址。</p>
<ul>
<li><code>RET</code> 指令</li>
</ul>
<p>从栈顶弹出原来保存的地址至 EIP。</p>
<ul>
<li><code>LEAVE</code> 指令</li>
</ul>
<p>通常将返回时涉及的两条指令用 <code>LEAVE</code> 指令代替，也就是说 <code>LEAVE</code> 等价于上述提到的两条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV ESP, EBP</span><br><span class="line">POP EBP</span><br></pre></td></tr></table></figure>
<h3 id="函数的调用约定"><a href="#函数的调用约定" class="headerlink" title="函数的调用约定"></a>函数的调用约定</h3><p>上述参数从右往左入栈、返回值存入 <code>EAX</code> 寄存器等不是硬性规定的，而是遵守函数的<strong>调用约定</strong>（calling convention）。函数的调用约定规定了参数的传递顺序、参数和返回值放置的位置、调用前后设置的工作由调用者完成还是被调用者完成等。上文提到的都是 C 调用约定（cdecl调用约定）。其他的调用约定有 stdcall调用约定、fastcall调用约定、thiscall调用约定等。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>以一个加法函数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: add.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成 32 位程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc add.c -o add -m32</span><br></pre></td></tr></table></figure>
<p>查看汇编代码（汇编代码可以用 gdb、objdump、IDA 等工具查看，也可以直接用 gcc 编译成汇编代码）。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100353.png" alt="20201029100353"></p>
<p>输入 <code>layout asm</code> 查看汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100438.png" alt="20201029100438"></p>
<p>进入 main() 函数后，先保存上一个栈帧的 <code>EBP</code>（main 函数不是第一个被调用的函数）。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100601.png" alt="20201029100601"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                </span><br><span class="line">    high address      </span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |                    |    | </span><br><span class="line">                |       ......       |    | previous frame</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">ESP,EBP ------&gt; |    previous EBP    |    | main()&#39;s frame</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">    low address</span><br></pre></td></tr></table></figure>
<p>然后保存寄存器。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100700.png" alt="20201029100700"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">ESP ------&gt; |  saved registers   |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>开辟一定的空间保存局部变量。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029100959.png" alt="20201029100959"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>压入 add() 函数的参数。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101023.png" alt="20201029101023"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    | main()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |         1          |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>call add() 函数，先保存下一条指令的地址，然后跳转到 add() 函数。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101150.png" alt="20201029101150"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>进入 add() 函数，先保存 main() 函数的 <code>EBP</code>。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101222.png" alt="20201029101222"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                </span><br><span class="line">    high address      </span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |                    |    | </span><br><span class="line">                |       ......       |    | previous frame</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |    previous EBP    |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |  saved registers   |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       ......       |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |        b&#x3D;2         |    |</span><br><span class="line">                +--------------------+    | main()&#39;s frame</span><br><span class="line">                |        a&#x3D;1         |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         2          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         1          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       0x122b       |    |</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">ESP,EBP ------&gt; |    previous EBP    |    | add()&#39;s frame</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">    low address</span><br></pre></td></tr></table></figure>
<p>开辟空间用以保存局部变量。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101315.png" alt="20201029101315"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |   saved registers  |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    | add()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>通过 <code>EBP</code> 加上偏移获取 add() 函数的两个参数，然后求和，结果保存在 <code>EAX</code> 寄存器（<code>EAX</code> 是累加寄存器）。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101353.png" alt="20201029101353"></p>
<p>累加结果放入局部变量 c。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101417.png" alt="20201029101417"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |   saved registers  |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        c&#x3D;3         |    |</span><br><span class="line">            +--------------------+    | add()&#39;s frame</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>将 c 的值放入 <code>EAX</code> 寄存器作为返回值。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101503.png" alt="20201029101503"></p>
<p>然后 add() 函数返回，先执行 <code>LEAVE</code> 指令，恢复 main() 函数的 <code>EBP</code>。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101534.png" alt="20201029101534"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV ESP, EBP</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                </span><br><span class="line">    high address      </span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |                    |    | </span><br><span class="line">                |       ......       |    | previous frame</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+ </span><br><span class="line">                |    previous EBP    |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |  saved registers   |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       ......       |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |        b&#x3D;2         |    |</span><br><span class="line">                +--------------------+    | main()&#39;s frame</span><br><span class="line">                |        a&#x3D;1         |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         2          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |         1          |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |       0x122b       |    |</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">ESP,EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |        c&#x3D;3         |    |</span><br><span class="line">                +--------------------+    | add()&#39;s frame</span><br><span class="line">                |       ......       |    |</span><br><span class="line">                +--------------------+    |</span><br><span class="line">                |                    |    |</span><br><span class="line">                +--------------------+ &lt;--+</span><br><span class="line">    low address</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POP EBP</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    | main()&#39;s frame</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         1          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |       0x122b       |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">            |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        c&#x3D;3         |    |</span><br><span class="line">            +--------------------+    | add()&#39;s frame</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>RET</code> 指令，将返回地址赋给 <code>EIP</code>，从 add() 函数返回至 main() 函数，<code>EIP</code> 的值为 <code>0x122b</code>，即下一条指令为 main() 函数的 <code>ADD ESP, 0x8</code></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101613.png" alt="20201029101613"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |  saved registers   |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    | main()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |         2          |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |         1          |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>执行 <code>ADD ESP, 0x8</code>，清除 add() 函数的两个参数。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029101641.png" alt="20201029101641"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">high address      </span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">            |                    |    | </span><br><span class="line">            |       ......       |    | previous frame</span><br><span class="line">            |                    |    |</span><br><span class="line">            +--------------------+ &lt;--+ </span><br><span class="line">EBP ------&gt; |    previous EBP    |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |   saved registers  |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |       ......       |    | main()&#39;s frame</span><br><span class="line">            +--------------------+    |</span><br><span class="line">            |        b&#x3D;2         |    |</span><br><span class="line">            +--------------------+    |</span><br><span class="line">ESP ------&gt; |        a&#x3D;1         |    |</span><br><span class="line">            +--------------------+ &lt;--+</span><br><span class="line">low address</span><br></pre></td></tr></table></figure>
<p>至此 add() 函数的调用完成，可以在 main() 函数继续执行之后的指令了。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>应用程序无法调用内核函数，需要通过<strong>系统调用</strong>陷入到内核态，由操作系统执行。</p>
<p>系统调用通过 <code>INT 0x80</code> 中断实现，不同的系统调用有不同的系统调用号，系统调用号需放在 <code>EAX</code> 寄存器中。</p>
<p>系统调用号在 /usr/include/asm/unistd.h 中定义。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029132816.png" alt="20201029132816"></p>
<p>查看 i386 体系结构下的系统调用号：</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20201029133124.png" alt="20201029133124"></p>
<p>陷入到内核态前需要保护现场，将寄存器、程序计数器压入<strong>内核栈</strong>，然后调用相应的内核函数（系统调用）。内核函数执行完成后，将返回值放入 <code>EAX</code> 寄存器，然后恢复现场，将寄存器、程序计数器从<strong>内核栈</strong>恢复，<br>然后恢复到用户态。保护现场和恢复现场均由中断处理程序完成。</p>
<p>系统调用参数传递与函数调用参数传递略有不同，当系统调用参数不超过 6 个时，参数从左到右放到寄存器 <code>EBX</code>，<code>ECX</code>，<code>EDX</code>，<code>ESI</code>，<code>EDI</code> ，<code>EBP</code> 中，如果参数超过 6 个，所有参数应该放在一块连续的内存区域里（C 结构体），用寄存器 <code>EBX</code> 保存指向该内存区域的指针。</p>
<p>应用程序一般通过 API 去完成系统调用。API 与 系统调用 不同，一个 API 可能调用多个系统调用，不同的 API 也可能调用同一个系统调用。</p>
<p>基本的流程可以概括为：</p>
<ul>
<li>应用程序调用 API</li>
<li>API 将系统调用号存入 <code>EAX</code>，然后通过中断调用系统调用</li>
<li>中断处理程序保存寄存器至内核栈，陷入内核态，根据系统调用号调用对应的内核函数</li>
<li>内核函数完成工作，保存返回值至 <code>EAX</code></li>
<li>中断处理程序从内核栈恢复寄存器，恢复到用户态，返回到 API</li>
<li>API 将 <code>EAX</code> 返回给应用程序</li>
</ul>
<p>系统调用的跟踪可用 strace 工具。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.bilibili.com/video/BV1U7411z7Ki" target="_blank" rel="noopener">CTF Linux pwn快速入门 - 哔哩哔哩</a></p>
<p><a href="https://mooc.study.163.com/course/1000029000?tid=2403023011&amp;_trace_c_p_k2_=a5ca10da464e4706ba97d6b676a259e8#/info" target="_blank" rel="noopener">Linux 内核分析 - 网易云课堂</a></p>
<p><a href="https://book.douban.com/subject/19973015//" target="_blank" rel="noopener">《Operating Systems: Three Easy Pieces》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
        <tag>CTF学习</tag>
        <tag>PWN</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code 修改字体</title>
    <url>/2019/10/12/Visual-Studio-Code-%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<p>下载安装想要更换的字体，这里以 Fira Code 字体为例。</p>
<p>Fira Code 字体的下载地址：<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">https://github.com/tonsky/FiraCode</a></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/12/1570885420411-1570885420413.png" alt=""></p>
<p>下载解压后安装字体，windows 可以选择 ttf 文件夹，安装里面的全部字体。</p>
<p>打开 VSC，点击左下角的图标，选择 Settings，然后搜索font，在 Font Family 加上 “Fira Code”。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/12/1570884843223-1570884843228.png" alt=""></p>
<p>重启 VS code 就能看到字体设置成功了。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/12/1570884854520-1570884854522.png" alt=""></p>
<p>注：</p>
<p>settings 中 Font Size 可以修改字体大小</p>
<p>Font Ligatures 启用连字</p>
<p>Font Size 控制字号</p>
<p>Font Weight 控制字体粗细</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>华东交通大学2018年ACM“双基”程序设计竞赛 C. 公式题 (2) (矩阵快速幂)</title>
    <url>/2019/08/27/%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A62018%E5%B9%B4ACM%E2%80%9C%E5%8F%8C%E5%9F%BA%E2%80%9D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-C-%E5%85%AC%E5%BC%8F%E9%A2%98-2-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/221/C" target="_blank" rel="noopener">公式题 (2)</a></p>
<p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/221#question" target="_blank" rel="noopener">华东交通大学2018年ACM“双基”程序设计竞赛</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>令f(n)=2<em>f(n-1)+3</em>f(n-2)+n,f(1)=1,f(2)=2</p>
<p>令g(n)=g(n-1)+f(n)+n*n,g(1)=2</p>
<p>告诉你n，输出g(n)的结果，结果对1e9+7取模</p>
</blockquote>
<a id="more"></a>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><blockquote>
<p>多组输入，每行一个整数n（1&lt;=n&lt;=1e9)，如果输入为0，停止程序。</p>
</blockquote>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><blockquote>
<p>在一行中输出对应g(n)的值，结果对1e9+7取模。</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><blockquote>
<p>输入</p>
<blockquote>
<pre><code>1
5
9
456
0
</code></pre></blockquote>
<p>输出</p>
<blockquote>
<pre><code>2
193
11956
634021561
</code></pre></blockquote>
<p>说明</p>
<blockquote>
<pre><code>多组输入，输入为0时，终止程序
</code></pre></blockquote>
</blockquote>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><blockquote>
<p>项数极大，朴素算法无法在规定时间内得出结果</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>矩阵快速幂</strong></p>
<script type="math/tex; mode=display">
\left[
 \begin{matrix}
   g(n) \\
   f(n) \\
   f(n - 1) \\
   n ^ 2 \\
   n \\
   1 \\
  \end{matrix}
  \right]
=
 \left[
 \begin{matrix}
   1 & 2 & 3 & 1 & 3 & 2 \\
   0 & 2 & 3 & 0 & 1 & 1 \\
   0 & 1 & 0 & 0 & 0 & 0 \\
   0 & 0 & 0 & 1 & 2 & 1 \\
   0 & 0 & 0 & 0 & 1 & 1 \\
   0 & 0 & 0 & 0 & 0 & 1 \\
  \end{matrix}
  \right] 
  \left[
 \begin{matrix}
   g(n - 1) \\
   f(n - 1) \\
   f(n - 2) \\
   (n - 1) ^ 2 \\
   n - 1 \\
   1 \\
  \end{matrix}
  \right]</script><script type="math/tex; mode=display">
\left[
 \begin{matrix}
   g(n) \\
   f(n) \\
   f(n - 1) \\
   n ^ 2 \\
   n \\
   1 \\
  \end{matrix}
  \right]
=
 \left[
 \begin{matrix}
   1 & 2 & 3 & 1 & 3 & 2 \\
   0 & 2 & 3 & 0 & 1 & 1 \\
   0 & 1 & 0 & 0 & 0 & 0 \\
   0 & 0 & 0 & 1 & 2 & 1 \\
   0 & 0 & 0 & 0 & 1 & 1 \\
   0 & 0 & 0 & 0 & 0 & 1
  \end{matrix}
  \right] ^ {n - 2}

  \left[
 \begin{matrix}
   8 \\
   2 \\
   1 \\
   4 \\
   2 \\
   1
  \end{matrix}
  \right]</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">    Matrix(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>) : n(n), m(m) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld"</span>, a[i][j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, j == m? <span class="string">"\n"</span>: <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m) &#123;</span><br><span class="line">            init();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                a[i][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix b) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">c</span><span class="params">(n, b.m)</span></span>;</span><br><span class="line">        c.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c.n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c.m; ++j) &#123;</span><br><span class="line">                    c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">qmod</span><span class="params">(ll b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == m) &#123;</span><br><span class="line">            Matrix a = *<span class="keyword">this</span>;</span><br><span class="line">            Matrix ans = Matrix(n, n);</span><br><span class="line">            ans.unit();</span><br><span class="line">            <span class="keyword">if</span>(!b) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">while</span>(b) &#123;</span><br><span class="line">                <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">                a = a * a;</span><br><span class="line">                b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"8\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Matrix m(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">            m.init();</span><br><span class="line">            m.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; m.a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span>; m.a[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">3</span>; m.a[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>; m.a[<span class="number">1</span>][<span class="number">5</span>] = <span class="number">3</span>; m.a[<span class="number">1</span>][<span class="number">6</span>] = <span class="number">2</span>;</span><br><span class="line">            m.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">2</span>; m.a[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">3</span>; m.a[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">1</span>; m.a[<span class="number">2</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">1</span>; m.a[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>; m.a[<span class="number">4</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">5</span>][<span class="number">5</span>] = <span class="number">1</span>; m.a[<span class="number">5</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            m.a[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="function">Matrix <span class="title">ans</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">            ans.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line">            ans.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            ans.a[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            ans.a[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">            ans.a[<span class="number">5</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            ans.a[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            ans = (m.qmod(n - <span class="number">2</span>)) * ans;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans.a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>大数运算之 Java BigInteger 的基本用法</title>
    <url>/2019/08/15/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E4%B9%8B-Java-BigInteger-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="大数运算之-Java-BigInteger-的基本用法"><a href="#大数运算之-Java-BigInteger-的基本用法" class="headerlink" title="大数运算之 Java BigInteger 的基本用法"></a>大数运算之 Java BigInteger 的基本用法</h1><p>在程序设计竞赛中会遇到高精度运算的问题，C++没有高精度运算，只能手动模拟人工运算，手动实现高精度，而 <code>java.math</code> 包中的 <code>BigInteger</code> 提供了高精度的基本运算，因此竞赛中常用 Java 解决高精度运算问题。</p>
<p><del>当然如果比赛支持 <code>python</code> 就当我没说。</del></p>
<a id="more"></a>
<h2 id="BigInteger-对象的创建"><a href="#BigInteger-对象的创建" class="headerlink" title="BigInteger 对象的创建"></a>BigInteger 对象的创建</h2><p>BigInteger 类在 java.math.BigInteger 包中，首先引用该包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br></pre></td></tr></table></figure>
<p>BigInteger 对象的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>); <span class="comment">// 这里是字符串</span></span><br></pre></td></tr></table></figure>
<p>改变 BigInteger 的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line">BigInteger a = BigInteger.valueOf(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">456</span>;</span><br><span class="line">BigInteger a = BigInteger.valueOf(num);</span><br></pre></td></tr></table></figure>
<p>基本常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = BigInteger.ONE <span class="comment">// 1</span></span><br><span class="line">b = BigInteger.TEN <span class="comment">// 10</span></span><br><span class="line">c = BigInteger.ZERO <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="BigInteger-的输入输出"><a href="#BigInteger-的输入输出" class="headerlink" title="BigInteger 的输入输出"></a>BigInteger 的输入输出</h2><p>直接读入 BigInteger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line"><span class="keyword">while</span>(in.hasNext()) <span class="comment">//等同于!=EOF</span></span><br><span class="line">&#123;</span><br><span class="line">    BigInteger a;</span><br><span class="line">    a = in.nextBigInteger();</span><br><span class="line">    System.out.print(a.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>间接读入 BigInteger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line"><span class="keyword">while</span>(in.hasNext()) <span class="comment">//等同于!=EOF</span></span><br><span class="line">&#123;</span><br><span class="line">    String s = in.nextLine();</span><br><span class="line">    BigInteger a = <span class="keyword">new</span> BigInteger(s);</span><br><span class="line">    System.out.print(a.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BigInteger 直接输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(a);</span><br></pre></td></tr></table></figure>
<p>BigInteger 转化成十进制表示的 String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(a.toString());</span><br></pre></td></tr></table></figure>
<p>BigInteger 转化成 p 进制表示的 String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = <span class="number">2</span>;</span><br><span class="line">System.out.print(a.toString(p)); <span class="comment">// 输出a的二进制</span></span><br></pre></td></tr></table></figure>
<p>BigInteger 二进制下的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">"12"</span>);</span><br><span class="line">System.out.println(n.bitLength()); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="BigInteger-的基本运算"><a href="#BigInteger-的基本运算" class="headerlink" title="BigInteger 的基本运算"></a>BigInteger 的基本运算</h2><p>BigInteger 之间的比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// a == b 时为 true 否则为 false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a.compareTo(b) == <span class="number">0</span>) System.out.println(<span class="string">"a == b"</span>); <span class="comment">// a == b</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.compareTo(b) &gt; <span class="number">0</span>) System.out.println(<span class="string">"a &gt; b"</span>); <span class="comment">// a &gt; b</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.compareTo(b) &lt; <span class="number">0</span>) System.out.println(<span class="string">"a &lt; b"</span>); <span class="comment">// a &lt; b</span></span><br></pre></td></tr></table></figure>
<p>加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">a.add(b);</span><br></pre></td></tr></table></figure>
<p>减法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">a.subtract(b);</span><br></pre></td></tr></table></figure>
<p>乘法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">a.multiply(b);</span><br></pre></td></tr></table></figure>
<p>除法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">a.divide(b);</span><br></pre></td></tr></table></figure>
<p>取余</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">BigInteger c = b.remainder(a);</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure>
<p>除法取余</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"123"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">BigInteger result[] = b.divideAndRemainder(a); <span class="comment">// 该函数返回的是数组</span></span><br><span class="line">System.out.println(<span class="string">"商是："</span> + result[<span class="number">0</span>] + <span class="string">"；余数是："</span> + result[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>最大公约数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"12"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"56"</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(a.gcd(b)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>绝对值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"-12"</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(a.abs()); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>取反数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"-12"</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(a.negate()); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>幂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(a.pow(<span class="number">3</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ACM学习</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂取模算法</title>
    <url>/2019/08/05/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E6%A8%A1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="快速幂取模算法"><a href="#快速幂取模算法" class="headerlink" title="快速幂取模算法"></a>快速幂取模算法</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>快速幂用于求解 $a ^ n mod m$ 的结果。</p>
<p>朴素的做法是直接用循环求解，时间复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a, ll n, ll m)</span> </span>&#123;</span><br><span class="line">    ll result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        result = (result * a) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点很明显，一是效率低，容易超时，二是指数爆炸，容易爆 $long long$。</p>
<a id="more"></a>
<h2 id="快速幂-分治思想"><a href="#快速幂-分治思想" class="headerlink" title="快速幂 分治思想"></a>快速幂 分治思想</h2><p>可以将问题分解成如下的子问题：</p>
<script type="math/tex; mode=display">
a^n\ mod\ m = 
\begin{cases}
1\ mod\ m, & n = 0\\
(a^{n/2} \cdot a^{n/2}) \ mod\ m, & n是偶数\\
(a \cdot a^{n/2} \cdot a^{n/2})\ mod\ m, & n是奇数 \\
\end{cases}</script><p>写成递归的形式</p>
<script type="math/tex; mode=display">
power(a, n, m) = 
\begin{cases}
1\% m, & n = 0\\
power(a^2, n/2, m) \% m, & n是偶数\\
(a * power(a^2, n/2, m)) \% m, & n是奇数 \\
\end{cases}</script><p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a, ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> quick_mod(a * a, n / <span class="number">2</span>, m) % m;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> ((a % m) * quick_mod(a * a, n / <span class="number">2</span>, m)) % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是快速幂了。</p>
<p>朴素方法计算 $a ^ n$ 其实计算了两遍 $a ^ {n / 2}$ 再相乘，其实计算一次 $a ^ {n / 2}$ 就够了，因为 $a ^ {n / 2}$ 的平方就是 $a ^ n$。而计算 $a ^ {n / 2}$ 又等价于计算 $a ^ {n / 4}$ 的平方…，因此只需 $log(n)$ 次就可以计算出结果。采用分而治之的方法将时间复杂度降为 $O(log(n))$。</p>
<p>由于递归比较慢，且容易爆栈，因此改成非递归的形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a, ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">            a = (a * a) % m;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = (res * a) % m;</span><br><span class="line">            a = (a * a) % m; </span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现上述代码有重复部分，还可以简化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a, ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) &#123; </span><br><span class="line">            res = (res * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m; </span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a, ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> % m;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;  <span class="comment">// 二进制最后一位为 1是奇数</span></span><br><span class="line">            res = (res * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m; </span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 右移一位就是整除 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul>
<li><a href="/2019/08/06/POJ-1995-Raising-Modulo-Numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/" title="POJ 1995">POJ 1995</a></li>
</ul>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM学习</tag>
        <tag>快速幂</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串 —— Manacher (马拉车) 算法</title>
    <url>/2019/11/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E2%80%94%E2%80%94-Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>回文串</strong>就是原串和反转字符串相同的字符串。比如 <code>aba</code>，<code>acca</code>。前一个是奇数长度的回文串，后一个是偶数长度的回文串。</p>
<p><strong>最长回文子串</strong>就是一个字符串的所有子串中，是回文串且长度最长的子串。</p>
<a id="more"></a>
<h2 id="Brute-Force-做法"><a href="#Brute-Force-做法" class="headerlink" title="Brute Force 做法"></a>Brute Force 做法</h2><p>枚举所有子串，判断是否是回文串，然后寻找最大长度。寻找所有子串要两重循环，判断是否是回文要一重循环，总体时间复杂度 $O(n^3)$。</p>
<p>稍微优化一下，可以枚举对称中心，然后向两边扩展，直到遇到两个不同的字符，枚举下一个对称中心，寻找其中的最大长度，时间复杂度 $O(n^2)$。</p>
<p>还可以使用 DP 解决，求原串与反转字符串的最长公共子序列 (LCS)，时间复杂度 $O(n^2)$。</p>
<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>接下来就是重点了，Manacher 算法，在1975年由一个叫 <a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#CITEREFManacher1975" target="_blank" rel="noopener">Manacher</a> 的人发明的。能够在 $O(n)$ 的时间求得最长回文子串。</p>
<p>前面提到，回文串有奇数长度的和偶数长度的，分类讨论有些复杂，可以参考<a href="https://oi-wiki.org/string/manacher/" target="_blank" rel="noopener">这里</a>。为了避免分类讨论，可以使用一个技巧：在字符串首尾以及每两个字符之间插入一个 <code>&#39;#&#39;</code>。比如 <code>abaacca</code>，转换后就是 <code>#a#b#a#a#c#c#a#</code>。那么不管是奇回文 <code>aba</code> 还是偶回文 <code>acca</code>，转换后都是奇回文 (<code>#a#b#a#</code> 和 <code>#a#c#c#a#</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;  <span class="comment">// 在开头加入哨兵防止越界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;  <span class="comment">// 结尾同样加入哨兵防止越界</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Manacher 算法的思想来自于上述枚举对称中心的思想。该算法需要维护一个 $len$ 数组，$len[i]$ 代表 $i$ 为中心的最长回文子串的长度。</p>
<p>设 $s$ 为原字符串，$mx$ 为之前计算的回文串中右端点的最大值，这个回文串的中心位置为 $id$，也就是 $mx = id + len[id]$。</p>
<p>每次计算的时候，$id$ 的右边和左边是对称的，因此计算右边的时候不需要用从对称中心向两边扩展的思想，而是只用一行代码解决：<code>len[i] = min(mx - i, len[2 * id - i]);</code>，这也是 Manacher 中最关键的一行代码。</p>
<p>如下图所示，$id$ 右边到 $mx$ 之间的子串与 $id$ 左边是对称的，所以右边的 $len[i]$ 最大长度为左边与之对称的 $len[2\times id - i]$，由于右边的回文串不能超过 $mx$ (原因见第 2 张图)，所以 <code>len[i] = min(mx - i, len[2 * id - i]);</code>。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/13/1573657779673-1573657779889.png" alt=""></p>
<p>$id$ 右边的回文串长度不能超过 $mx - i$ 的原因是，如果 $len[2 * id - i]$ 更长，如下图的黄色部分，那么右边的黄色部分与左边的黄色部分相同，那么黑色部分应该可以更长，产生矛盾。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/11/13/1573658827030-1573658827032.png" alt=""></p>
<p>理解了上面的内容基本上就理解了 Manacher 算法了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);  <span class="comment">// 上面提到的最关键的一行代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;  <span class="comment">// 如果 i 超过右边界要从头计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;  <span class="comment">// 从头计算的方法，就是上面提到的从中心向两边扩展</span></span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 mx 和 id</span></span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i]; </span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>; <span class="comment">// len[i] 中的最大值-1 即为原串的最长回文子串长度 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板题：HDU-3068-最长回文"><a href="#模板题：HDU-3068-最长回文" class="headerlink" title="模板题：HDU 3068 最长回文"></a>模板题：HDU 3068 最长回文</h2><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" target="_blank" rel="noopener">HDU 3068 最长回文</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    res += <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        res += <span class="string">'#'</span>;</span><br><span class="line">        res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">'#'</span>;</span><br><span class="line">    res += <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i) &#123;</span><br><span class="line">            len[i] = min(mx - i, len[<span class="number">2</span> * id - i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[i - len[i]] == s[i + len[i]]) &#123;</span><br><span class="line">            ++len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + len[i] &gt; mx) &#123;</span><br><span class="line">            mx = i + len[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp = init(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Manacher(tmp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://blog.csdn.net/csdn_kou/article/details/82917937" target="_blank" rel="noopener">Manacher算法图解</a></p>
<p><a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">Manacher算法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ACM学习</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1613 跑路 (倍增 + DP + 最短路)</title>
    <url>/2019/09/12/%E6%B4%9B%E8%B0%B7-P1613-%E8%B7%91%E8%B7%AF-%E5%80%8D%E5%A2%9E-DP-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P1613" target="_blank" rel="noopener">P1613 跑路</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定包含 $n$ 个点和 $m$ 条边的有向图，每条边的长度为 $1$ 千米。每秒钟可以跑 $2^k$ 千米，问从点 $1$ 到点 $n$ 最少需几秒。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>倍增 DP Floyd</strong></p>
<p>令 $dp[i][j][k]$ 表示从 $i$ 到 $j$ 是否存在长度为 $2^k$ 的路径。</p>
<p>那么如果 $dp[i][t][k - 1]$ 和 $dp[t][j][k - 1]$ 都为 $1$ 则 $dp[i][j][k]$ 为 $1$。此时可以用边权为 $1$ 的边将点 $i$ 和点 $j$ 连起来。</p>
<p>最后跑一遍最短路即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll dp[maxn][maxn][maxn];</span><br><span class="line">ll dis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        dp[x][y][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dis[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">64</span>; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][k][x - <span class="number">1</span>] &amp;&amp; dp[k][j][x - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j][x] = <span class="number">1</span>;</span><br><span class="line">                        dis[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>动态规划</tag>
        <tag>最短路</tag>
        <tag>倍增</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P2756 飞行员配对方案问题 (二分图匹配)</title>
    <url>/2019/09/21/%E6%B4%9B%E8%B0%B7-P2756-%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">P2756 飞行员配对方案问题</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $m$ 个外籍飞行员和 $n - m$ 个英国飞行员，每一架飞机需要一名英国飞行员和一名外籍飞行员，求最多能派出几架飞机。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>最大流</strong></p>
<p>二分图最大匹配的模板题。</p>
<p>建立一个超级源点 $s$ 和一个超级汇点 $t$。让 $s$ 与所有的外籍飞行员建立有向边，所有的英国飞行员与 $t$ 建立有向边。让所有边的容量为 $1$，求最大流即可。最后找出所有流量为 $1$ 的反向边即可。</p>
<p>此题也可以使用匈牙利算法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ver[M], edge[M], Next[M], d[N];</span><br><span class="line"><span class="keyword">int</span> tot, maxflow;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">    ver[++tot] = x, edge[tot] = <span class="number">0</span>, Next[tot] = head[y], head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s); d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i] &amp;&amp; !d[ver[i]]) &#123;</span><br><span class="line">                q.push(ver[i]);</span><br><span class="line">                d[ver[i]] = d[x] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ver[i] == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest = flow, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i &amp;&amp; rest; i = Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i] &amp;&amp; d[ver[i]] == d[x] + <span class="number">1</span>) &#123;</span><br><span class="line">            k = dinic(ver[i], min(rest, edge[i]));</span><br><span class="line">            <span class="keyword">if</span>(!k) d[ver[i]] = <span class="number">0</span>;</span><br><span class="line">            edge[i] -= k;</span><br><span class="line">            edge[i ^ <span class="number">1</span>] += k;</span><br><span class="line">            rest -= k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) add(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i) add(i, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span> &amp;&amp; v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        add(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(flow = dinic(s, inf)) &#123;</span><br><span class="line">            maxflow += flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxflow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxflow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[i]; j; j = Next[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ver[j] != s &amp;&amp; edge[j] == <span class="number">0</span> &amp;&amp; edge[j ^ <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ver[j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://book.douban.com/subject/30136932/" target="_blank" rel="noopener">《算法竞赛进阶指南》</a> 李煜东 著</p>
</blockquote>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>图论</tag>
        <tag>Dinic</tag>
        <tag>模板题</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1742 最小圆覆盖 (随机增量)</title>
    <url>/2019/10/04/%E6%B4%9B%E8%B0%B7-P1742-%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96-%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P1742" target="_blank" rel="noopener">P1742 最小圆覆盖</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote>
<p>给出 N 个点，求最小的包含所有点的圆。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>随机增量</strong></p>
<p>最小圆覆盖一般有两种做法：随机增量和模拟退火。随机增量的精确度更高，这里介绍随机增量的做法。</p>
<p>先将所有点随机打乱。</p>
<p>令前 $i - 1$ 个点的最小覆盖圆为圆 $O$，加入第 $i$ 个点。</p>
<p>如果第 $i$ 个点在圆 $O$ 内或圆 $O$ 上，则前 $i$ 个点的最小覆盖圆还是圆 $O$。</p>
<p>否则新得到的最小覆盖圆肯定经过第 $i$ 个点。然后确定前 $i − 1$ 个点中还有哪两个点在最小覆盖圆上。</p>
<p>以第 $i$ 个点为圆心，半径为 $0$，重复以上过程依次加入点 $P_j$。(圆心为 $\frac{P_i+P_j}{2}$，半径为 $\frac{|P_iP_j|}{2}$)</p>
<p>固定两个点之后再重复以上步骤找第三个点。(因为需要三个点来确定一个圆)</p>
<p>遍历完所有点之后，所得到的圆就是最小覆盖圆。</p>
<p>时间复杂度为 $O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>((a.dis() * dis()) / dot(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point o;</span><br><span class="line">    db r;</span><br><span class="line">    Circle() &#123;&#125;</span><br><span class="line">    Circle(Point o, db r):o(o), r(r)&#123;&#125;</span><br><span class="line">    <span class="comment">// 三点定圆</span></span><br><span class="line">    Circle(Point A, Point B, Point C) &#123;</span><br><span class="line">        <span class="keyword">double</span> a1 = B.x - A.x, b1 = B.y - A.y, c1 = (a1 * a1 + b1 * b1) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> a2 = C.x - A.x, b2 = C.y - A.y, c2 = (a2 * a2 + b2 * b2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> d = a1 * b2 - a2 * b1;</span><br><span class="line">        o.x = A.x + (c1 * b2 - c2 * b1) / d;</span><br><span class="line">        o.y = A.y + (a1 * c2 - a2 * c1) / d;</span><br><span class="line">        r = o.dis(A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(db a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(o.x + <span class="built_in">cos</span>(a) * r, o.y + <span class="built_in">sin</span>(a) * r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 点在圆内</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PinC</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        db d = p.dis(o);</span><br><span class="line">        <span class="keyword">return</span> dcmp(d - r) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 点在圆外</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PoutC</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        db d = p.dis(o);</span><br><span class="line">        <span class="keyword">return</span> dcmp(d - r) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小圆覆盖</span></span><br><span class="line"><span class="function">Circle <span class="title">min_circle</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = p.size();</span><br><span class="line">    random_shuffle(p.begin(), p.end());</span><br><span class="line">    <span class="function">Circle <span class="title">ans</span><span class="params">(p[<span class="number">0</span>], <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.PoutC(p[i])) &#123;</span><br><span class="line">            ans = Circle(p[i], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.PoutC(p[j])) &#123;</span><br><span class="line">                    ans = Circle((p[i] + p[j]) / <span class="number">2.0</span>, p[i].dis(p[j]) / <span class="number">2.0</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ans.PoutC(p[k])) &#123;</span><br><span class="line">                            ans = Circle(p[i], p[j], p[k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point tmp;</span><br><span class="line">        tmp.input();</span><br><span class="line">        p.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    Circle ans = min_circle(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n%.10lf %.10lf\n"</span>, ans.r, ans.o.x, ans.o.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://yang2002.github.io/2019/04/21/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">最小圆（球）覆盖学习笔记</a></li>
<li><a href="https://oi-wiki.org/geometry/random-incremental/" target="_blank" rel="noopener">随机增量法</a></li>
</ul>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>模板题</tag>
        <tag>随机增量法</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P3187 BZOJ 1185 [HNOI2007]最小矩形覆盖 (旋转卡壳)</title>
    <url>/2019/08/30/%E6%B4%9B%E8%B0%B7-P3187-BZOJ-1185-HNOI2007-%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/</url>
    <content><![CDATA[<p>题目链接：</p>
<p><a href="https://www.luogu.org/problem/P3187" target="_blank" rel="noopener">洛谷 P3187 [HNOI2007]最小矩形覆盖</a></p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1185" target="_blank" rel="noopener">BZOJ 1185: [HNOI2007]最小矩形覆盖</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>给定一些点的坐标，要求求能够覆盖所有点的最小面积的矩形，</p>
<p>输出所求矩形的面积和四个顶点坐标</p>
</blockquote>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote>
<p>第一行为一个整数n（3&lt;=n&lt;=50000）</p>
<p>从第2至第n+1行每行有两个浮点数，表示一个顶点的x和y坐标，不用科学计数法</p>
</blockquote>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote>
<p>第一行为一个浮点数，表示所求矩形的面积（精确到小数点后5位），</p>
<p>接下来4行每行表示一个顶点坐标，要求第一行为y坐标最小的顶点，</p>
<p>其后按逆时针输出顶点坐标.如果用相同y坐标，先输出最小x坐标的顶点</p>
</blockquote>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">6 1.0 3.00000</span><br><span class="line"></span><br><span class="line">1 4.00000</span><br><span class="line"></span><br><span class="line">2.0000 1</span><br><span class="line"></span><br><span class="line">3 0.0000</span><br><span class="line"></span><br><span class="line">3.00000 6</span><br><span class="line"></span><br><span class="line">6.0 3.0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">18.00000</span><br><span class="line"></span><br><span class="line">3.00000 0.00000</span><br><span class="line"></span><br><span class="line">6.00000 3.00000</span><br><span class="line"></span><br><span class="line">3.00000 6.00000</span><br><span class="line"></span><br><span class="line">0.00000 3.00000</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>旋转卡壳</strong></p>
<p>旋转卡壳求最小面积多边形外接矩形的模板题。</p>
<p>精度问题卡了好久，-0.00000 被卡了，真的毒瘤。</p>
<p>首先求凸包，然后用旋转卡壳维护最左边的点，最上面的点和最右边的点即可。(下图中的 $L$, $K$, $J$ 点)</p>
<p>最上面的点的求法类似凸包的直径，就是求对踵点，用叉积维护即可。</p>
<p>最左边和最右边的点就是投影最大的点。用点积维护。</p>
<p>注：比较的时候最好不要直接用比较运算符。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/08/30/1567152436333-1567152436545.png" alt=""></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * a, y * a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x &amp;&amp; y == a.y)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point ans[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = P.size(), k = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">H</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">    sort(P.begin(), P.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">2</span> &amp;&amp; cross(H[k - <span class="number">1</span>] - H[k - <span class="number">2</span>], P[i] - H[k - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        H[k++] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= t &amp;&amp; cross(H[k - <span class="number">1</span>] - H[k - <span class="number">2</span>], P[i - <span class="number">1</span>] - H[k - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        H[k++] = P[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H.resize(k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rotating_caliper</span><span class="params">(Polygon v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> min_s = <span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = v.size();</span><br><span class="line">    v.push_back(v[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">1</span>, r = <span class="number">1</span>, l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="comment">// 最上面的点</span></span><br><span class="line">        <span class="keyword">while</span> (dcmp(<span class="built_in">fabs</span>(cross(v[u] - v[i], v[i + <span class="number">1</span>] - v[i])) - <span class="built_in">fabs</span>(cross(v[u + <span class="number">1</span>] - v[i], v[i + <span class="number">1</span>] - v[i]))) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            u = (u + <span class="number">1</span>) % cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最右边的点</span></span><br><span class="line">        <span class="keyword">while</span> (dcmp(dot(v[r] - v[i], v[i + <span class="number">1</span>] - v[i]) - dot(v[r + <span class="number">1</span>] - v[i], v[i + <span class="number">1</span>] - v[i])) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r = (r + <span class="number">1</span>) % cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!i) l = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最左边的点</span></span><br><span class="line">        <span class="keyword">while</span> (dcmp(dot(v[l] - v[i], v[i + <span class="number">1</span>] - v[i]) - dot(v[l + <span class="number">1</span>] - v[i], v[i + <span class="number">1</span>] - v[i])) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            l = (l + <span class="number">1</span>) % cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> d = v[i].dis(v[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">double</span> R = dot(v[r] - v[i], v[i + <span class="number">1</span>] - v[i]) / d; </span><br><span class="line">        <span class="keyword">double</span> L = dot(v[l] - v[i], v[i + <span class="number">1</span>] - v[i]) / d;</span><br><span class="line">        <span class="keyword">double</span> ll = R - L;</span><br><span class="line">        <span class="keyword">double</span> dd = <span class="built_in">fabs</span>(cross(v[u] - v[i], v[i + <span class="number">1</span>] - v[i])) / d;</span><br><span class="line">        <span class="keyword">double</span> s = ll * dd;</span><br><span class="line">        <span class="keyword">if</span>(s &lt; min_s) &#123;</span><br><span class="line">            min_s = s;</span><br><span class="line">            ans[<span class="number">0</span>] = v[i] + (v[i + <span class="number">1</span>] - v[i]) * (R / d);</span><br><span class="line">            ans[<span class="number">1</span>] = ans[<span class="number">0</span>] + (v[r] - ans[<span class="number">0</span>]) * (dd / v[r].dis(ans[<span class="number">0</span>]));</span><br><span class="line">            ans[<span class="number">2</span>] = ans[<span class="number">1</span>] + (v[i] - ans[<span class="number">0</span>]) * (ll / R);</span><br><span class="line">            ans[<span class="number">3</span>] = ans[<span class="number">2</span>] + (ans[<span class="number">0</span>] - ans[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    Polygon s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p.x, &amp;p.y);</span><br><span class="line">        s.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Polygon p = Andrew(s);</span><br><span class="line">    <span class="keyword">double</span> d = rotating_caliper(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, d);</span><br><span class="line">    <span class="keyword">double</span> miny = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(ans[i].x) == <span class="number">0</span>) ans[i].x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(ans[i].y) == <span class="number">0</span>) ans[i].y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].y &lt; miny) &#123;</span><br><span class="line">            miny = ans[i].y;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> minx = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].y == miny &amp;&amp; ans[i].x &lt; minx) &#123;</span><br><span class="line">            minx = ans[i].x;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)  &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.5lf %.5lf\n"</span>, ans[(i + index) % <span class="number">4</span>].x, ans[(i + index) % <span class="number">4</span>].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1919 【模板】A*B Problem升级版（FFT快速傅里叶）</title>
    <url>/2019/09/16/%E6%B4%9B%E8%B0%B7-P1919-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91A-B-Problem%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%88FFT%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%EF%BC%89/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P1919" target="_blank" rel="noopener">P1919 【模板】A*B Problem升级版（FFT快速傅里叶）</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个 $n$ 位 $10$ 进制整数 $x$ 和 $y$，求 $x*y$。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>FFT</strong></p>
<p>$FFT$ 的模板题，好像也可以直接用高精度乘法做。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; Complex;</span><br><span class="line"></span><br><span class="line">Complex a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> n, Complex *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Complex a1[n&gt;&gt;<span class="number">1</span>], a2[n&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        a1[i] = a[<span class="number">2</span> * i];</span><br><span class="line">        a2[i] = a[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(n&gt;&gt;<span class="number">1</span>, a1, op);</span><br><span class="line">    FFT(n&gt;&gt;<span class="number">1</span>, a2, op);</span><br><span class="line">    Complex wn=Complex(<span class="built_in">cos</span>(<span class="number">2</span> * PI / n), <span class="built_in">sin</span>(<span class="number">2</span> * PI * op / n));</span><br><span class="line">    Complex w=Complex(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n&gt;&gt;<span class="number">1</span>); ++i, w = w * wn) &#123;</span><br><span class="line">        a[i] = a1[i] + w * a2[i];</span><br><span class="line">        a[i + (n&gt;&gt;<span class="number">1</span>)] = a1[i] - w * a2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = (<span class="keyword">double</span>)(s1[n - i - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">        b[i] = (<span class="keyword">double</span>)(s2[n - i - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &lt;= m) n = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    FFT(n, a, <span class="number">1</span>);</span><br><span class="line">    FFT(n, b, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        c[i] = a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(n, c, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        ans[i] = (<span class="keyword">int</span>)(c[i].real() / n + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        ans[i] = ans[i] + ans[i - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">        ans[i - <span class="number">1</span>] = ans[i - <span class="number">1</span>] % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = m;</span><br><span class="line">    <span class="keyword">for</span>(; s &gt;= <span class="number">0</span>; --s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[s]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>模板题</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P3369 【模板】普通平衡树 (Treap)</title>
    <url>/2019/09/25/%E6%B4%9B%E8%B0%B7-P3369-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-Treap/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P3369" target="_blank" rel="noopener">P3369 【模板】普通平衡树</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>构造一种数据结构满足给出的 6 种操作。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>平衡树</strong></p>
<p>平衡树的模板题。</p>
<p>先学习了一下 Treap。</p>
<p>Treap 在插入结点时给该结点随机生成一个额外的权值，然后用该权值维护一个大根堆，如果某个结点不满足大根堆的性质，就通过旋转与父节点交换。</p>
<p>对于删除某个结点，通过不断向下旋转直至变成叶子结点，然后直接删除即可。</p>
<p>模板来自<a href="https://book.douban.com/subject/30136932/" target="_blank" rel="noopener">《算法竞赛进阶指南》</a>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">int</span> val, dat;</span><br><span class="line">	<span class="keyword">int</span> cnt, size;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> tot, root;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	a[++tot].val = val;</span><br><span class="line">	a[tot].dat = rand();</span><br><span class="line">	a[tot].cnt = a[tot].size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	new_node(-inf), new_node(inf);</span><br><span class="line">	root = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">	update(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) <span class="keyword">return</span> a[a[p].l].size + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (val &lt; a[p].val) <span class="keyword">return</span> get_rank(a[p].l, val);</span><br><span class="line">	<span class="keyword">return</span> get_rank(a[p].r, val) + a[a[p].l].size + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> inf;</span><br><span class="line">	<span class="keyword">if</span> (a[a[p].l].size &gt;= rank) <span class="keyword">return</span> get_val(a[p].l, rank);</span><br><span class="line">	<span class="keyword">if</span> (a[a[p].l].size + a[p].cnt &gt;= rank) <span class="keyword">return</span> a[p].val;</span><br><span class="line">	<span class="keyword">return</span> get_val(a[p].r, rank - a[a[p].l].size - a[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q = a[p].l;</span><br><span class="line">	a[p].l = a[q].r, a[q].r = p, p = q;</span><br><span class="line">	update(a[p].r), update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q = a[p].r;</span><br><span class="line">	a[p].r = a[q].l, a[q].l = p, p = q;</span><br><span class="line">	update(a[p].l), update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">		p = new_node(val);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">		a[p].cnt++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; a[p].val) &#123;</span><br><span class="line">		add(a[p].l, val);</span><br><span class="line">		<span class="keyword">if</span> (a[p].dat &lt; a[a[p].l].dat) zig(p);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		add(a[p].r, val);</span><br><span class="line">		<span class="keyword">if</span> (a[p].dat &lt; a[a[p].r].dat) zag(p);</span><br><span class="line">	&#125;</span><br><span class="line">	update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">// a[1].val==-inf</span></span><br><span class="line">	<span class="keyword">int</span> p = root;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[p].l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				p = a[p].l;</span><br><span class="line">				<span class="keyword">while</span> (a[p].r &gt; <span class="number">0</span>) p = a[p].r;</span><br><span class="line">				ans = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p;</span><br><span class="line">		p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">2</span>; <span class="comment">// a[2].val==inf</span></span><br><span class="line">	<span class="keyword">int</span> p = root;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[p].r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				p = a[p].r;</span><br><span class="line">				<span class="keyword">while</span> (a[p].l &gt; <span class="number">0</span>) p = a[p].l;</span><br><span class="line">				ans = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p;</span><br><span class="line">		p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把非叶子结点旋转至叶子结点后直接删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[p].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			a[p].cnt--, update(p);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[p].l || a[p].r) &#123; <span class="comment">// 不是叶子节点，向下旋转</span></span><br><span class="line">			<span class="keyword">if</span> (a[p].r == <span class="number">0</span> || a[a[p].l].dat &gt; a[a[p].r].dat)</span><br><span class="line">				zig(p), remove(a[p].r, val);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				zag(p), remove(a[p].l, val);</span><br><span class="line">			update(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p = <span class="number">0</span>; <span class="comment">// 叶子节点，删除</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	val &lt; a[p].val ? remove(a[p].l, val) : remove(a[p].r, val);</span><br><span class="line">	update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	build();</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">			add(root, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;</span><br><span class="line">			remove(root, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; get_rank(root, x) - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; get_val(root, x + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; get_pre(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; get_next(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>平衡树</tag>
        <tag>模板题</tag>
        <tag>树</tag>
        <tag>Treap</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P3455 [POI2007]ZAP-Queries (莫比乌斯函数)</title>
    <url>/2019/10/08/%E6%B4%9B%E8%B0%B7-P3455-POI2007-ZAP-Queries-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P3455" target="_blank" rel="noopener">P3455 [POI2007]ZAP-Queries</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote>
<p>给定 $a,b,d$，求 $\sum_{x=1}^{a} \sum_{y=1}^{b}[gcd(x, y) = d]$。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>莫比乌斯函数的一个性质：</p>
<script type="math/tex; mode=display">[x = 1] = \sum_{d|x} \mu(d)</script><p>设 $a \le b$，对原式转化：</p>
<script type="math/tex; mode=display">\sum_{x=1}^{a} \sum_{y=1}^{b}[gcd(x, y) = d] \\
= \sum_{x=1}^{\lfloor \frac{a}{d} \rfloor} \sum_{y=1}^{\lfloor \frac{b}{d} \rfloor}[gcd(x, y) = 1] \\
= \sum_{x=1}^{\lfloor \frac{a}{d} \rfloor} \sum_{y=1}^{\lfloor \frac{b}{d} \rfloor} \sum_{d'|gcd(x, y)} \mu(d') \\
= \sum_{x=1}^{\lfloor \frac{a}{d} \rfloor} \sum_{y=1}^{\lfloor \frac{b}{d} \rfloor} \sum_{d'=1}^{\lfloor \frac{a}{d} \rfloor} \mu(d') \cdot [d'|gcd(x, y)] \\
= \sum_{d'=1}^{\lfloor \frac{a}{d} \rfloor} \mu(d') \sum_{x=1}^{\lfloor \frac{a}{d} \rfloor} \sum_{y=1}^{\lfloor \frac{b}{d} \rfloor} [d'|gcd(x, y)] \\
= \sum_{d'=1}^{\lfloor \frac{a}{d} \rfloor} \mu(d') \sum_{x=1}^{\lfloor \frac{a}{d} \rfloor} \sum_{y=1}^{\lfloor \frac{b}{d} \rfloor} [d'|x \wedge d'|y] \\
= \sum_{d'=1}^{\lfloor \frac{a}{d} \rfloor} \mu(d') \sum_{x=1}^{\lfloor \frac{a}{d} \rfloor} [d'|x] \sum_{y=1}^{\lfloor \frac{b}{d} \rfloor} [d'|y] \\
= \sum_{d'=1}^{\lfloor \frac{a}{d} \rfloor} \mu(d') \lfloor \frac{a}{dd'} \rfloor {\lfloor \frac{b}{dd'} \rfloor}\\</script><p>然后预处理 $\mu$ 的前缀和，用一下<strong>整除分块</strong>求解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line">ll a, b, d;</span><br><span class="line"></span><br><span class="line">ll mu[maxn], vis[maxn], sum[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 莫比乌斯函数的前缀和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sum[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            p.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size() &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * p[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        a /= d;</span><br><span class="line">        b /= d;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 整除分块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= a; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">            j = min(a / (a / i), b / (b / i));</span><br><span class="line">            ans += (sum[j] - sum[i - <span class="number">1</span>]) * (a / i) * (b / i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数论</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P4173 残缺的字符串 (FFT)</title>
    <url>/2019/09/23/%E6%B4%9B%E8%B0%B7-P4173-%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-FFT/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P4173" target="_blank" rel="noopener">P4173 残缺的字符串</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 $m$ 的模式串和长度为 $n$ 的目标串，两个串都带有通配符，求所有匹配的位置。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>FFT</strong></p>
<p>带有通配符的字符串匹配问题。</p>
<p>设模式串为 $p$，目标串为 $t$，将两个串的内容都根据字母先后顺序映射到 $1$ 到 $26$。</p>
<p>如果不带有通配符，那么 $t$ 以第 $k$ 位结束的长度为 $|p|$ 的子串与 $p$ 匹配时有</p>
<script type="math/tex; mode=display">\sum_{i=0}^{|p|-1} (p[i] - t[k - |p| + 1 + i])^2 = 0</script><p>如果带有通配符，只需将上式稍微改一下就行。</p>
<p>让两个串中的所有通配符映射到 $0$，设匹配结果为 $f$，则有</p>
<script type="math/tex; mode=display">f[i] = \sum_{i=0}^{|p|-1} (p[i] - t[k - |p| + 1 + i])^2 \cdot p[i] \cdot t[k - |p| + 1 + i]</script><p>接下来翻转 $p$ 串 ($FFT$ 的套路)，设 $r[|p| - i - 1] = p[i]$，则有</p>
<script type="math/tex; mode=display">f[i] = \sum_{i=0}^{|p|-1} (r[|p| - i - 1] - t[k - |p| + 1 + i])^2 \cdot r[|p| - i - 1] \cdot t[k - |p| + 1 + i]</script><p>下标加起来等于 $k$，令 $j = |p| - i - 1$，则</p>
<script type="math/tex; mode=display">f[i] = \sum_{i + j = k} (r[j] - t[i])^2 \cdot r[j] \cdot t[i]</script><p>展开后有</p>
<script type="math/tex; mode=display">f[i] = \sum_{i + j = k} (r[j]^3t[i] + t[i]^3r[j] - 2\cdot r[j]^2t[i]^2)</script><p>用 $FFT$ 分别求一下卷积即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; Complex;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Complex p[maxn], t[maxn];</span><br><span class="line">Complex a[maxn], b[maxn], c[maxn], d[maxn];</span><br><span class="line">Complex ans[maxn];</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">2</span>, rev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rev, <span class="number">0</span>, <span class="keyword">sizeof</span>(rev));</span><br><span class="line">    <span class="keyword">while</span>(bit &lt;= n + m) bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | (bit &gt;&gt; <span class="number">1</span>) * (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; bit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(PI / mid), op * <span class="built_in">sin</span>(PI / mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit; j += mid&lt;&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k, w = w * wn) &#123;</span><br><span class="line">                Complex x = a[j + k], y = w * a[j + k + mid];</span><br><span class="line">                a[j + k] = x + y, a[j + k + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        p[m - i - <span class="number">1</span>] = str[i] == <span class="string">'*'</span> ? <span class="number">0</span> : (str[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        t[i] = str[i] == <span class="string">'*'</span> ? <span class="number">0</span> : (str[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    get_rev();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        a[i] = p[i] * p[i] * p[i];</span><br><span class="line">        b[i] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, <span class="number">1</span>); FFT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        ans[i] += a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        a[i] = p[i];</span><br><span class="line">        b[i] = t[i] * t[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, <span class="number">1</span>); FFT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        ans[i] += a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        a[i] = p[i] * p[i];</span><br><span class="line">        b[i] = t[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, <span class="number">1</span>); FFT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        ans[i] -= a[i] * b[i] * Complex(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FFT(ans, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)(ans[i].real() / bit + <span class="number">0.5</span>) == <span class="number">0</span>) q.push(i - m + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.front() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P3803 【模板】多项式乘法（FFT）</title>
    <url>/2019/09/17/%E6%B4%9B%E8%B0%B7-P3803-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%EF%BC%88FFT%EF%BC%89/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P3803" target="_blank" rel="noopener">P3803 【模板】多项式乘法（FFT）</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式 $G(x)$，求 $F(x)$ 和 $G(x)$ 的卷积。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>FFT</strong></p>
<p>又是一道 $FFT$ 的模板题，不过用递归的 $FFT$ 会超时。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; Complex;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Complex a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">2</span>, rev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bit &lt;= n + m) bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | (bit &gt;&gt; <span class="number">1</span>) * (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) swap(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; bit; mid &lt;&lt;= <span class="number">1</span>) &#123;  <span class="comment">// 左右两部分的区间长度</span></span><br><span class="line">        Complex wn = Complex(<span class="built_in">cos</span>(PI / mid), op * <span class="built_in">sin</span>(PI / mid));  <span class="comment">// 单位复数根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit; j += mid&lt;&lt;<span class="number">1</span>) &#123;  <span class="comment">// 一组一组处理</span></span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k, w = w * wn) &#123;</span><br><span class="line">                Complex x = a[j + k], y = w * a[j + k + mid];  <span class="comment">// 蝴蝶操作</span></span><br><span class="line">                a[j + k] = x + y, a[j + k + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        b[i] = read();</span><br><span class="line">    &#125;</span><br><span class="line">    get_rev();</span><br><span class="line">    FFT(a, <span class="number">1</span>);</span><br><span class="line">    FFT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) &#123;</span><br><span class="line">        a[i] *= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(a[i].real() / bit + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>数学</tag>
        <tag>模板题</tag>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客 Fruit Ninja 2018 ACM 上海大都会赛 (随机化算法)</title>
    <url>/2019/09/30/%E7%89%9B%E5%AE%A2-Fruit-Ninja-2018-%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9B-%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/problem/17376" target="_blank" rel="noopener">Fruit Ninja</a><br>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/163#question" target="_blank" rel="noopener">2018 ACM 国际大学生程序设计竞赛上海大都会赛重现赛</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Fruit Ninja is a juicy action game enjoyed by millions of players around the world, with squishy,</p>
<p>splat and satisfying fruit carnage! Become the ultimate bringer of sweet, tasty destruction with every slash.</p>
<p>Fruit Ninja is a very popular game on cell phones where people can enjoy cutting the fruit by touching the screen.</p>
<p>In this problem, the screen is rectangular, and all the fruits can be considered as a point. A touch is a straight line cutting</p>
<p>thought the whole screen, all the fruits in the line will be cut.</p>
<p>A touch is EXCELLENT if $\frac{M}{N} \ge x$, ($N$ is total number of fruits in the screen, $M$ is the number of fruits that cut by the touch, $x$ is a real number.)<br>Now you are given $N$ fruits position in the screen, you want to know if exist a EXCELLENT touch.</p>
</blockquote>
<a id="more"></a>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>The first line of the input is $T(1 \le T \le 100)$, which stands for the number of test cases you need to solve.<br>The first line of each case contains an integer $N (1 \le N \le 10^4)$ and a real number $x (0 &lt; x &lt; 1)$, as mentioned above.<br>The real number will have only 1 digit after the decimal point.<br>The next $N$ lines, each lines contains two integers $x_i$ and $y_i (-10^9 ≤ x_i,y_i ≤ 10^9)$, denotes the coordinates of a fruit.</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>For each test case, output “Yes” if there are at least one EXCELLENT touch. Otherwise, output “No”.</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><blockquote>
<p>输入</p>
<pre><code>  2
  5 0.6
  -1 -1
  20 1
  1 20
  5 5
  9 9
  5 0.5
  -1 -1
  20 1
  1 20
  2 5
  9 9
</code></pre><p>输出</p>
<pre><code>  Yes
  No
</code></pre></blockquote>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $N$ 个点以及一个实数 $x$，问是否存在一条直线，直线经过 $N$ 个点中的 $M$ 个点，且 $\frac{M}{N} \ge x$。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>随机化算法</strong></p>
<p>随机取两个点构造直线，比较直线经过的点的个数（斜率相同）是否大于等于 $N * x$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    db x, y;</span><br><span class="line">    Point(db x = <span class="number">0</span>, db y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        db x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;x);</span><br><span class="line">        x *= n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = rand() % n, b = rand() % n;</span><br><span class="line">            <span class="keyword">while</span>(a == b) a = rand() % n;</span><br><span class="line">            db cnt = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == a || j == b) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((p[j].y - p[a].y) * (p[b].x - p[j].x) == (p[j].x - p[a].x) * (p[b].y - p[j].y)) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= x) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>随机化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何模板整理</title>
    <url>/2019/09/06/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  <span class="comment">// 误差</span></span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  <span class="comment">// 圆周率</span></span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  <span class="comment">// 无穷大</span></span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精度三态函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;  <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般用于排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断点的坐标是否相同</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 点到点的距离的平方</span></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 点到点的距离</span></span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量的模的平方</span></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量的模</span></span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量加法</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量减法</span></span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量数乘</span></span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量数除</span></span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量点积</span></span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量叉积</span></span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量与 a 向量的夹角</span></span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>((a.dis() * dis()) / dot(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量在 b 向量上的投影</span></span><br><span class="line">    <span class="function">db <span class="title">projection</span><span class="params">(Point b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(dis()) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(b.dis()) == <span class="number">0</span>) <span class="keyword">return</span> dis();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cos</span>(ang(b)) * dis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向量逆时针旋转 rad 弧度</span></span><br><span class="line">    <span class="function">Point <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * <span class="built_in">cos</span>(rad) - y * <span class="built_in">sin</span>(rad), x * <span class="built_in">sin</span>(rad) + y * <span class="built_in">cos</span>(rad));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="comment">// 点 p 在有向线段 se 的左边返回 1, 右边返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直线与直线位置关系 0-重合 1-平行 2-相交</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span> <span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直线与直线交点</span></span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		<span class="keyword">double</span> a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        <span class="keyword">double</span> x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">double</span> y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凸包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size(), cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Polygon <span class="title">ans</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">    sort(p.begin(), p.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &gt;= <span class="number">2</span> &amp;&amp; (ans[cnt - <span class="number">1</span>] - ans[cnt - <span class="number">2</span>]).cross(p[i] - ans[cnt - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[cnt++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt &gt;= t &amp;&amp; (ans[cnt - <span class="number">1</span>] - ans[cnt - <span class="number">2</span>]).cross(p[i - <span class="number">1</span>] - ans[cnt - <span class="number">2</span>]) &lt; eps) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[cnt++] = p[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ans.resize(cnt - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp((a1 - p).cross(a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp((a1 - p).dot(a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线段相交</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = (a2 - a1).cross(b1 - a1), c2 = (a2 - a1).cross(b2 - a1),</span><br><span class="line">            c3 = (b2 - b1).cross(a1 - b1), c4 = (b2 - b1).cross(a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp((p2 - p1).cross(p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凸包面积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolygonArea</span><span class="params">(Polygon p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; p.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>((p[i] - p[<span class="number">1</span>]).cross(p[i + <span class="number">1</span>] - p[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(更新中)</p>
]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>ACM学习</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客 14505 轰炸区最优选取 (二维前缀和)</title>
    <url>/2019/08/15/%E7%89%9B%E5%AE%A2-14505-%E8%BD%B0%E7%82%B8%E5%8C%BA%E6%9C%80%E4%BC%98%E9%80%89%E5%8F%96-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/problem/14505" target="_blank" rel="noopener">轰炸区最优选取</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>现在给出一个正方形地图，其边长为n，地图上有的地方是空的，有的地方会有敌人。</p>
<p>我们现在有一次轰炸敌人的机会，轰炸敌人的区域是一个k*k的正方形区域，现在需要你解决的问题就是计算最多轰炸的敌人数量是多少。 </p>
</blockquote>
<a id="more"></a>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><blockquote>
<p>本题包含多组数据，每组数据第一行输入两个数n，k。</p>
<p>接下来n行，每行n个数字，表示这个点上的敌人数量。</p>
<p>数据范围：</p>
<p>1&lt;=n&lt;=50</p>
<p>1&lt;=k&lt;=n</p>
<p>每个点上的敌人数量不超过100个（0&lt;=a[i][j]&lt;=100）。</p>
</blockquote>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><blockquote>
<p>每组数据输出包含一行，表示计算的结果。</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 1 0 0</span><br><span class="line">1 1 0 0</span><br><span class="line">0 0 2 2</span><br><span class="line">0 0 2 2</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote>
<p>样例中，显然轰炸右下角那个部分能够击败最多的敌人</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>二维前缀和</strong></p>
<p>二维前缀和的模板题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">                sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = sum[i][j] - sum[i - k][j] - sum[i][j - k] + sum[i - k][j - k];</span><br><span class="line">                ans = max(ans, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>模板题</tag>
        <tag>二维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P4196 [CQOI2006]凸多边形 (半平面交)</title>
    <url>/2019/09/10/%E6%B4%9B%E8%B0%B7-P4196-CQOI2006-%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P4196" target="_blank" rel="noopener">P4196 [CQOI2006]凸多边形</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote>
<p>给定 $n$ 个凸多边形，求它们相交的面积。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>半平面交</strong></p>
<p>半平面交的模板题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;  </span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  </span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!dcmp(x - a.x))? dcmp(y - a.y) &lt; <span class="number">0</span>: x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dcmp(x - a.x) == <span class="number">0</span> &amp;&amp; dcmp(y - a.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x - a.x, <span class="number">2</span>) + <span class="built_in">pow</span>(y - a.y, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">db <span class="title">dis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(dis2());</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + a.x, y + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x * p, y * p);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="keyword">double</span> p) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x / p, y / p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">ang</span><span class="params">(Point a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>((a.dis() * dis()) / dot(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line">Point p[maxn], ip[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point s, e;</span><br><span class="line">    db angle;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point s, Point e) : s(s), e(e) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.input();e.input();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        Line l = a;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(angle - l.angle) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l.toLeftTest(s) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> angle &lt; l.angle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_angle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        angle = <span class="built_in">atan2</span>(e.y - s.y, e.x - s.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toLeftTest</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((e - s).cross(p - s) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((e - s).cross(p - s) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp((e - s).cross(l.e - l.s)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp((l.s - e).cross(l.e - s)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line l)</span> </span>&#123;</span><br><span class="line">		db a1 = (l.e - l.s).cross(s - l.s);</span><br><span class="line">		db a2 = (l.e - l.s).cross(e - l.s);</span><br><span class="line">        db x = (s.x * a2 - e.x * a1) / (a2 - a1);</span><br><span class="line">        db y = (s.y * a2 - e.y * a1) / (a2 - a1);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(x) == <span class="number">0</span>) x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(y) == <span class="number">0</span>) y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line l[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">half_plane</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= cnt; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; l[i].s.x &lt;&lt; " " &lt;&lt; l[i].s.y &lt;&lt; " ";</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; l[i].e.x &lt;&lt; " " &lt;&lt; l[i].e.y &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(l[i].angle - l[tmp].angle) == <span class="number">1</span>) l[++tmp] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = tmp;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    q[<span class="number">1</span>] = l[<span class="number">1</span>], q[<span class="number">2</span>] = l[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            --tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; l[i].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++tail] = l[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[head].toLeftTest(q[tail].crosspoint(q[tail - <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        --tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail &amp;&amp; q[tail].toLeftTest(q[head].crosspoint(q[head + <span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ++head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tail - head + <span class="number">1</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">        ip[++tmp] = q[i].crosspoint(q[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ip[++tmp] = q[head].crosspoint(q[tail]);</span><br><span class="line">    db ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= tmp; ++i) &#123;</span><br><span class="line">        ans += (ip[i - <span class="number">1</span>] - ip[<span class="number">1</span>]).cross(ip[i] - ip[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            p[i].input();</span><br><span class="line">            <span class="keyword">if</span>(i) &#123;</span><br><span class="line">                l[++cnt].e = p[i];</span><br><span class="line">                l[cnt].s = p[i - <span class="number">1</span>];</span><br><span class="line">                l[cnt].get_angle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l[++cnt].e = p[<span class="number">0</span>];</span><br><span class="line">        l[cnt].s = p[m - <span class="number">1</span>];</span><br><span class="line">        l[cnt].get_angle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, half_plane(cnt));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>ACM刷题</tag>
        <tag>计算几何</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>设置 Quartus II 的仿真时间大于 1us</title>
    <url>/2019/10/22/%E8%AE%BE%E7%BD%AE-Quartus-II-%E7%9A%84%E4%BB%BF%E7%9C%9F%E6%97%B6%E9%97%B4%E5%A4%A7%E4%BA%8E-1us/</url>
    <content><![CDATA[<p>Quartus II 仿真的默认时长是 1us。</p>
<a id="more"></a>
<p>设置时钟时看到 End time 想修改时长，把默认的 1us 改成 10us。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/22/1571757694971-1571757695212.png" alt=""></p>
<p>然后提示 End time 不合法。（只能设置为 0 到 1us）</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/22/1571757707255-1571757707258.png" alt=""></p>
<p>正确的做法是在菜单栏选择 Edit -&gt; End time，然后将 time 设置为 10us 就可以了。</p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/22/1571757716320-1571757716325.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/22/1571757728121-1571757728124.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/WuTao18/images/master/gitnote/2019/10/22/1571757736360-1571757736364.png" alt=""></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Quartus</tag>
        <tag>数字电路</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归及Python实现</title>
    <url>/2020/06/21/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8APython%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>线性模型</strong>：</p>
<script type="math/tex; mode=display">y = \boldsymbol{w}^T \boldsymbol{x} + b \tag{1}</script><p>数据集：$D = \{(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), … , (\boldsymbol{x}_m, y_m)\}$，$\boldsymbol{x}_i = (x_{i1}; x_{i2};…; x_{id})$</p>
<p><strong>损失函数</strong> (Loss function) 采用平方损失：</p>
<script type="math/tex; mode=display">
L(\boldsymbol{w}, b) = \sum_{i=1}^m (y_i - \hat{y_i})^2</script><script type="math/tex; mode=display">
= \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2
\tag{2}</script><p>目标是找到一组解 $(\boldsymbol{w}^{\star}, b^{\star})$ 使得损失函数的值最小，即：</p>
<script type="math/tex; mode=display">
(\boldsymbol{w}^*, b^*) = \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)}L(\boldsymbol{w}, b)</script><script type="math/tex; mode=display">
= \mathop{arg\ min}\limits_{(\boldsymbol{w}, b)} \sum_{i=1}^m (y_i - (\boldsymbol{w}^T \boldsymbol{x}_i + b))^2
\tag{3}</script><a id="more"></a>
<p>求解方法：</p>
<ul>
<li><strong>最小二乘法</strong></li>
<li><strong>梯度下降法</strong><ul>
<li>模拟退火</li>
<li>随机梯度下降</li>
</ul>
</li>
</ul>
<p>损失函数的代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 误差函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(w, b, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line">  b = np.array(b)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  b = np.matrix(b)</span><br><span class="line">  </span><br><span class="line">  err = [[<span class="number">0.0</span>]]</span><br><span class="line">  m = len(x)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    err = err + (y[i] - w.T * x[i] - b) ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># err = err + abs(y[i,:] - w.T * x[i,:] - b)</span></span><br><span class="line">  <span class="keyword">return</span> err.tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 误差函数重载，这里的w包含了w和b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x=np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  </span><br><span class="line">  err = <span class="number">0.0</span></span><br><span class="line">  m = len(x)</span><br><span class="line">  <span class="comment"># print('-------')</span></span><br><span class="line">  <span class="comment"># print(m)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    pp= x[i] * w</span><br><span class="line">    p=(y[i] - pp.T )</span><br><span class="line">    err = err + p * p.T</span><br><span class="line">    <span class="comment"># err = err + (y[i] - x[i] * w.T ) ** 2</span></span><br><span class="line">  <span class="comment"># return math.sqrt(err.tolist()[0][0])/10</span></span><br><span class="line">  <span class="keyword">return</span> err.tolist()[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">1.</span>], [<span class="number">2.</span>]]</span><br><span class="line">y = [ <span class="number">1.</span>, <span class="number">2.</span>]</span><br><span class="line"></span><br><span class="line">print(loss_function([<span class="number">1</span>], <span class="number">0</span>, x, y))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<pre><code>0.0
</code></pre><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>把 $\boldsymbol{w}$ 和 $b$ 吸收入向量形式 $\hat{\boldsymbol{w}} = (\boldsymbol{w}; b)$</p>
<p>把数据集 $D$ 的输入表示为一个 $m \times (d + 1)$ 大小的矩阵 $\boldsymbol{X}$</p>
<script type="math/tex; mode=display">
\boldsymbol{X} = \left(
    \begin{array}{cccc|c}
      x_{11} & x_{12} & \cdots & x_{1d} & 1 \\
      x_{21} & x_{22} & \cdots & x_{2d} & 1 \\
      \vdots & \vdots & \ddots & \vdots & \vdots \\
      x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\
    \end{array}
\right) 
= \left(
    \begin{array}{c|c}
      \boldsymbol{x}_{1}^T & 1 \\
      \boldsymbol{x}_{2}^T & 1 \\
      \vdots & \vdots \\
      \boldsymbol{x}_{m}^T & 1 \\
    \end{array}
\right)</script><p>把输出也表示成向量形式 $\boldsymbol{y} = (y_1; y_2; …; y_n)$</p>
<p>式(2) 可表示为</p>
<script type="math/tex; mode=display">
L(\hat{\boldsymbol{w}}) = (\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})^T(\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})
\tag{4}</script><p>式(3) 可表示为</p>
<script type="math/tex; mode=display">
\hat{\boldsymbol{w}}^* = \mathop{arg\ min}\limits_{\hat{\boldsymbol{w}}} (\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})^T(\boldsymbol{y} - \boldsymbol{X} \hat{\boldsymbol{w}})
\tag{5}</script><p>对式(4)求导可得</p>
<script type="math/tex; mode=display">
\frac{\partial L(\hat{\boldsymbol{w}})}{\partial \hat{\boldsymbol{w}}} = 2 \boldsymbol{X}^T(\boldsymbol{X} \hat{\boldsymbol{w}} - \boldsymbol{y})
\tag{6}</script><p>当 $\boldsymbol{X}^T\boldsymbol{X}$ 为满秩矩阵时（不是满秩矩阵时无法求解），令式(5)等于0可得解为</p>
<script type="math/tex; mode=display">
\hat{\boldsymbol{w}}^* = (\boldsymbol{X}^T\boldsymbol{X})^{-1}\boldsymbol{X}^T \boldsymbol{y}
\tag{7}</script><p>Python代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_w</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  w = (x.T * x).I * x.T * y</span><br><span class="line">  <span class="keyword">return</span> w.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小二乘法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">least_squares</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line"></span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  <span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  <span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> get_w(x, y)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># x = [[1], [2], [3]]</span></span><br><span class="line"><span class="comment"># y = [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = least_squares(x, y)</span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(math.sqrt(loss_function(w0, w[<span class="number">-1</span>][<span class="number">0</span>], x, y)) / len(x))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<pre><code>31.927531989787543
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(str(w[<span class="number">0</span>][<span class="number">0</span>]) + <span class="string">' '</span> + str(w[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">600</span>]</span><br><span class="line">p2 = [<span class="number">0</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>], <span class="number">600</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>模型的解为：</p>
<pre><code>2.669454966762257 -188.43319665732653
</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621194739.png" alt="20200621194739"></p>
<p>采用statsmodels库求线性回归作为对比：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 采用statsmodels库求线性回归</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line">x = sm.add_constant(x) <span class="comment"># 若模型中有截距，必须有这一步</span></span><br><span class="line">model = sm.OLS(y, x).fit() <span class="comment"># 构建最小二乘模型并拟合</span></span><br><span class="line">print(model.summary()) <span class="comment"># 输出回归结果</span></span><br></pre></td></tr></table></figure>
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      y   R-squared:                       0.944
Model:                            OLS   Adj. R-squared:                  0.938
Method:                 Least Squares   F-statistic:                     136.1
Date:                Wed, 10 Jun 2020   Prob (F-statistic):           2.66e-06
Time:                        07:28:51   Log-Likelihood:                -60.337
No. Observations:                  10   AIC:                             124.7
Df Residuals:                       8   BIC:                             125.3
Df Model:                           1                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
const       -188.4332     67.619     -2.787      0.024    -344.363     -32.503
x1             2.6695      0.229     11.667      0.000       2.142       3.197
==============================================================================
Omnibus:                        1.562   Durbin-Watson:                   2.661
Prob(Omnibus):                  0.458   Jarque-Bera (JB):                0.877
Skew:                           0.356   Prob(JB):                        0.645
Kurtosis:                       1.737   Cond. No.                         560.
==============================================================================

Warnings:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.


/usr/local/lib/python3.6/dist-packages/scipy/stats/stats.py:1535: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=10
  &quot;anyway, n=%i&quot; % int(n))
</code></pre><p>可以看到结果基本一致。   </p>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>式(4)的梯度为</p>
<script type="math/tex; mode=display">
\nabla L(\hat{\boldsymbol{w}}) = 
\left(
    \begin{matrix}
      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_1} \\
      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_2} \\
      \vdots \\
      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial w_d} \\
      \frac{\partial L(\hat{\boldsymbol{w}})}{\partial b} \\
    \end{matrix}
\right)
= \frac{\partial L(\hat{\boldsymbol{w}})}{\partial \hat{\boldsymbol{w}}} = 2 \boldsymbol{X}^T(\boldsymbol{X} \hat{\boldsymbol{w}} - \boldsymbol{y})
\tag{8}</script><p>根据梯度下降法，不断更新 $\hat{\boldsymbol{w}}$ 去寻找 $\hat{\boldsymbol{w}}^*$。参数的更新以目标的负梯度为方向，$t$ 表示第 $t$ 次更新参数，$\eta$ 表示学习率。</p>
<script type="math/tex; mode=display">\hat{\boldsymbol{w}}^{(t+1)} = \hat{\boldsymbol{w}}^{(t)} - \eta \nabla L(\hat{\boldsymbol{w}}^{(t)}) \tag{9}</script><p>Python代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x.T * (x * w - y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">0.0000001</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line">  w[len(x[<span class="number">0</span>])][<span class="number">0</span>] = y[<span class="number">0</span>] - x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">  <span class="comment"># w=data.iloc[1:2,1:-1].values</span></span><br><span class="line">  <span class="comment"># w=np.concatenate((w, np.ones((len(w), 1))), axis=1).T</span></span><br><span class="line">  <span class="comment"># print(x)</span></span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    w = w - lr * gradient(w, x, y)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># data=pd.read_csv('final_data.csv',encoding='gb18030')</span></span><br><span class="line"><span class="comment"># x = data.iloc[:,1:-1].values</span></span><br><span class="line"><span class="comment"># y = data.iloc[:,0].values</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"><span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))  <span class="comment"># 均方误差</span></span><br></pre></td></tr></table></figure>
<p>模型的解及误差为：</p>
<pre><code>[[2.664103150270952], [-186.57092397847248]]
31.929045483933738
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(str(w[<span class="number">0</span>][<span class="number">0</span>]) + <span class="string">' '</span> + str(w[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">p1 = [<span class="number">0</span>, <span class="number">600</span>]</span><br><span class="line">p2 = [<span class="number">0</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>], <span class="number">600</span> * w[<span class="number">0</span>][<span class="number">0</span>] + w[<span class="number">1</span>][<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>2.664103150270952 -186.57092397847248
</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621195200.png" alt="20200621195200"></p>
<p>线性回归也可以求解<strong>非线性模型</strong>。如引入二次项：</p>
<script type="math/tex; mode=display">y = \boldsymbol{w}_2^T
\left(
    \begin{matrix}
      x_1^2 \\
      x_2^2 \\
      \vdots \\
      x_d^2 \\
    \end{matrix}
\right)
+ \boldsymbol{w}_1^T
\left(
    \begin{matrix}
      x_1 \\
      x_2 \\
      \vdots \\
      x_d \\
    \end{matrix}
\right)
+ b</script><p>可以把 $x_i^2$ 看成另一个特征，本质还是线性回归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">1e-12</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    w = w - lr * gradient(w, x, y)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">m = len(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">  x[i].insert(<span class="number">0</span>, x[i][<span class="number">0</span>] ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">w = gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))  <span class="comment"># 均方误差</span></span><br></pre></td></tr></table></figure>
<pre><code>[[114244.0, 338.0], [110889.0, 333.0], [107584.0, 328.0], [42849.0, 207.0], [51076.0, 226.0], [625.0, 25.0], [32041.0, 179.0], [3600.0, 60.0], [43264.0, 208.0], [367236.0, 606.0]]
[640.0, 633.0, 619.0, 393.0, 428.0, 27.0, 193.0, 66.0, 226.0, 1591.0]
[[0.002695722750670167], [0.9906491919888195], [0.9999201489658276]]
15.529527888679146
</code></pre><p>可以看到误差小了一半。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">x_list = []</span><br><span class="line">y_list = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">  x_list.append(i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画散点图，以x_list中的值为横坐标，以y_list中的值为纵坐标</span></span><br><span class="line"><span class="comment">#参数c指定点的颜色，s指定点的大小,alpha指定点的透明度</span></span><br><span class="line">ax.scatter(x_list, y_list, c=<span class="string">'r'</span>, s=<span class="number">20</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p1 = [0, 600]</span></span><br><span class="line"><span class="comment"># p2 = [0 * w[0][0] + w[1][0], 600 * w[0][0] + w[1][0]]</span></span><br><span class="line">p1 = []</span><br><span class="line">p2 = []</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">print(w[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">print(w[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">  p1.append(i)</span><br><span class="line">  p2.append(i * i * w[<span class="number">0</span>][<span class="number">0</span>] + i * w[<span class="number">1</span>][<span class="number">0</span>] + w[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(p1)</span></span><br><span class="line"><span class="comment"># print(p2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax1 = plt.gca()</span><br><span class="line"><span class="comment">#设置x轴、y轴名称</span></span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数c指定连线的颜色，linewidth指定连线宽度，alpha指定连线的透明度</span></span><br><span class="line">ax1.plot(p1, p2, color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>模型的解为：</p>
<pre><code>0.002695722750670167
0.9906491919888195
0.9999201489658276
</code></pre><p><img src="https://raw.githubusercontent.com/WuTao18/images/master/notes/2020/20200621195602.png" alt="20200621195602"></p>
<h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>模拟退火算法基于物理退火的原理，将固体加热至高温然后冷却，温度越高降温的概率越大 (降温更快)，温度越低降温的概率越小 (降温越慢)。模拟退火算法进行多次降温，直到找到一个可行解。</p>
<p>简单来说，如果新的状态比当前状态更优就接受该状态，否则以一定概率接受新状态。概率为：$P(\Delta E) = e^{\frac{-\Delta E}{T}}$，其中 $T$ 为当前温度，$\Delta E$ 新状态与当前状态的能量差。</p>
<p>模拟退火主要有三个参数：初始温度 $T_0$，降温系数 $d$，终止温度 $T_k$。</p>
<p>让当前温度 $T = T_0$，温度下降，尝试转移，如果转移 $T = d * T$。当 $T &lt; T_k$ 时结束模拟退火算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟退火</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulateAnneal</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  Tk = <span class="number">1e-8</span>  <span class="comment"># 终止温度</span></span><br><span class="line">  T0 = <span class="number">100</span>  <span class="comment"># 初始温度</span></span><br><span class="line">  d = <span class="number">0.5</span>  <span class="comment"># 降温系数</span></span><br><span class="line">  w = [[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x[<span class="number">0</span>]) + <span class="number">1</span>)]</span><br><span class="line">  <span class="comment"># now = loss_function(w, x, y)</span></span><br><span class="line">  <span class="comment"># nxt = now</span></span><br><span class="line">  <span class="comment"># min_value = now  # 损失函数最小值</span></span><br><span class="line">  </span><br><span class="line">  min_value = loss_function(w, x, y)  <span class="comment"># 损失函数最小值</span></span><br><span class="line">  T = T0  <span class="comment"># 当前温度</span></span><br><span class="line">  cnt = <span class="number">0</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">  <span class="keyword">while</span> T &gt; Tk:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    next = []</span><br><span class="line">    mn = <span class="number">1e20</span>  <span class="comment"># 临时的最小值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">      nw = []</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">        nw.append(i.copy())</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">        nw[i][<span class="number">0</span>] = w[i][<span class="number">0</span>] + math.cos(myrand() * <span class="number">2</span> * math.pi) * T</span><br><span class="line">      </span><br><span class="line">      nE = loss_function(nw, x, y)  <span class="comment"># 新状态</span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span> mn &gt; nE:  <span class="comment"># 更新最小值</span></span><br><span class="line">        mn = nE</span><br><span class="line">        next = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nw:</span><br><span class="line">          next.append(i.copy())</span><br><span class="line">    dE = mn - min_value  <span class="comment"># 能量差</span></span><br><span class="line">    <span class="keyword">if</span> dE / T &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> dE &lt; <span class="number">0</span> <span class="keyword">or</span> math.exp(dE / T) &lt; myrand():</span><br><span class="line">      min_value = mn</span><br><span class="line">      w = []</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> next:</span><br><span class="line">        w.append(i.copy())</span><br><span class="line">    T = T * d  <span class="comment"># 降温</span></span><br><span class="line">  print(cnt)</span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myrand</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">10000</span>) / <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = simulateAnneal(x, y)</span><br><span class="line"><span class="comment"># w = w.tolist()</span></span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))</span><br></pre></td></tr></table></figure>
<pre><code>40
[[2.5460349824125927], [-145.48637019150746]]
32.72257883908066
</code></pre><p>模拟退火求得的解随机性比较强，可能效果很好也可能很差，因为模拟退火能跳出局部最优解，也可能跳出全局最优解。</p>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>随机梯度下降法在计算梯度时加入随机因素，这样即便陷入局部最小点，计算出的梯度仍可能不为零，就有机会跳出局部极小继续搜索。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">  x = np.array(x)</span><br><span class="line">  y = np.array(y).reshape(len(y), <span class="number">1</span>)</span><br><span class="line">  x = np.concatenate((x, np.ones((len(x), <span class="number">1</span>))), axis=<span class="number">1</span>)</span><br><span class="line">  w = np.array(w)</span><br><span class="line"></span><br><span class="line">  x = np.matrix(x)</span><br><span class="line">  y = np.matrix(y)</span><br><span class="line">  w = np.matrix(w)</span><br><span class="line">  <span class="comment"># print(w)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * x.T * (x * w - y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_gradient_descent</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  lr = <span class="number">0.0000001</span>  <span class="comment"># learning rate</span></span><br><span class="line">  iteration = <span class="number">1000000</span></span><br><span class="line">  w = np.ones((<span class="number">1</span>, len(x[<span class="number">0</span>]) + <span class="number">1</span>)).T</span><br><span class="line">  w[len(x[<span class="number">0</span>])][<span class="number">0</span>] = y[<span class="number">0</span>] - x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    id = random.randint(<span class="number">0</span>, len(x) - <span class="number">1</span>)  <span class="comment"># 随机选择一组数据</span></span><br><span class="line">    w = w - lr * gradient(w, [x[id]], [y[id]])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x = [ [<span class="number">338.</span>], [<span class="number">333.</span>], [<span class="number">328.</span>], [<span class="number">207.</span>], [<span class="number">226.</span>], [<span class="number">25.</span>], [<span class="number">179.</span>], [<span class="number">60.</span>], [<span class="number">208.</span>], [<span class="number">606.</span>]]</span><br><span class="line">y = [ <span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line"></span><br><span class="line">w = random_gradient_descent(x, y)</span><br><span class="line">w = w.tolist()</span><br><span class="line"></span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">w0 = w[<span class="number">0</span>:len(w) - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(math.sqrt(loss_function(w0, w[-1][0], x, y)) / len(x))</span></span><br><span class="line">print(math.sqrt(loss_function(w, x, y)) / len(x))</span><br></pre></td></tr></table></figure>
<pre><code>[[1.4345358411567755], [275.41894946969995]]
84.25783548408097
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》周志华</a></li>
<li><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html" target="_blank" rel="noopener">台湾大学 李宏毅 机器学习 Machine Learning (2017,Fall)</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>机器学习</tag>
        <tag>西瓜书</tag>
      </tags>
  </entry>
</search>
